{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/linanqi/Hackathon/GameRoom/frontend/node_modules/@babel/runtime/helpers/toConsumableArray\");\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeMultisignedTxBytes = exports.makeMultisignedTx = exports.makeCompactBitArray = void 0;\nvar amino_1 = require(\"@cosmjs/amino\");\nvar encoding_1 = require(\"@cosmjs/encoding\");\nvar proto_signing_1 = require(\"@cosmjs/proto-signing\");\nvar multisig_1 = require(\"cosmjs-types/cosmos/crypto/multisig/v1beta1/multisig\");\nvar signing_1 = require(\"cosmjs-types/cosmos/tx/signing/v1beta1/signing\");\nvar tx_1 = require(\"cosmjs-types/cosmos/tx/v1beta1/tx\");\nvar tx_2 = require(\"cosmjs-types/cosmos/tx/v1beta1/tx\");\nvar long_1 = __importDefault(require(\"long\"));\nfunction makeCompactBitArray(bits) {\n  var byteCount = Math.ceil(bits.length / 8);\n  var extraBits = bits.length - Math.floor(bits.length / 8) * 8;\n  var bytes = new Uint8Array(byteCount); // zero-filled\n  bits.forEach(function (value, index) {\n    var bytePos = Math.floor(index / 8);\n    var bitPos = index % 8;\n    // eslint-disable-next-line no-bitwise\n    if (value) bytes[bytePos] |= 1 << 8 - 1 - bitPos;\n  });\n  return multisig_1.CompactBitArray.fromPartial({\n    elems: bytes,\n    extraBitsStored: extraBits\n  });\n}\nexports.makeCompactBitArray = makeCompactBitArray;\n/**\n * Creates a signed transaction from signer info, transaction body and signatures.\n * The result can be broadcasted after serialization.\n *\n * Consider using `makeMultisignedTxBytes` instead if you want to broadcast the\n * transaction immediately.\n */\nfunction makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures) {\n  var addresses = Array.from(signatures.keys());\n  var prefix = (0, encoding_1.fromBech32)(addresses[0]).prefix;\n  var signers = Array(multisigPubkey.value.pubkeys.length).fill(false);\n  var signaturesList = new Array();\n  for (var i = 0; i < multisigPubkey.value.pubkeys.length; i++) {\n    var signerAddress = (0, amino_1.pubkeyToAddress)(multisigPubkey.value.pubkeys[i], prefix);\n    var signature = signatures.get(signerAddress);\n    if (signature) {\n      signers[i] = true;\n      signaturesList.push(signature);\n    }\n  }\n  var signerInfo = {\n    publicKey: (0, proto_signing_1.encodePubkey)(multisigPubkey),\n    modeInfo: {\n      multi: {\n        bitarray: makeCompactBitArray(signers),\n        modeInfos: signaturesList.map(function (_) {\n          return {\n            single: {\n              mode: signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON\n            }\n          };\n        })\n      }\n    },\n    sequence: long_1.default.fromNumber(sequence)\n  };\n  var authInfo = tx_1.AuthInfo.fromPartial({\n    signerInfos: [signerInfo],\n    fee: {\n      amount: _toConsumableArray(fee.amount),\n      gasLimit: long_1.default.fromString(fee.gas)\n    }\n  });\n  var authInfoBytes = tx_1.AuthInfo.encode(authInfo).finish();\n  var signedTx = tx_2.TxRaw.fromPartial({\n    bodyBytes: bodyBytes,\n    authInfoBytes: authInfoBytes,\n    signatures: [multisig_1.MultiSignature.encode(multisig_1.MultiSignature.fromPartial({\n      signatures: signaturesList\n    })).finish()]\n  });\n  return signedTx;\n}\nexports.makeMultisignedTx = makeMultisignedTx;\n/**\n * Creates a signed transaction from signer info, transaction body and signatures.\n * The result can be broadcasted.\n *\n * This is a wrapper around `makeMultisignedTx` that encodes the transaction for broadcasting.\n */\nfunction makeMultisignedTxBytes(multisigPubkey, sequence, fee, bodyBytes, signatures) {\n  var signedTx = makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures);\n  return Uint8Array.from(tx_2.TxRaw.encode(signedTx).finish());\n}\nexports.makeMultisignedTxBytes = makeMultisignedTxBytes;","map":null,"metadata":{},"sourceType":"script"}