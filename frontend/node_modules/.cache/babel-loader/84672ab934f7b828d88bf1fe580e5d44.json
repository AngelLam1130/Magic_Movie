{"ast":null,"code":"'use strict';\n\nvar _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault');\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.verifyDigest32 = exports.pubKeyToKeyPair = exports.pubKeyToBytes = exports.isValidSeiAddress = exports.getAddressFromPubKey = void 0;\nvar _encoding = require('@cosmjs/encoding');\nvar _cryptoJs = _interopRequireDefault(require('crypto-js'));\nvar _elliptic = require('elliptic');\nvar isValidSeiAddress = function isValidSeiAddress(address) {\n  try {\n    var _fromBech = (0, _encoding.fromBech32)(address),\n      prefix = _fromBech.prefix;\n    return prefix && prefix === 'sei';\n  } catch (e) {\n    return false;\n  }\n};\nexports.isValidSeiAddress = isValidSeiAddress;\nvar pubKeyToKeyPair = function pubKeyToKeyPair(pubKey) {\n  var secp256k1 = new _elliptic.ec('secp256k1');\n  return secp256k1.keyFromPublic(Buffer.from(pubKey).toString('hex'), 'hex');\n};\nexports.pubKeyToKeyPair = pubKeyToKeyPair;\nvar pubKeyToBytes = function pubKeyToBytes(pubKey, uncompressed) {\n  if (uncompressed && pubKey.length === 65) {\n    return pubKey;\n  }\n  if (!uncompressed && pubKey.length === 33) {\n    return pubKey;\n  }\n  var keyPair = pubKeyToKeyPair(pubKey);\n  if (uncompressed) {\n    return new Uint8Array(Buffer.from(keyPair.getPublic().encode('hex', false), 'hex'));\n  } else {\n    return new Uint8Array(Buffer.from(keyPair.getPublic().encodeCompressed('hex'), 'hex'));\n  }\n};\nexports.pubKeyToBytes = pubKeyToBytes;\nvar getAddressFromPubKey = function getAddressFromPubKey(pubKey) {\n  var hash = _cryptoJs['default'].SHA256(_cryptoJs['default'].lib.WordArray.create(pubKeyToBytes(pubKey))).toString();\n  hash = _cryptoJs['default'].RIPEMD160(_cryptoJs['default'].enc.Hex.parse(hash)).toString();\n  return new Uint8Array(Buffer.from(hash, 'hex'));\n};\nexports.getAddressFromPubKey = getAddressFromPubKey;\nvar verifyDigest32 = function verifyDigest32(digest, signature, pubKey) {\n  if (digest.length !== 32) {\n    throw new Error('Invalid length of digest to verify: '.concat(digest.length));\n  }\n  if (signature.length !== 64) {\n    throw new Error('Invalid length of signature: '.concat(signature.length));\n  }\n  var secp256k1 = new _elliptic.ec('secp256k1');\n  var r = signature.slice(0, 32);\n  var s = signature.slice(32);\n  return secp256k1.verify(digest, {\n    r: Buffer.from(r).toString('hex'),\n    s: Buffer.from(s).toString('hex')\n  }, pubKeyToKeyPair(pubKey));\n};\nexports.verifyDigest32 = verifyDigest32;","map":{"version":3,"names":["_encoding","require","_cryptoJs","_interopRequireDefault","_elliptic","isValidSeiAddress","address","_fromBech","fromBech32","prefix","e","exports","pubKeyToKeyPair","pubKey","secp256k1","ec","keyFromPublic","Buffer","from","toString","pubKeyToBytes","uncompressed","length","keyPair","Uint8Array","getPublic","encode","encodeCompressed","getAddressFromPubKey","hash","SHA256","lib","WordArray","create","RIPEMD160","enc","Hex","parse","verifyDigest32","digest","signature","Error","concat","r","slice","s","verify"],"sources":["../../../src/lib/utils/address.ts"],"sourcesContent":["import { fromBech32 } from '@cosmjs/encoding';\nimport CryptoJS from 'crypto-js';\nimport { ec as EllipticCurve } from 'elliptic';\n\nexport const isValidSeiAddress = (address: string) => {\n\ttry {\n\t\tconst { prefix } = fromBech32(address);\n\t\treturn prefix && prefix === 'sei';\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n\nexport const pubKeyToKeyPair = (pubKey: Uint8Array): EllipticCurve.KeyPair => {\n\tconst secp256k1 = new EllipticCurve('secp256k1');\n\n\treturn secp256k1.keyFromPublic(Buffer.from(pubKey).toString('hex'), 'hex');\n};\n\nexport const pubKeyToBytes = (pubKey: Uint8Array, uncompressed?: boolean): Uint8Array => {\n\tif (uncompressed && pubKey.length === 65) {\n\t\treturn pubKey;\n\t}\n\tif (!uncompressed && pubKey.length === 33) {\n\t\treturn pubKey;\n\t}\n\n\tconst keyPair = pubKeyToKeyPair(pubKey);\n\n\tif (uncompressed) {\n\t\treturn new Uint8Array(Buffer.from(keyPair.getPublic().encode('hex', false), 'hex'));\n\t} else {\n\t\treturn new Uint8Array(Buffer.from(keyPair.getPublic().encodeCompressed('hex'), 'hex'));\n\t}\n};\n\nexport const getAddressFromPubKey = (pubKey: Uint8Array): Uint8Array => {\n\tlet hash = CryptoJS.SHA256(CryptoJS.lib.WordArray.create(pubKeyToBytes(pubKey) as any)).toString();\n\thash = CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(hash)).toString();\n\n\treturn new Uint8Array(Buffer.from(hash, 'hex'));\n};\n\nexport const verifyDigest32 = (digest: Uint8Array, signature: Uint8Array, pubKey: Uint8Array): boolean => {\n\tif (digest.length !== 32) {\n\t\tthrow new Error(`Invalid length of digest to verify: ${digest.length}`);\n\t}\n\n\tif (signature.length !== 64) {\n\t\tthrow new Error(`Invalid length of signature: ${signature.length}`);\n\t}\n\n\tconst secp256k1 = new EllipticCurve('secp256k1');\n\n\tconst r = signature.slice(0, 32);\n\tconst s = signature.slice(32);\n\n\treturn secp256k1.verify(\n\t\tdigest,\n\t\t{\n\t\t\tr: Buffer.from(r).toString('hex'),\n\t\t\ts: Buffer.from(s).toString('hex')\n\t\t},\n\t\tpubKeyToKeyPair(pubKey)\n\t);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}