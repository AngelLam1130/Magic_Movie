{"ast":null,"code":"\"use strict\";\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ProofSpec = exports.NonExistenceProof = exports.LengthOpSDKType = exports.LengthOp = exports.LeafOp = exports.InnerSpec = exports.InnerOp = exports.HashOpSDKType = exports.HashOp = exports.ExistenceProof = exports.CompressedNonExistenceProof = exports.CompressedExistenceProof = exports.CompressedBatchProof = exports.CompressedBatchEntry = exports.CommitmentProof = exports.BatchProof = exports.BatchEntry = void 0;\nexports.hashOpFromJSON = hashOpFromJSON;\nexports.hashOpToJSON = hashOpToJSON;\nexports.lengthOpFromJSON = lengthOpFromJSON;\nexports.lengthOpToJSON = lengthOpToJSON;\nvar _m0 = _interopRequireWildcard(require(\"protobufjs/minimal\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj[\"default\"] = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nvar HashOp;\nexports.HashOp = HashOp;\n(function (HashOp) {\n  HashOp[HashOp[\"NO_HASH\"] = 0] = \"NO_HASH\";\n  HashOp[HashOp[\"SHA256\"] = 1] = \"SHA256\";\n  HashOp[HashOp[\"SHA512\"] = 2] = \"SHA512\";\n  HashOp[HashOp[\"KECCAK\"] = 3] = \"KECCAK\";\n  HashOp[HashOp[\"RIPEMD160\"] = 4] = \"RIPEMD160\";\n  HashOp[HashOp[\"BITCOIN\"] = 5] = \"BITCOIN\";\n  HashOp[HashOp[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(HashOp || (exports.HashOp = HashOp = {}));\nvar HashOpSDKType = HashOp;\nexports.HashOpSDKType = HashOpSDKType;\nfunction hashOpFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"NO_HASH\":\n      return HashOp.NO_HASH;\n    case 1:\n    case \"SHA256\":\n      return HashOp.SHA256;\n    case 2:\n    case \"SHA512\":\n      return HashOp.SHA512;\n    case 3:\n    case \"KECCAK\":\n      return HashOp.KECCAK;\n    case 4:\n    case \"RIPEMD160\":\n      return HashOp.RIPEMD160;\n    case 5:\n    case \"BITCOIN\":\n      return HashOp.BITCOIN;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return HashOp.UNRECOGNIZED;\n  }\n}\nfunction hashOpToJSON(object) {\n  switch (object) {\n    case HashOp.NO_HASH:\n      return \"NO_HASH\";\n    case HashOp.SHA256:\n      return \"SHA256\";\n    case HashOp.SHA512:\n      return \"SHA512\";\n    case HashOp.KECCAK:\n      return \"KECCAK\";\n    case HashOp.RIPEMD160:\n      return \"RIPEMD160\";\n    case HashOp.BITCOIN:\n      return \"BITCOIN\";\n    case HashOp.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n/**\n * LengthOp defines how to process the key and value of the LeafOp\n * to include length information. After encoding the length with the given\n * algorithm, the length will be prepended to the key and value bytes.\n * (Each one with it's own encoded length)\n */\nvar LengthOp;\nexports.LengthOp = LengthOp;\n(function (LengthOp) {\n  LengthOp[LengthOp[\"NO_PREFIX\"] = 0] = \"NO_PREFIX\";\n  LengthOp[LengthOp[\"VAR_PROTO\"] = 1] = \"VAR_PROTO\";\n  LengthOp[LengthOp[\"VAR_RLP\"] = 2] = \"VAR_RLP\";\n  LengthOp[LengthOp[\"FIXED32_BIG\"] = 3] = \"FIXED32_BIG\";\n  LengthOp[LengthOp[\"FIXED32_LITTLE\"] = 4] = \"FIXED32_LITTLE\";\n  LengthOp[LengthOp[\"FIXED64_BIG\"] = 5] = \"FIXED64_BIG\";\n  LengthOp[LengthOp[\"FIXED64_LITTLE\"] = 6] = \"FIXED64_LITTLE\";\n  LengthOp[LengthOp[\"REQUIRE_32_BYTES\"] = 7] = \"REQUIRE_32_BYTES\";\n  LengthOp[LengthOp[\"REQUIRE_64_BYTES\"] = 8] = \"REQUIRE_64_BYTES\";\n  LengthOp[LengthOp[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(LengthOp || (exports.LengthOp = LengthOp = {}));\nvar LengthOpSDKType = LengthOp;\nexports.LengthOpSDKType = LengthOpSDKType;\nfunction lengthOpFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"NO_PREFIX\":\n      return LengthOp.NO_PREFIX;\n    case 1:\n    case \"VAR_PROTO\":\n      return LengthOp.VAR_PROTO;\n    case 2:\n    case \"VAR_RLP\":\n      return LengthOp.VAR_RLP;\n    case 3:\n    case \"FIXED32_BIG\":\n      return LengthOp.FIXED32_BIG;\n    case 4:\n    case \"FIXED32_LITTLE\":\n      return LengthOp.FIXED32_LITTLE;\n    case 5:\n    case \"FIXED64_BIG\":\n      return LengthOp.FIXED64_BIG;\n    case 6:\n    case \"FIXED64_LITTLE\":\n      return LengthOp.FIXED64_LITTLE;\n    case 7:\n    case \"REQUIRE_32_BYTES\":\n      return LengthOp.REQUIRE_32_BYTES;\n    case 8:\n    case \"REQUIRE_64_BYTES\":\n      return LengthOp.REQUIRE_64_BYTES;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return LengthOp.UNRECOGNIZED;\n  }\n}\nfunction lengthOpToJSON(object) {\n  switch (object) {\n    case LengthOp.NO_PREFIX:\n      return \"NO_PREFIX\";\n    case LengthOp.VAR_PROTO:\n      return \"VAR_PROTO\";\n    case LengthOp.VAR_RLP:\n      return \"VAR_RLP\";\n    case LengthOp.FIXED32_BIG:\n      return \"FIXED32_BIG\";\n    case LengthOp.FIXED32_LITTLE:\n      return \"FIXED32_LITTLE\";\n    case LengthOp.FIXED64_BIG:\n      return \"FIXED64_BIG\";\n    case LengthOp.FIXED64_LITTLE:\n      return \"FIXED64_LITTLE\";\n    case LengthOp.REQUIRE_32_BYTES:\n      return \"REQUIRE_32_BYTES\";\n    case LengthOp.REQUIRE_64_BYTES:\n      return \"REQUIRE_64_BYTES\";\n    case LengthOp.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n/**\n * ExistenceProof takes a key and a value and a set of steps to perform on it.\n * The result of peforming all these steps will provide a \"root hash\", which can\n * be compared to the value in a header.\n * \n * Since it is computationally infeasible to produce a hash collission for any of the used\n * cryptographic hash functions, if someone can provide a series of operations to transform\n * a given key and value into a root hash that matches some trusted root, these key and values\n * must be in the referenced merkle tree.\n * \n * The only possible issue is maliablity in LeafOp, such as providing extra prefix data,\n * which should be controlled by a spec. Eg. with lengthOp as NONE,\n * prefix = FOO, key = BAR, value = CHOICE\n * and\n * prefix = F, key = OOBAR, value = CHOICE\n * would produce the same value.\n * \n * With LengthOp this is tricker but not impossible. Which is why the \"leafPrefixEqual\" field\n * in the ProofSpec is valuable to prevent this mutability. And why all trees should\n * length-prefix the data before hashing it.\n */\n\nfunction createBaseExistenceProof() {\n  return {\n    key: new Uint8Array(),\n    value: new Uint8Array(),\n    leaf: LeafOp.fromPartial({}),\n    path: []\n  };\n}\nvar ExistenceProof = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    if (message.value.length !== 0) {\n      writer.uint32(18).bytes(message.value);\n    }\n    if (message.leaf !== undefined) {\n      LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();\n    }\n    var _iterator = _createForOfIteratorHelper(message.path),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var v = _step.value;\n        InnerOp.encode(v, writer.uint32(34).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseExistenceProof();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        case 2:\n          message.value = reader.bytes();\n          break;\n        case 3:\n          message.leaf = LeafOp.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.path.push(InnerOp.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$key, _object$value, _object$path;\n    var message = createBaseExistenceProof();\n    message.key = (_object$key = object.key) !== null && _object$key !== void 0 ? _object$key : new Uint8Array();\n    message.value = (_object$value = object.value) !== null && _object$value !== void 0 ? _object$value : new Uint8Array();\n    message.leaf = object.leaf !== undefined && object.leaf !== null ? LeafOp.fromPartial(object.leaf) : undefined;\n    message.path = ((_object$path = object.path) === null || _object$path === void 0 ? void 0 : _object$path.map(function (e) {\n      return InnerOp.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.ExistenceProof = ExistenceProof;\nfunction createBaseNonExistenceProof() {\n  return {\n    key: new Uint8Array(),\n    left: ExistenceProof.fromPartial({}),\n    right: ExistenceProof.fromPartial({})\n  };\n}\nvar NonExistenceProof = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    if (message.left !== undefined) {\n      ExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.right !== undefined) {\n      ExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseNonExistenceProof();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        case 2:\n          message.left = ExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.right = ExistenceProof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$key2;\n    var message = createBaseNonExistenceProof();\n    message.key = (_object$key2 = object.key) !== null && _object$key2 !== void 0 ? _object$key2 : new Uint8Array();\n    message.left = object.left !== undefined && object.left !== null ? ExistenceProof.fromPartial(object.left) : undefined;\n    message.right = object.right !== undefined && object.right !== null ? ExistenceProof.fromPartial(object.right) : undefined;\n    return message;\n  }\n};\nexports.NonExistenceProof = NonExistenceProof;\nfunction createBaseCommitmentProof() {\n  return {\n    exist: undefined,\n    nonexist: undefined,\n    batch: undefined,\n    compressed: undefined\n  };\n}\nvar CommitmentProof = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.exist !== undefined) {\n      ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.nonexist !== undefined) {\n      NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.batch !== undefined) {\n      BatchProof.encode(message.batch, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.compressed !== undefined) {\n      CompressedBatchProof.encode(message.compressed, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseCommitmentProof();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.exist = ExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.nonexist = NonExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.batch = BatchProof.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.compressed = CompressedBatchProof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = createBaseCommitmentProof();\n    message.exist = object.exist !== undefined && object.exist !== null ? ExistenceProof.fromPartial(object.exist) : undefined;\n    message.nonexist = object.nonexist !== undefined && object.nonexist !== null ? NonExistenceProof.fromPartial(object.nonexist) : undefined;\n    message.batch = object.batch !== undefined && object.batch !== null ? BatchProof.fromPartial(object.batch) : undefined;\n    message.compressed = object.compressed !== undefined && object.compressed !== null ? CompressedBatchProof.fromPartial(object.compressed) : undefined;\n    return message;\n  }\n};\nexports.CommitmentProof = CommitmentProof;\nfunction createBaseLeafOp() {\n  return {\n    hash: 0,\n    prehashKey: 0,\n    prehashValue: 0,\n    length: 0,\n    prefix: new Uint8Array()\n  };\n}\nvar LeafOp = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.hash !== 0) {\n      writer.uint32(8).int32(message.hash);\n    }\n    if (message.prehashKey !== 0) {\n      writer.uint32(16).int32(message.prehashKey);\n    }\n    if (message.prehashValue !== 0) {\n      writer.uint32(24).int32(message.prehashValue);\n    }\n    if (message.length !== 0) {\n      writer.uint32(32).int32(message.length);\n    }\n    if (message.prefix.length !== 0) {\n      writer.uint32(42).bytes(message.prefix);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseLeafOp();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.int32();\n          break;\n        case 2:\n          message.prehashKey = reader.int32();\n          break;\n        case 3:\n          message.prehashValue = reader.int32();\n          break;\n        case 4:\n          message.length = reader.int32();\n          break;\n        case 5:\n          message.prefix = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$hash, _object$prehashKey, _object$prehashValue, _object$length, _object$prefix;\n    var message = createBaseLeafOp();\n    message.hash = (_object$hash = object.hash) !== null && _object$hash !== void 0 ? _object$hash : 0;\n    message.prehashKey = (_object$prehashKey = object.prehashKey) !== null && _object$prehashKey !== void 0 ? _object$prehashKey : 0;\n    message.prehashValue = (_object$prehashValue = object.prehashValue) !== null && _object$prehashValue !== void 0 ? _object$prehashValue : 0;\n    message.length = (_object$length = object.length) !== null && _object$length !== void 0 ? _object$length : 0;\n    message.prefix = (_object$prefix = object.prefix) !== null && _object$prefix !== void 0 ? _object$prefix : new Uint8Array();\n    return message;\n  }\n};\nexports.LeafOp = LeafOp;\nfunction createBaseInnerOp() {\n  return {\n    hash: 0,\n    prefix: new Uint8Array(),\n    suffix: new Uint8Array()\n  };\n}\nvar InnerOp = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.hash !== 0) {\n      writer.uint32(8).int32(message.hash);\n    }\n    if (message.prefix.length !== 0) {\n      writer.uint32(18).bytes(message.prefix);\n    }\n    if (message.suffix.length !== 0) {\n      writer.uint32(26).bytes(message.suffix);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseInnerOp();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.int32();\n          break;\n        case 2:\n          message.prefix = reader.bytes();\n          break;\n        case 3:\n          message.suffix = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$hash2, _object$prefix2, _object$suffix;\n    var message = createBaseInnerOp();\n    message.hash = (_object$hash2 = object.hash) !== null && _object$hash2 !== void 0 ? _object$hash2 : 0;\n    message.prefix = (_object$prefix2 = object.prefix) !== null && _object$prefix2 !== void 0 ? _object$prefix2 : new Uint8Array();\n    message.suffix = (_object$suffix = object.suffix) !== null && _object$suffix !== void 0 ? _object$suffix : new Uint8Array();\n    return message;\n  }\n};\nexports.InnerOp = InnerOp;\nfunction createBaseProofSpec() {\n  return {\n    leafSpec: LeafOp.fromPartial({}),\n    innerSpec: InnerSpec.fromPartial({}),\n    maxDepth: 0,\n    minDepth: 0\n  };\n}\nvar ProofSpec = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.leafSpec !== undefined) {\n      LeafOp.encode(message.leafSpec, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.innerSpec !== undefined) {\n      InnerSpec.encode(message.innerSpec, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.maxDepth !== 0) {\n      writer.uint32(24).int32(message.maxDepth);\n    }\n    if (message.minDepth !== 0) {\n      writer.uint32(32).int32(message.minDepth);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseProofSpec();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.leafSpec = LeafOp.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.innerSpec = InnerSpec.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.maxDepth = reader.int32();\n          break;\n        case 4:\n          message.minDepth = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$maxDepth, _object$minDepth;\n    var message = createBaseProofSpec();\n    message.leafSpec = object.leafSpec !== undefined && object.leafSpec !== null ? LeafOp.fromPartial(object.leafSpec) : undefined;\n    message.innerSpec = object.innerSpec !== undefined && object.innerSpec !== null ? InnerSpec.fromPartial(object.innerSpec) : undefined;\n    message.maxDepth = (_object$maxDepth = object.maxDepth) !== null && _object$maxDepth !== void 0 ? _object$maxDepth : 0;\n    message.minDepth = (_object$minDepth = object.minDepth) !== null && _object$minDepth !== void 0 ? _object$minDepth : 0;\n    return message;\n  }\n};\nexports.ProofSpec = ProofSpec;\nfunction createBaseInnerSpec() {\n  return {\n    childOrder: [],\n    childSize: 0,\n    minPrefixLength: 0,\n    maxPrefixLength: 0,\n    emptyChild: new Uint8Array(),\n    hash: 0\n  };\n}\nvar InnerSpec = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    writer.uint32(10).fork();\n    var _iterator2 = _createForOfIteratorHelper(message.childOrder),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var v = _step2.value;\n        writer.int32(v);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    writer.ldelim();\n    if (message.childSize !== 0) {\n      writer.uint32(16).int32(message.childSize);\n    }\n    if (message.minPrefixLength !== 0) {\n      writer.uint32(24).int32(message.minPrefixLength);\n    }\n    if (message.maxPrefixLength !== 0) {\n      writer.uint32(32).int32(message.maxPrefixLength);\n    }\n    if (message.emptyChild.length !== 0) {\n      writer.uint32(42).bytes(message.emptyChild);\n    }\n    if (message.hash !== 0) {\n      writer.uint32(48).int32(message.hash);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseInnerSpec();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if ((tag & 7) === 2) {\n            var end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.childOrder.push(reader.int32());\n            }\n          } else {\n            message.childOrder.push(reader.int32());\n          }\n          break;\n        case 2:\n          message.childSize = reader.int32();\n          break;\n        case 3:\n          message.minPrefixLength = reader.int32();\n          break;\n        case 4:\n          message.maxPrefixLength = reader.int32();\n          break;\n        case 5:\n          message.emptyChild = reader.bytes();\n          break;\n        case 6:\n          message.hash = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$childOrder, _object$childSize, _object$minPrefixLeng, _object$maxPrefixLeng, _object$emptyChild, _object$hash3;\n    var message = createBaseInnerSpec();\n    message.childOrder = ((_object$childOrder = object.childOrder) === null || _object$childOrder === void 0 ? void 0 : _object$childOrder.map(function (e) {\n      return e;\n    })) || [];\n    message.childSize = (_object$childSize = object.childSize) !== null && _object$childSize !== void 0 ? _object$childSize : 0;\n    message.minPrefixLength = (_object$minPrefixLeng = object.minPrefixLength) !== null && _object$minPrefixLeng !== void 0 ? _object$minPrefixLeng : 0;\n    message.maxPrefixLength = (_object$maxPrefixLeng = object.maxPrefixLength) !== null && _object$maxPrefixLeng !== void 0 ? _object$maxPrefixLeng : 0;\n    message.emptyChild = (_object$emptyChild = object.emptyChild) !== null && _object$emptyChild !== void 0 ? _object$emptyChild : new Uint8Array();\n    message.hash = (_object$hash3 = object.hash) !== null && _object$hash3 !== void 0 ? _object$hash3 : 0;\n    return message;\n  }\n};\nexports.InnerSpec = InnerSpec;\nfunction createBaseBatchProof() {\n  return {\n    entries: []\n  };\n}\nvar BatchProof = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    var _iterator3 = _createForOfIteratorHelper(message.entries),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var v = _step3.value;\n        BatchEntry.encode(v, writer.uint32(10).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseBatchProof();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.entries.push(BatchEntry.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$entries;\n    var message = createBaseBatchProof();\n    message.entries = ((_object$entries = object.entries) === null || _object$entries === void 0 ? void 0 : _object$entries.map(function (e) {\n      return BatchEntry.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.BatchProof = BatchProof;\nfunction createBaseBatchEntry() {\n  return {\n    exist: undefined,\n    nonexist: undefined\n  };\n}\nvar BatchEntry = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.exist !== undefined) {\n      ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.nonexist !== undefined) {\n      NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseBatchEntry();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.exist = ExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.nonexist = NonExistenceProof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = createBaseBatchEntry();\n    message.exist = object.exist !== undefined && object.exist !== null ? ExistenceProof.fromPartial(object.exist) : undefined;\n    message.nonexist = object.nonexist !== undefined && object.nonexist !== null ? NonExistenceProof.fromPartial(object.nonexist) : undefined;\n    return message;\n  }\n};\nexports.BatchEntry = BatchEntry;\nfunction createBaseCompressedBatchProof() {\n  return {\n    entries: [],\n    lookupInners: []\n  };\n}\nvar CompressedBatchProof = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    var _iterator4 = _createForOfIteratorHelper(message.entries),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var v = _step4.value;\n        CompressedBatchEntry.encode(v, writer.uint32(10).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n    var _iterator5 = _createForOfIteratorHelper(message.lookupInners),\n      _step5;\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var _v = _step5.value;\n        InnerOp.encode(_v, writer.uint32(18).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseCompressedBatchProof();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.entries.push(CompressedBatchEntry.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.lookupInners.push(InnerOp.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$entries2, _object$lookupInners;\n    var message = createBaseCompressedBatchProof();\n    message.entries = ((_object$entries2 = object.entries) === null || _object$entries2 === void 0 ? void 0 : _object$entries2.map(function (e) {\n      return CompressedBatchEntry.fromPartial(e);\n    })) || [];\n    message.lookupInners = ((_object$lookupInners = object.lookupInners) === null || _object$lookupInners === void 0 ? void 0 : _object$lookupInners.map(function (e) {\n      return InnerOp.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.CompressedBatchProof = CompressedBatchProof;\nfunction createBaseCompressedBatchEntry() {\n  return {\n    exist: undefined,\n    nonexist: undefined\n  };\n}\nvar CompressedBatchEntry = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.exist !== undefined) {\n      CompressedExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.nonexist !== undefined) {\n      CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseCompressedBatchEntry();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.exist = CompressedExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.nonexist = CompressedNonExistenceProof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = createBaseCompressedBatchEntry();\n    message.exist = object.exist !== undefined && object.exist !== null ? CompressedExistenceProof.fromPartial(object.exist) : undefined;\n    message.nonexist = object.nonexist !== undefined && object.nonexist !== null ? CompressedNonExistenceProof.fromPartial(object.nonexist) : undefined;\n    return message;\n  }\n};\nexports.CompressedBatchEntry = CompressedBatchEntry;\nfunction createBaseCompressedExistenceProof() {\n  return {\n    key: new Uint8Array(),\n    value: new Uint8Array(),\n    leaf: LeafOp.fromPartial({}),\n    path: []\n  };\n}\nvar CompressedExistenceProof = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    if (message.value.length !== 0) {\n      writer.uint32(18).bytes(message.value);\n    }\n    if (message.leaf !== undefined) {\n      LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();\n    }\n    writer.uint32(34).fork();\n    var _iterator6 = _createForOfIteratorHelper(message.path),\n      _step6;\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var v = _step6.value;\n        writer.int32(v);\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n    writer.ldelim();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseCompressedExistenceProof();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        case 2:\n          message.value = reader.bytes();\n          break;\n        case 3:\n          message.leaf = LeafOp.decode(reader, reader.uint32());\n          break;\n        case 4:\n          if ((tag & 7) === 2) {\n            var end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.path.push(reader.int32());\n            }\n          } else {\n            message.path.push(reader.int32());\n          }\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$key3, _object$value2, _object$path2;\n    var message = createBaseCompressedExistenceProof();\n    message.key = (_object$key3 = object.key) !== null && _object$key3 !== void 0 ? _object$key3 : new Uint8Array();\n    message.value = (_object$value2 = object.value) !== null && _object$value2 !== void 0 ? _object$value2 : new Uint8Array();\n    message.leaf = object.leaf !== undefined && object.leaf !== null ? LeafOp.fromPartial(object.leaf) : undefined;\n    message.path = ((_object$path2 = object.path) === null || _object$path2 === void 0 ? void 0 : _object$path2.map(function (e) {\n      return e;\n    })) || [];\n    return message;\n  }\n};\nexports.CompressedExistenceProof = CompressedExistenceProof;\nfunction createBaseCompressedNonExistenceProof() {\n  return {\n    key: new Uint8Array(),\n    left: CompressedExistenceProof.fromPartial({}),\n    right: CompressedExistenceProof.fromPartial({})\n  };\n}\nvar CompressedNonExistenceProof = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    if (message.left !== undefined) {\n      CompressedExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.right !== undefined) {\n      CompressedExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseCompressedNonExistenceProof();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        case 2:\n          message.left = CompressedExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.right = CompressedExistenceProof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$key4;\n    var message = createBaseCompressedNonExistenceProof();\n    message.key = (_object$key4 = object.key) !== null && _object$key4 !== void 0 ? _object$key4 : new Uint8Array();\n    message.left = object.left !== undefined && object.left !== null ? CompressedExistenceProof.fromPartial(object.left) : undefined;\n    message.right = object.right !== undefined && object.right !== null ? CompressedExistenceProof.fromPartial(object.right) : undefined;\n    return message;\n  }\n};\nexports.CompressedNonExistenceProof = CompressedNonExistenceProof;","map":{"version":3,"names":["_typeof","require","Object","defineProperty","exports","value","ProofSpec","NonExistenceProof","LengthOpSDKType","LengthOp","LeafOp","InnerSpec","InnerOp","HashOpSDKType","HashOp","ExistenceProof","CompressedNonExistenceProof","CompressedExistenceProof","CompressedBatchProof","CompressedBatchEntry","CommitmentProof","BatchProof","BatchEntry","hashOpFromJSON","hashOpToJSON","lengthOpFromJSON","lengthOpToJSON","_m0","_interopRequireWildcard","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","e","_e","f","TypeError","normalCompletion","didErr","err","step","next","_e2","minLen","_arrayLikeToArray","toString","slice","constructor","name","from","test","arr","len","arr2","object","NO_HASH","SHA256","SHA512","KECCAK","RIPEMD160","BITCOIN","UNRECOGNIZED","NO_PREFIX","VAR_PROTO","VAR_RLP","FIXED32_BIG","FIXED32_LITTLE","FIXED64_BIG","FIXED64_LITTLE","REQUIRE_32_BYTES","REQUIRE_64_BYTES","createBaseExistenceProof","Uint8Array","leaf","fromPartial","path","encode","message","writer","arguments","undefined","Writer","create","uint32","bytes","fork","ldelim","_iterator","_step","v","decode","input","reader","Reader","end","pos","tag","push","skipType","_object$key","_object$value","_object$path","map","createBaseNonExistenceProof","left","right","_object$key2","createBaseCommitmentProof","exist","nonexist","batch","compressed","createBaseLeafOp","hash","prehashKey","prehashValue","prefix","int32","_object$hash","_object$prehashKey","_object$prehashValue","_object$length","_object$prefix","createBaseInnerOp","suffix","_object$hash2","_object$prefix2","_object$suffix","createBaseProofSpec","leafSpec","innerSpec","maxDepth","minDepth","_object$maxDepth","_object$minDepth","createBaseInnerSpec","childOrder","childSize","minPrefixLength","maxPrefixLength","emptyChild","_iterator2","_step2","end2","_object$childOrder","_object$childSize","_object$minPrefixLeng","_object$maxPrefixLeng","_object$emptyChild","_object$hash3","createBaseBatchProof","entries","_iterator3","_step3","_object$entries","createBaseBatchEntry","createBaseCompressedBatchProof","lookupInners","_iterator4","_step4","_iterator5","_step5","_v","_object$entries2","_object$lookupInners","createBaseCompressedBatchEntry","createBaseCompressedExistenceProof","_iterator6","_step6","_object$key3","_object$value2","_object$path2","createBaseCompressedNonExistenceProof","_object$key4"],"sources":["/Users/linanqi/node_modules/@sei-js/proto/main/codegen/confio/proofs.js"],"sourcesContent":["\"use strict\";\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ProofSpec = exports.NonExistenceProof = exports.LengthOpSDKType = exports.LengthOp = exports.LeafOp = exports.InnerSpec = exports.InnerOp = exports.HashOpSDKType = exports.HashOp = exports.ExistenceProof = exports.CompressedNonExistenceProof = exports.CompressedExistenceProof = exports.CompressedBatchProof = exports.CompressedBatchEntry = exports.CommitmentProof = exports.BatchProof = exports.BatchEntry = void 0;\nexports.hashOpFromJSON = hashOpFromJSON;\nexports.hashOpToJSON = hashOpToJSON;\nexports.lengthOpFromJSON = lengthOpFromJSON;\nexports.lengthOpToJSON = lengthOpToJSON;\nvar _m0 = _interopRequireWildcard(require(\"protobufjs/minimal\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar HashOp;\nexports.HashOp = HashOp;\n(function (HashOp) {\n  HashOp[HashOp[\"NO_HASH\"] = 0] = \"NO_HASH\";\n  HashOp[HashOp[\"SHA256\"] = 1] = \"SHA256\";\n  HashOp[HashOp[\"SHA512\"] = 2] = \"SHA512\";\n  HashOp[HashOp[\"KECCAK\"] = 3] = \"KECCAK\";\n  HashOp[HashOp[\"RIPEMD160\"] = 4] = \"RIPEMD160\";\n  HashOp[HashOp[\"BITCOIN\"] = 5] = \"BITCOIN\";\n  HashOp[HashOp[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(HashOp || (exports.HashOp = HashOp = {}));\nvar HashOpSDKType = HashOp;\nexports.HashOpSDKType = HashOpSDKType;\nfunction hashOpFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"NO_HASH\":\n      return HashOp.NO_HASH;\n    case 1:\n    case \"SHA256\":\n      return HashOp.SHA256;\n    case 2:\n    case \"SHA512\":\n      return HashOp.SHA512;\n    case 3:\n    case \"KECCAK\":\n      return HashOp.KECCAK;\n    case 4:\n    case \"RIPEMD160\":\n      return HashOp.RIPEMD160;\n    case 5:\n    case \"BITCOIN\":\n      return HashOp.BITCOIN;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return HashOp.UNRECOGNIZED;\n  }\n}\nfunction hashOpToJSON(object) {\n  switch (object) {\n    case HashOp.NO_HASH:\n      return \"NO_HASH\";\n    case HashOp.SHA256:\n      return \"SHA256\";\n    case HashOp.SHA512:\n      return \"SHA512\";\n    case HashOp.KECCAK:\n      return \"KECCAK\";\n    case HashOp.RIPEMD160:\n      return \"RIPEMD160\";\n    case HashOp.BITCOIN:\n      return \"BITCOIN\";\n    case HashOp.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n/**\n * LengthOp defines how to process the key and value of the LeafOp\n * to include length information. After encoding the length with the given\n * algorithm, the length will be prepended to the key and value bytes.\n * (Each one with it's own encoded length)\n */\nvar LengthOp;\nexports.LengthOp = LengthOp;\n(function (LengthOp) {\n  LengthOp[LengthOp[\"NO_PREFIX\"] = 0] = \"NO_PREFIX\";\n  LengthOp[LengthOp[\"VAR_PROTO\"] = 1] = \"VAR_PROTO\";\n  LengthOp[LengthOp[\"VAR_RLP\"] = 2] = \"VAR_RLP\";\n  LengthOp[LengthOp[\"FIXED32_BIG\"] = 3] = \"FIXED32_BIG\";\n  LengthOp[LengthOp[\"FIXED32_LITTLE\"] = 4] = \"FIXED32_LITTLE\";\n  LengthOp[LengthOp[\"FIXED64_BIG\"] = 5] = \"FIXED64_BIG\";\n  LengthOp[LengthOp[\"FIXED64_LITTLE\"] = 6] = \"FIXED64_LITTLE\";\n  LengthOp[LengthOp[\"REQUIRE_32_BYTES\"] = 7] = \"REQUIRE_32_BYTES\";\n  LengthOp[LengthOp[\"REQUIRE_64_BYTES\"] = 8] = \"REQUIRE_64_BYTES\";\n  LengthOp[LengthOp[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(LengthOp || (exports.LengthOp = LengthOp = {}));\nvar LengthOpSDKType = LengthOp;\nexports.LengthOpSDKType = LengthOpSDKType;\nfunction lengthOpFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"NO_PREFIX\":\n      return LengthOp.NO_PREFIX;\n    case 1:\n    case \"VAR_PROTO\":\n      return LengthOp.VAR_PROTO;\n    case 2:\n    case \"VAR_RLP\":\n      return LengthOp.VAR_RLP;\n    case 3:\n    case \"FIXED32_BIG\":\n      return LengthOp.FIXED32_BIG;\n    case 4:\n    case \"FIXED32_LITTLE\":\n      return LengthOp.FIXED32_LITTLE;\n    case 5:\n    case \"FIXED64_BIG\":\n      return LengthOp.FIXED64_BIG;\n    case 6:\n    case \"FIXED64_LITTLE\":\n      return LengthOp.FIXED64_LITTLE;\n    case 7:\n    case \"REQUIRE_32_BYTES\":\n      return LengthOp.REQUIRE_32_BYTES;\n    case 8:\n    case \"REQUIRE_64_BYTES\":\n      return LengthOp.REQUIRE_64_BYTES;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return LengthOp.UNRECOGNIZED;\n  }\n}\nfunction lengthOpToJSON(object) {\n  switch (object) {\n    case LengthOp.NO_PREFIX:\n      return \"NO_PREFIX\";\n    case LengthOp.VAR_PROTO:\n      return \"VAR_PROTO\";\n    case LengthOp.VAR_RLP:\n      return \"VAR_RLP\";\n    case LengthOp.FIXED32_BIG:\n      return \"FIXED32_BIG\";\n    case LengthOp.FIXED32_LITTLE:\n      return \"FIXED32_LITTLE\";\n    case LengthOp.FIXED64_BIG:\n      return \"FIXED64_BIG\";\n    case LengthOp.FIXED64_LITTLE:\n      return \"FIXED64_LITTLE\";\n    case LengthOp.REQUIRE_32_BYTES:\n      return \"REQUIRE_32_BYTES\";\n    case LengthOp.REQUIRE_64_BYTES:\n      return \"REQUIRE_64_BYTES\";\n    case LengthOp.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n/**\n * ExistenceProof takes a key and a value and a set of steps to perform on it.\n * The result of peforming all these steps will provide a \"root hash\", which can\n * be compared to the value in a header.\n * \n * Since it is computationally infeasible to produce a hash collission for any of the used\n * cryptographic hash functions, if someone can provide a series of operations to transform\n * a given key and value into a root hash that matches some trusted root, these key and values\n * must be in the referenced merkle tree.\n * \n * The only possible issue is maliablity in LeafOp, such as providing extra prefix data,\n * which should be controlled by a spec. Eg. with lengthOp as NONE,\n * prefix = FOO, key = BAR, value = CHOICE\n * and\n * prefix = F, key = OOBAR, value = CHOICE\n * would produce the same value.\n * \n * With LengthOp this is tricker but not impossible. Which is why the \"leafPrefixEqual\" field\n * in the ProofSpec is valuable to prevent this mutability. And why all trees should\n * length-prefix the data before hashing it.\n */\n\nfunction createBaseExistenceProof() {\n  return {\n    key: new Uint8Array(),\n    value: new Uint8Array(),\n    leaf: LeafOp.fromPartial({}),\n    path: []\n  };\n}\nvar ExistenceProof = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    if (message.value.length !== 0) {\n      writer.uint32(18).bytes(message.value);\n    }\n    if (message.leaf !== undefined) {\n      LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();\n    }\n    var _iterator = _createForOfIteratorHelper(message.path),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var v = _step.value;\n        InnerOp.encode(v, writer.uint32(34).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseExistenceProof();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        case 2:\n          message.value = reader.bytes();\n          break;\n        case 3:\n          message.leaf = LeafOp.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.path.push(InnerOp.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$key, _object$value, _object$path;\n    var message = createBaseExistenceProof();\n    message.key = (_object$key = object.key) !== null && _object$key !== void 0 ? _object$key : new Uint8Array();\n    message.value = (_object$value = object.value) !== null && _object$value !== void 0 ? _object$value : new Uint8Array();\n    message.leaf = object.leaf !== undefined && object.leaf !== null ? LeafOp.fromPartial(object.leaf) : undefined;\n    message.path = ((_object$path = object.path) === null || _object$path === void 0 ? void 0 : _object$path.map(function (e) {\n      return InnerOp.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.ExistenceProof = ExistenceProof;\nfunction createBaseNonExistenceProof() {\n  return {\n    key: new Uint8Array(),\n    left: ExistenceProof.fromPartial({}),\n    right: ExistenceProof.fromPartial({})\n  };\n}\nvar NonExistenceProof = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    if (message.left !== undefined) {\n      ExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.right !== undefined) {\n      ExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseNonExistenceProof();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        case 2:\n          message.left = ExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.right = ExistenceProof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$key2;\n    var message = createBaseNonExistenceProof();\n    message.key = (_object$key2 = object.key) !== null && _object$key2 !== void 0 ? _object$key2 : new Uint8Array();\n    message.left = object.left !== undefined && object.left !== null ? ExistenceProof.fromPartial(object.left) : undefined;\n    message.right = object.right !== undefined && object.right !== null ? ExistenceProof.fromPartial(object.right) : undefined;\n    return message;\n  }\n};\nexports.NonExistenceProof = NonExistenceProof;\nfunction createBaseCommitmentProof() {\n  return {\n    exist: undefined,\n    nonexist: undefined,\n    batch: undefined,\n    compressed: undefined\n  };\n}\nvar CommitmentProof = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.exist !== undefined) {\n      ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.nonexist !== undefined) {\n      NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.batch !== undefined) {\n      BatchProof.encode(message.batch, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.compressed !== undefined) {\n      CompressedBatchProof.encode(message.compressed, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseCommitmentProof();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.exist = ExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.nonexist = NonExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.batch = BatchProof.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.compressed = CompressedBatchProof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = createBaseCommitmentProof();\n    message.exist = object.exist !== undefined && object.exist !== null ? ExistenceProof.fromPartial(object.exist) : undefined;\n    message.nonexist = object.nonexist !== undefined && object.nonexist !== null ? NonExistenceProof.fromPartial(object.nonexist) : undefined;\n    message.batch = object.batch !== undefined && object.batch !== null ? BatchProof.fromPartial(object.batch) : undefined;\n    message.compressed = object.compressed !== undefined && object.compressed !== null ? CompressedBatchProof.fromPartial(object.compressed) : undefined;\n    return message;\n  }\n};\nexports.CommitmentProof = CommitmentProof;\nfunction createBaseLeafOp() {\n  return {\n    hash: 0,\n    prehashKey: 0,\n    prehashValue: 0,\n    length: 0,\n    prefix: new Uint8Array()\n  };\n}\nvar LeafOp = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.hash !== 0) {\n      writer.uint32(8).int32(message.hash);\n    }\n    if (message.prehashKey !== 0) {\n      writer.uint32(16).int32(message.prehashKey);\n    }\n    if (message.prehashValue !== 0) {\n      writer.uint32(24).int32(message.prehashValue);\n    }\n    if (message.length !== 0) {\n      writer.uint32(32).int32(message.length);\n    }\n    if (message.prefix.length !== 0) {\n      writer.uint32(42).bytes(message.prefix);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseLeafOp();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.int32();\n          break;\n        case 2:\n          message.prehashKey = reader.int32();\n          break;\n        case 3:\n          message.prehashValue = reader.int32();\n          break;\n        case 4:\n          message.length = reader.int32();\n          break;\n        case 5:\n          message.prefix = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$hash, _object$prehashKey, _object$prehashValue, _object$length, _object$prefix;\n    var message = createBaseLeafOp();\n    message.hash = (_object$hash = object.hash) !== null && _object$hash !== void 0 ? _object$hash : 0;\n    message.prehashKey = (_object$prehashKey = object.prehashKey) !== null && _object$prehashKey !== void 0 ? _object$prehashKey : 0;\n    message.prehashValue = (_object$prehashValue = object.prehashValue) !== null && _object$prehashValue !== void 0 ? _object$prehashValue : 0;\n    message.length = (_object$length = object.length) !== null && _object$length !== void 0 ? _object$length : 0;\n    message.prefix = (_object$prefix = object.prefix) !== null && _object$prefix !== void 0 ? _object$prefix : new Uint8Array();\n    return message;\n  }\n};\nexports.LeafOp = LeafOp;\nfunction createBaseInnerOp() {\n  return {\n    hash: 0,\n    prefix: new Uint8Array(),\n    suffix: new Uint8Array()\n  };\n}\nvar InnerOp = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.hash !== 0) {\n      writer.uint32(8).int32(message.hash);\n    }\n    if (message.prefix.length !== 0) {\n      writer.uint32(18).bytes(message.prefix);\n    }\n    if (message.suffix.length !== 0) {\n      writer.uint32(26).bytes(message.suffix);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseInnerOp();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.int32();\n          break;\n        case 2:\n          message.prefix = reader.bytes();\n          break;\n        case 3:\n          message.suffix = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$hash2, _object$prefix2, _object$suffix;\n    var message = createBaseInnerOp();\n    message.hash = (_object$hash2 = object.hash) !== null && _object$hash2 !== void 0 ? _object$hash2 : 0;\n    message.prefix = (_object$prefix2 = object.prefix) !== null && _object$prefix2 !== void 0 ? _object$prefix2 : new Uint8Array();\n    message.suffix = (_object$suffix = object.suffix) !== null && _object$suffix !== void 0 ? _object$suffix : new Uint8Array();\n    return message;\n  }\n};\nexports.InnerOp = InnerOp;\nfunction createBaseProofSpec() {\n  return {\n    leafSpec: LeafOp.fromPartial({}),\n    innerSpec: InnerSpec.fromPartial({}),\n    maxDepth: 0,\n    minDepth: 0\n  };\n}\nvar ProofSpec = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.leafSpec !== undefined) {\n      LeafOp.encode(message.leafSpec, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.innerSpec !== undefined) {\n      InnerSpec.encode(message.innerSpec, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.maxDepth !== 0) {\n      writer.uint32(24).int32(message.maxDepth);\n    }\n    if (message.minDepth !== 0) {\n      writer.uint32(32).int32(message.minDepth);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseProofSpec();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.leafSpec = LeafOp.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.innerSpec = InnerSpec.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.maxDepth = reader.int32();\n          break;\n        case 4:\n          message.minDepth = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$maxDepth, _object$minDepth;\n    var message = createBaseProofSpec();\n    message.leafSpec = object.leafSpec !== undefined && object.leafSpec !== null ? LeafOp.fromPartial(object.leafSpec) : undefined;\n    message.innerSpec = object.innerSpec !== undefined && object.innerSpec !== null ? InnerSpec.fromPartial(object.innerSpec) : undefined;\n    message.maxDepth = (_object$maxDepth = object.maxDepth) !== null && _object$maxDepth !== void 0 ? _object$maxDepth : 0;\n    message.minDepth = (_object$minDepth = object.minDepth) !== null && _object$minDepth !== void 0 ? _object$minDepth : 0;\n    return message;\n  }\n};\nexports.ProofSpec = ProofSpec;\nfunction createBaseInnerSpec() {\n  return {\n    childOrder: [],\n    childSize: 0,\n    minPrefixLength: 0,\n    maxPrefixLength: 0,\n    emptyChild: new Uint8Array(),\n    hash: 0\n  };\n}\nvar InnerSpec = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    writer.uint32(10).fork();\n    var _iterator2 = _createForOfIteratorHelper(message.childOrder),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var v = _step2.value;\n        writer.int32(v);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    writer.ldelim();\n    if (message.childSize !== 0) {\n      writer.uint32(16).int32(message.childSize);\n    }\n    if (message.minPrefixLength !== 0) {\n      writer.uint32(24).int32(message.minPrefixLength);\n    }\n    if (message.maxPrefixLength !== 0) {\n      writer.uint32(32).int32(message.maxPrefixLength);\n    }\n    if (message.emptyChild.length !== 0) {\n      writer.uint32(42).bytes(message.emptyChild);\n    }\n    if (message.hash !== 0) {\n      writer.uint32(48).int32(message.hash);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseInnerSpec();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if ((tag & 7) === 2) {\n            var end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.childOrder.push(reader.int32());\n            }\n          } else {\n            message.childOrder.push(reader.int32());\n          }\n          break;\n        case 2:\n          message.childSize = reader.int32();\n          break;\n        case 3:\n          message.minPrefixLength = reader.int32();\n          break;\n        case 4:\n          message.maxPrefixLength = reader.int32();\n          break;\n        case 5:\n          message.emptyChild = reader.bytes();\n          break;\n        case 6:\n          message.hash = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$childOrder, _object$childSize, _object$minPrefixLeng, _object$maxPrefixLeng, _object$emptyChild, _object$hash3;\n    var message = createBaseInnerSpec();\n    message.childOrder = ((_object$childOrder = object.childOrder) === null || _object$childOrder === void 0 ? void 0 : _object$childOrder.map(function (e) {\n      return e;\n    })) || [];\n    message.childSize = (_object$childSize = object.childSize) !== null && _object$childSize !== void 0 ? _object$childSize : 0;\n    message.minPrefixLength = (_object$minPrefixLeng = object.minPrefixLength) !== null && _object$minPrefixLeng !== void 0 ? _object$minPrefixLeng : 0;\n    message.maxPrefixLength = (_object$maxPrefixLeng = object.maxPrefixLength) !== null && _object$maxPrefixLeng !== void 0 ? _object$maxPrefixLeng : 0;\n    message.emptyChild = (_object$emptyChild = object.emptyChild) !== null && _object$emptyChild !== void 0 ? _object$emptyChild : new Uint8Array();\n    message.hash = (_object$hash3 = object.hash) !== null && _object$hash3 !== void 0 ? _object$hash3 : 0;\n    return message;\n  }\n};\nexports.InnerSpec = InnerSpec;\nfunction createBaseBatchProof() {\n  return {\n    entries: []\n  };\n}\nvar BatchProof = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    var _iterator3 = _createForOfIteratorHelper(message.entries),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var v = _step3.value;\n        BatchEntry.encode(v, writer.uint32(10).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseBatchProof();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.entries.push(BatchEntry.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$entries;\n    var message = createBaseBatchProof();\n    message.entries = ((_object$entries = object.entries) === null || _object$entries === void 0 ? void 0 : _object$entries.map(function (e) {\n      return BatchEntry.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.BatchProof = BatchProof;\nfunction createBaseBatchEntry() {\n  return {\n    exist: undefined,\n    nonexist: undefined\n  };\n}\nvar BatchEntry = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.exist !== undefined) {\n      ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.nonexist !== undefined) {\n      NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseBatchEntry();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.exist = ExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.nonexist = NonExistenceProof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = createBaseBatchEntry();\n    message.exist = object.exist !== undefined && object.exist !== null ? ExistenceProof.fromPartial(object.exist) : undefined;\n    message.nonexist = object.nonexist !== undefined && object.nonexist !== null ? NonExistenceProof.fromPartial(object.nonexist) : undefined;\n    return message;\n  }\n};\nexports.BatchEntry = BatchEntry;\nfunction createBaseCompressedBatchProof() {\n  return {\n    entries: [],\n    lookupInners: []\n  };\n}\nvar CompressedBatchProof = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    var _iterator4 = _createForOfIteratorHelper(message.entries),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var v = _step4.value;\n        CompressedBatchEntry.encode(v, writer.uint32(10).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n    var _iterator5 = _createForOfIteratorHelper(message.lookupInners),\n      _step5;\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var _v = _step5.value;\n        InnerOp.encode(_v, writer.uint32(18).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseCompressedBatchProof();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.entries.push(CompressedBatchEntry.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.lookupInners.push(InnerOp.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$entries2, _object$lookupInners;\n    var message = createBaseCompressedBatchProof();\n    message.entries = ((_object$entries2 = object.entries) === null || _object$entries2 === void 0 ? void 0 : _object$entries2.map(function (e) {\n      return CompressedBatchEntry.fromPartial(e);\n    })) || [];\n    message.lookupInners = ((_object$lookupInners = object.lookupInners) === null || _object$lookupInners === void 0 ? void 0 : _object$lookupInners.map(function (e) {\n      return InnerOp.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.CompressedBatchProof = CompressedBatchProof;\nfunction createBaseCompressedBatchEntry() {\n  return {\n    exist: undefined,\n    nonexist: undefined\n  };\n}\nvar CompressedBatchEntry = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.exist !== undefined) {\n      CompressedExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.nonexist !== undefined) {\n      CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseCompressedBatchEntry();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.exist = CompressedExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.nonexist = CompressedNonExistenceProof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = createBaseCompressedBatchEntry();\n    message.exist = object.exist !== undefined && object.exist !== null ? CompressedExistenceProof.fromPartial(object.exist) : undefined;\n    message.nonexist = object.nonexist !== undefined && object.nonexist !== null ? CompressedNonExistenceProof.fromPartial(object.nonexist) : undefined;\n    return message;\n  }\n};\nexports.CompressedBatchEntry = CompressedBatchEntry;\nfunction createBaseCompressedExistenceProof() {\n  return {\n    key: new Uint8Array(),\n    value: new Uint8Array(),\n    leaf: LeafOp.fromPartial({}),\n    path: []\n  };\n}\nvar CompressedExistenceProof = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    if (message.value.length !== 0) {\n      writer.uint32(18).bytes(message.value);\n    }\n    if (message.leaf !== undefined) {\n      LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();\n    }\n    writer.uint32(34).fork();\n    var _iterator6 = _createForOfIteratorHelper(message.path),\n      _step6;\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var v = _step6.value;\n        writer.int32(v);\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n    writer.ldelim();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseCompressedExistenceProof();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        case 2:\n          message.value = reader.bytes();\n          break;\n        case 3:\n          message.leaf = LeafOp.decode(reader, reader.uint32());\n          break;\n        case 4:\n          if ((tag & 7) === 2) {\n            var end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.path.push(reader.int32());\n            }\n          } else {\n            message.path.push(reader.int32());\n          }\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$key3, _object$value2, _object$path2;\n    var message = createBaseCompressedExistenceProof();\n    message.key = (_object$key3 = object.key) !== null && _object$key3 !== void 0 ? _object$key3 : new Uint8Array();\n    message.value = (_object$value2 = object.value) !== null && _object$value2 !== void 0 ? _object$value2 : new Uint8Array();\n    message.leaf = object.leaf !== undefined && object.leaf !== null ? LeafOp.fromPartial(object.leaf) : undefined;\n    message.path = ((_object$path2 = object.path) === null || _object$path2 === void 0 ? void 0 : _object$path2.map(function (e) {\n      return e;\n    })) || [];\n    return message;\n  }\n};\nexports.CompressedExistenceProof = CompressedExistenceProof;\nfunction createBaseCompressedNonExistenceProof() {\n  return {\n    key: new Uint8Array(),\n    left: CompressedExistenceProof.fromPartial({}),\n    right: CompressedExistenceProof.fromPartial({})\n  };\n}\nvar CompressedNonExistenceProof = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    if (message.left !== undefined) {\n      CompressedExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.right !== undefined) {\n      CompressedExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseCompressedNonExistenceProof();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        case 2:\n          message.left = CompressedExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.right = CompressedExistenceProof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$key4;\n    var message = createBaseCompressedNonExistenceProof();\n    message.key = (_object$key4 = object.key) !== null && _object$key4 !== void 0 ? _object$key4 : new Uint8Array();\n    message.left = object.left !== undefined && object.left !== null ? CompressedExistenceProof.fromPartial(object.left) : undefined;\n    message.right = object.right !== undefined && object.right !== null ? CompressedExistenceProof.fromPartial(object.right) : undefined;\n    return message;\n  }\n};\nexports.CompressedNonExistenceProof = CompressedNonExistenceProof;"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,OAAO,GAAGC,OAAO,CAAC,+BAA+B,CAAC;AACtDC,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,SAAS,GAAGF,OAAO,CAACG,iBAAiB,GAAGH,OAAO,CAACI,eAAe,GAAGJ,OAAO,CAACK,QAAQ,GAAGL,OAAO,CAACM,MAAM,GAAGN,OAAO,CAACO,SAAS,GAAGP,OAAO,CAACQ,OAAO,GAAGR,OAAO,CAACS,aAAa,GAAGT,OAAO,CAACU,MAAM,GAAGV,OAAO,CAACW,cAAc,GAAGX,OAAO,CAACY,2BAA2B,GAAGZ,OAAO,CAACa,wBAAwB,GAAGb,OAAO,CAACc,oBAAoB,GAAGd,OAAO,CAACe,oBAAoB,GAAGf,OAAO,CAACgB,eAAe,GAAGhB,OAAO,CAACiB,UAAU,GAAGjB,OAAO,CAACkB,UAAU,GAAG,KAAK,CAAC;AACvalB,OAAO,CAACmB,cAAc,GAAGA,cAAc;AACvCnB,OAAO,CAACoB,YAAY,GAAGA,YAAY;AACnCpB,OAAO,CAACqB,gBAAgB,GAAGA,gBAAgB;AAC3CrB,OAAO,CAACsB,cAAc,GAAGA,cAAc;AACvC,IAAIC,GAAG,GAAGC,uBAAuB,CAAC3B,OAAO,CAAC,oBAAoB,CAAC,CAAC;AAChE,SAAS4B,wBAAwBA,CAACC,WAAW,EAAE;EAAE,IAAI,OAAOC,OAAO,KAAK,UAAU,EAAE,OAAO,IAAI;EAAE,IAAIC,iBAAiB,GAAG,IAAID,OAAO,CAAC,CAAC;EAAE,IAAIE,gBAAgB,GAAG,IAAIF,OAAO,CAAC,CAAC;EAAE,OAAO,CAACF,wBAAwB,GAAG,SAASA,wBAAwBA,CAACC,WAAW,EAAE;IAAE,OAAOA,WAAW,GAAGG,gBAAgB,GAAGD,iBAAiB;EAAE,CAAC,EAAEF,WAAW,CAAC;AAAE;AAC9U,SAASF,uBAAuBA,CAACM,GAAG,EAAEJ,WAAW,EAAE;EAAE,IAAI,CAACA,WAAW,IAAII,GAAG,IAAIA,GAAG,CAACC,UAAU,EAAE;IAAE,OAAOD,GAAG;EAAE;EAAE,IAAIA,GAAG,KAAK,IAAI,IAAIlC,OAAO,CAACkC,GAAG,CAAC,KAAK,QAAQ,IAAI,OAAOA,GAAG,KAAK,UAAU,EAAE;IAAE,OAAO;MAAE,SAAS,EAAEA;IAAI,CAAC;EAAE;EAAE,IAAIE,KAAK,GAAGP,wBAAwB,CAACC,WAAW,CAAC;EAAE,IAAIM,KAAK,IAAIA,KAAK,CAACC,GAAG,CAACH,GAAG,CAAC,EAAE;IAAE,OAAOE,KAAK,CAACE,GAAG,CAACJ,GAAG,CAAC;EAAE;EAAE,IAAIK,MAAM,GAAG,CAAC,CAAC;EAAE,IAAIC,qBAAqB,GAAGtC,MAAM,CAACC,cAAc,IAAID,MAAM,CAACuC,wBAAwB;EAAE,KAAK,IAAIC,GAAG,IAAIR,GAAG,EAAE;IAAE,IAAIQ,GAAG,KAAK,SAAS,IAAIxC,MAAM,CAACyC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACX,GAAG,EAAEQ,GAAG,CAAC,EAAE;MAAE,IAAII,IAAI,GAAGN,qBAAqB,GAAGtC,MAAM,CAACuC,wBAAwB,CAACP,GAAG,EAAEQ,GAAG,CAAC,GAAG,IAAI;MAAE,IAAII,IAAI,KAAKA,IAAI,CAACR,GAAG,IAAIQ,IAAI,CAACC,GAAG,CAAC,EAAE;QAAE7C,MAAM,CAACC,cAAc,CAACoC,MAAM,EAAEG,GAAG,EAAEI,IAAI,CAAC;MAAE,CAAC,MAAM;QAAEP,MAAM,CAACG,GAAG,CAAC,GAAGR,GAAG,CAACQ,GAAG,CAAC;MAAE;IAAE;EAAE;EAAEH,MAAM,CAAC,SAAS,CAAC,GAAGL,GAAG;EAAE,IAAIE,KAAK,EAAE;IAAEA,KAAK,CAACW,GAAG,CAACb,GAAG,EAAEK,MAAM,CAAC;EAAE;EAAE,OAAOA,MAAM;AAAE;AAC1yB,SAASS,0BAA0BA,CAACC,CAAC,EAAEC,cAAc,EAAE;EAAE,IAAIC,EAAE,GAAG,OAAOC,MAAM,KAAK,WAAW,IAAIH,CAAC,CAACG,MAAM,CAACC,QAAQ,CAAC,IAAIJ,CAAC,CAAC,YAAY,CAAC;EAAE,IAAI,CAACE,EAAE,EAAE;IAAE,IAAIG,KAAK,CAACC,OAAO,CAACN,CAAC,CAAC,KAAKE,EAAE,GAAGK,2BAA2B,CAACP,CAAC,CAAC,CAAC,IAAIC,cAAc,IAAID,CAAC,IAAI,OAAOA,CAAC,CAACQ,MAAM,KAAK,QAAQ,EAAE;MAAE,IAAIN,EAAE,EAAEF,CAAC,GAAGE,EAAE;MAAE,IAAIO,CAAC,GAAG,CAAC;MAAE,IAAIC,CAAC,GAAG,SAASA,CAACA,CAAA,EAAG,CAAC,CAAC;MAAE,OAAO;QAAEC,CAAC,EAAED,CAAC;QAAEE,CAAC,EAAE,SAASA,CAACA,CAAA,EAAG;UAAE,IAAIH,CAAC,IAAIT,CAAC,CAACQ,MAAM,EAAE,OAAO;YAAEK,IAAI,EAAE;UAAK,CAAC;UAAE,OAAO;YAAEA,IAAI,EAAE,KAAK;YAAEzD,KAAK,EAAE4C,CAAC,CAACS,CAAC,EAAE;UAAE,CAAC;QAAE,CAAC;QAAEK,CAAC,EAAE,SAASA,CAACA,CAACC,EAAE,EAAE;UAAE,MAAMA,EAAE;QAAE,CAAC;QAAEC,CAAC,EAAEN;MAAE,CAAC;IAAE;IAAE,MAAM,IAAIO,SAAS,CAAC,uIAAuI,CAAC;EAAE;EAAE,IAAIC,gBAAgB,GAAG,IAAI;IAAEC,MAAM,GAAG,KAAK;IAAEC,GAAG;EAAE,OAAO;IAAET,CAAC,EAAE,SAASA,CAACA,CAAA,EAAG;MAAET,EAAE,GAAGA,EAAE,CAACN,IAAI,CAACI,CAAC,CAAC;IAAE,CAAC;IAAEY,CAAC,EAAE,SAASA,CAACA,CAAA,EAAG;MAAE,IAAIS,IAAI,GAAGnB,EAAE,CAACoB,IAAI,CAAC,CAAC;MAAEJ,gBAAgB,GAAGG,IAAI,CAACR,IAAI;MAAE,OAAOQ,IAAI;IAAE,CAAC;IAAEP,CAAC,EAAE,SAASA,CAACA,CAACS,GAAG,EAAE;MAAEJ,MAAM,GAAG,IAAI;MAAEC,GAAG,GAAGG,GAAG;IAAE,CAAC;IAAEP,CAAC,EAAE,SAASA,CAACA,CAAA,EAAG;MAAE,IAAI;QAAE,IAAI,CAACE,gBAAgB,IAAIhB,EAAE,CAAC,QAAQ,CAAC,IAAI,IAAI,EAAEA,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;MAAE,CAAC,SAAS;QAAE,IAAIiB,MAAM,EAAE,MAAMC,GAAG;MAAE;IAAE;EAAE,CAAC;AAAE;AAC3+B,SAASb,2BAA2BA,CAACP,CAAC,EAAEwB,MAAM,EAAE;EAAE,IAAI,CAACxB,CAAC,EAAE;EAAQ,IAAI,OAAOA,CAAC,KAAK,QAAQ,EAAE,OAAOyB,iBAAiB,CAACzB,CAAC,EAAEwB,MAAM,CAAC;EAAE,IAAIZ,CAAC,GAAG3D,MAAM,CAACyC,SAAS,CAACgC,QAAQ,CAAC9B,IAAI,CAACI,CAAC,CAAC,CAAC2B,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EAAE,IAAIf,CAAC,KAAK,QAAQ,IAAIZ,CAAC,CAAC4B,WAAW,EAAEhB,CAAC,GAAGZ,CAAC,CAAC4B,WAAW,CAACC,IAAI;EAAE,IAAIjB,CAAC,KAAK,KAAK,IAAIA,CAAC,KAAK,KAAK,EAAE,OAAOP,KAAK,CAACyB,IAAI,CAAC9B,CAAC,CAAC;EAAE,IAAIY,CAAC,KAAK,WAAW,IAAI,0CAA0C,CAACmB,IAAI,CAACnB,CAAC,CAAC,EAAE,OAAOa,iBAAiB,CAACzB,CAAC,EAAEwB,MAAM,CAAC;AAAE;AAC/Z,SAASC,iBAAiBA,CAACO,GAAG,EAAEC,GAAG,EAAE;EAAE,IAAIA,GAAG,IAAI,IAAI,IAAIA,GAAG,GAAGD,GAAG,CAACxB,MAAM,EAAEyB,GAAG,GAAGD,GAAG,CAACxB,MAAM;EAAE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEyB,IAAI,GAAG,IAAI7B,KAAK,CAAC4B,GAAG,CAAC,EAAExB,CAAC,GAAGwB,GAAG,EAAExB,CAAC,EAAE,EAAEyB,IAAI,CAACzB,CAAC,CAAC,GAAGuB,GAAG,CAACvB,CAAC,CAAC;EAAE,OAAOyB,IAAI;AAAE;AAClL,IAAIrE,MAAM;AACVV,OAAO,CAACU,MAAM,GAAGA,MAAM;AACvB,CAAC,UAAUA,MAAM,EAAE;EACjBA,MAAM,CAACA,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;EACzCA,MAAM,CAACA,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;EACvCA,MAAM,CAACA,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;EACvCA,MAAM,CAACA,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;EACvCA,MAAM,CAACA,MAAM,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;EAC7CA,MAAM,CAACA,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;EACzCA,MAAM,CAACA,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,cAAc;AACtD,CAAC,EAAEA,MAAM,KAAKV,OAAO,CAACU,MAAM,GAAGA,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;AAC5C,IAAID,aAAa,GAAGC,MAAM;AAC1BV,OAAO,CAACS,aAAa,GAAGA,aAAa;AACrC,SAASU,cAAcA,CAAC6D,MAAM,EAAE;EAC9B,QAAQA,MAAM;IACZ,KAAK,CAAC;IACN,KAAK,SAAS;MACZ,OAAOtE,MAAM,CAACuE,OAAO;IACvB,KAAK,CAAC;IACN,KAAK,QAAQ;MACX,OAAOvE,MAAM,CAACwE,MAAM;IACtB,KAAK,CAAC;IACN,KAAK,QAAQ;MACX,OAAOxE,MAAM,CAACyE,MAAM;IACtB,KAAK,CAAC;IACN,KAAK,QAAQ;MACX,OAAOzE,MAAM,CAAC0E,MAAM;IACtB,KAAK,CAAC;IACN,KAAK,WAAW;MACd,OAAO1E,MAAM,CAAC2E,SAAS;IACzB,KAAK,CAAC;IACN,KAAK,SAAS;MACZ,OAAO3E,MAAM,CAAC4E,OAAO;IACvB,KAAK,CAAC,CAAC;IACP,KAAK,cAAc;IACnB;MACE,OAAO5E,MAAM,CAAC6E,YAAY;EAC9B;AACF;AACA,SAASnE,YAAYA,CAAC4D,MAAM,EAAE;EAC5B,QAAQA,MAAM;IACZ,KAAKtE,MAAM,CAACuE,OAAO;MACjB,OAAO,SAAS;IAClB,KAAKvE,MAAM,CAACwE,MAAM;MAChB,OAAO,QAAQ;IACjB,KAAKxE,MAAM,CAACyE,MAAM;MAChB,OAAO,QAAQ;IACjB,KAAKzE,MAAM,CAAC0E,MAAM;MAChB,OAAO,QAAQ;IACjB,KAAK1E,MAAM,CAAC2E,SAAS;MACnB,OAAO,WAAW;IACpB,KAAK3E,MAAM,CAAC4E,OAAO;MACjB,OAAO,SAAS;IAClB,KAAK5E,MAAM,CAAC6E,YAAY;IACxB;MACE,OAAO,cAAc;EACzB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIlF,QAAQ;AACZL,OAAO,CAACK,QAAQ,GAAGA,QAAQ;AAC3B,CAAC,UAAUA,QAAQ,EAAE;EACnBA,QAAQ,CAACA,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;EACjDA,QAAQ,CAACA,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;EACjDA,QAAQ,CAACA,QAAQ,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;EAC7CA,QAAQ,CAACA,QAAQ,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,GAAG,aAAa;EACrDA,QAAQ,CAACA,QAAQ,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC,GAAG,gBAAgB;EAC3DA,QAAQ,CAACA,QAAQ,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,GAAG,aAAa;EACrDA,QAAQ,CAACA,QAAQ,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC,GAAG,gBAAgB;EAC3DA,QAAQ,CAACA,QAAQ,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,GAAG,kBAAkB;EAC/DA,QAAQ,CAACA,QAAQ,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,GAAG,kBAAkB;EAC/DA,QAAQ,CAACA,QAAQ,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,cAAc;AAC1D,CAAC,EAAEA,QAAQ,KAAKL,OAAO,CAACK,QAAQ,GAAGA,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC;AAClD,IAAID,eAAe,GAAGC,QAAQ;AAC9BL,OAAO,CAACI,eAAe,GAAGA,eAAe;AACzC,SAASiB,gBAAgBA,CAAC2D,MAAM,EAAE;EAChC,QAAQA,MAAM;IACZ,KAAK,CAAC;IACN,KAAK,WAAW;MACd,OAAO3E,QAAQ,CAACmF,SAAS;IAC3B,KAAK,CAAC;IACN,KAAK,WAAW;MACd,OAAOnF,QAAQ,CAACoF,SAAS;IAC3B,KAAK,CAAC;IACN,KAAK,SAAS;MACZ,OAAOpF,QAAQ,CAACqF,OAAO;IACzB,KAAK,CAAC;IACN,KAAK,aAAa;MAChB,OAAOrF,QAAQ,CAACsF,WAAW;IAC7B,KAAK,CAAC;IACN,KAAK,gBAAgB;MACnB,OAAOtF,QAAQ,CAACuF,cAAc;IAChC,KAAK,CAAC;IACN,KAAK,aAAa;MAChB,OAAOvF,QAAQ,CAACwF,WAAW;IAC7B,KAAK,CAAC;IACN,KAAK,gBAAgB;MACnB,OAAOxF,QAAQ,CAACyF,cAAc;IAChC,KAAK,CAAC;IACN,KAAK,kBAAkB;MACrB,OAAOzF,QAAQ,CAAC0F,gBAAgB;IAClC,KAAK,CAAC;IACN,KAAK,kBAAkB;MACrB,OAAO1F,QAAQ,CAAC2F,gBAAgB;IAClC,KAAK,CAAC,CAAC;IACP,KAAK,cAAc;IACnB;MACE,OAAO3F,QAAQ,CAACkF,YAAY;EAChC;AACF;AACA,SAASjE,cAAcA,CAAC0D,MAAM,EAAE;EAC9B,QAAQA,MAAM;IACZ,KAAK3E,QAAQ,CAACmF,SAAS;MACrB,OAAO,WAAW;IACpB,KAAKnF,QAAQ,CAACoF,SAAS;MACrB,OAAO,WAAW;IACpB,KAAKpF,QAAQ,CAACqF,OAAO;MACnB,OAAO,SAAS;IAClB,KAAKrF,QAAQ,CAACsF,WAAW;MACvB,OAAO,aAAa;IACtB,KAAKtF,QAAQ,CAACuF,cAAc;MAC1B,OAAO,gBAAgB;IACzB,KAAKvF,QAAQ,CAACwF,WAAW;MACvB,OAAO,aAAa;IACtB,KAAKxF,QAAQ,CAACyF,cAAc;MAC1B,OAAO,gBAAgB;IACzB,KAAKzF,QAAQ,CAAC0F,gBAAgB;MAC5B,OAAO,kBAAkB;IAC3B,KAAK1F,QAAQ,CAAC2F,gBAAgB;MAC5B,OAAO,kBAAkB;IAC3B,KAAK3F,QAAQ,CAACkF,YAAY;IAC1B;MACE,OAAO,cAAc;EACzB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASU,wBAAwBA,CAAA,EAAG;EAClC,OAAO;IACL3D,GAAG,EAAE,IAAI4D,UAAU,CAAC,CAAC;IACrBjG,KAAK,EAAE,IAAIiG,UAAU,CAAC,CAAC;IACvBC,IAAI,EAAE7F,MAAM,CAAC8F,WAAW,CAAC,CAAC,CAAC,CAAC;IAC5BC,IAAI,EAAE;EACR,CAAC;AACH;AACA,IAAI1F,cAAc,GAAG;EACnB2F,MAAM,EAAE,SAASA,MAAMA,CAACC,OAAO,EAAE;IAC/B,IAAIC,MAAM,GAAGC,SAAS,CAACpD,MAAM,GAAG,CAAC,IAAIoD,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAGlF,GAAG,CAACoF,MAAM,CAACC,MAAM,CAAC,CAAC;IACpG,IAAIL,OAAO,CAACjE,GAAG,CAACe,MAAM,KAAK,CAAC,EAAE;MAC5BmD,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACC,KAAK,CAACP,OAAO,CAACjE,GAAG,CAAC;IACtC;IACA,IAAIiE,OAAO,CAACtG,KAAK,CAACoD,MAAM,KAAK,CAAC,EAAE;MAC9BmD,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACC,KAAK,CAACP,OAAO,CAACtG,KAAK,CAAC;IACxC;IACA,IAAIsG,OAAO,CAACJ,IAAI,KAAKO,SAAS,EAAE;MAC9BpG,MAAM,CAACgG,MAAM,CAACC,OAAO,CAACJ,IAAI,EAAEK,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;IAChE;IACA,IAAIC,SAAS,GAAGrE,0BAA0B,CAAC2D,OAAO,CAACF,IAAI,CAAC;MACtDa,KAAK;IACP,IAAI;MACF,KAAKD,SAAS,CAACzD,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC0D,KAAK,GAAGD,SAAS,CAACxD,CAAC,CAAC,CAAC,EAAEC,IAAI,GAAG;QAClD,IAAIyD,CAAC,GAAGD,KAAK,CAACjH,KAAK;QACnBO,OAAO,CAAC8F,MAAM,CAACa,CAAC,EAAEX,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;MACtD;IACF,CAAC,CAAC,OAAO/C,GAAG,EAAE;MACZgD,SAAS,CAACtD,CAAC,CAACM,GAAG,CAAC;IAClB,CAAC,SAAS;MACRgD,SAAS,CAACpD,CAAC,CAAC,CAAC;IACf;IACA,OAAO2C,MAAM;EACf,CAAC;EACDY,MAAM,EAAE,SAASA,MAAMA,CAACC,KAAK,EAAEhE,MAAM,EAAE;IACrC,IAAIiE,MAAM,GAAGD,KAAK,YAAY9F,GAAG,CAACgG,MAAM,GAAGF,KAAK,GAAG,IAAI9F,GAAG,CAACgG,MAAM,CAACF,KAAK,CAAC;IACxE,IAAIG,GAAG,GAAGnE,MAAM,KAAKqD,SAAS,GAAGY,MAAM,CAACxC,GAAG,GAAGwC,MAAM,CAACG,GAAG,GAAGpE,MAAM;IACjE,IAAIkD,OAAO,GAAGN,wBAAwB,CAAC,CAAC;IACxC,OAAOqB,MAAM,CAACG,GAAG,GAAGD,GAAG,EAAE;MACvB,IAAIE,GAAG,GAAGJ,MAAM,CAACT,MAAM,CAAC,CAAC;MACzB,QAAQa,GAAG,KAAK,CAAC;QACf,KAAK,CAAC;UACJnB,OAAO,CAACjE,GAAG,GAAGgF,MAAM,CAACR,KAAK,CAAC,CAAC;UAC5B;QACF,KAAK,CAAC;UACJP,OAAO,CAACtG,KAAK,GAAGqH,MAAM,CAACR,KAAK,CAAC,CAAC;UAC9B;QACF,KAAK,CAAC;UACJP,OAAO,CAACJ,IAAI,GAAG7F,MAAM,CAAC8G,MAAM,CAACE,MAAM,EAAEA,MAAM,CAACT,MAAM,CAAC,CAAC,CAAC;UACrD;QACF,KAAK,CAAC;UACJN,OAAO,CAACF,IAAI,CAACsB,IAAI,CAACnH,OAAO,CAAC4G,MAAM,CAACE,MAAM,EAAEA,MAAM,CAACT,MAAM,CAAC,CAAC,CAAC,CAAC;UAC1D;QACF;UACES,MAAM,CAACM,QAAQ,CAACF,GAAG,GAAG,CAAC,CAAC;UACxB;MACJ;IACF;IACA,OAAOnB,OAAO;EAChB,CAAC;EACDH,WAAW,EAAE,SAASA,WAAWA,CAACpB,MAAM,EAAE;IACxC,IAAI6C,WAAW,EAAEC,aAAa,EAAEC,YAAY;IAC5C,IAAIxB,OAAO,GAAGN,wBAAwB,CAAC,CAAC;IACxCM,OAAO,CAACjE,GAAG,GAAG,CAACuF,WAAW,GAAG7C,MAAM,CAAC1C,GAAG,MAAM,IAAI,IAAIuF,WAAW,KAAK,KAAK,CAAC,GAAGA,WAAW,GAAG,IAAI3B,UAAU,CAAC,CAAC;IAC5GK,OAAO,CAACtG,KAAK,GAAG,CAAC6H,aAAa,GAAG9C,MAAM,CAAC/E,KAAK,MAAM,IAAI,IAAI6H,aAAa,KAAK,KAAK,CAAC,GAAGA,aAAa,GAAG,IAAI5B,UAAU,CAAC,CAAC;IACtHK,OAAO,CAACJ,IAAI,GAAGnB,MAAM,CAACmB,IAAI,KAAKO,SAAS,IAAI1B,MAAM,CAACmB,IAAI,KAAK,IAAI,GAAG7F,MAAM,CAAC8F,WAAW,CAACpB,MAAM,CAACmB,IAAI,CAAC,GAAGO,SAAS;IAC9GH,OAAO,CAACF,IAAI,GAAG,CAAC,CAAC0B,YAAY,GAAG/C,MAAM,CAACqB,IAAI,MAAM,IAAI,IAAI0B,YAAY,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,YAAY,CAACC,GAAG,CAAC,UAAUrE,CAAC,EAAE;MACxH,OAAOnD,OAAO,CAAC4F,WAAW,CAACzC,CAAC,CAAC;IAC/B,CAAC,CAAC,KAAK,EAAE;IACT,OAAO4C,OAAO;EAChB;AACF,CAAC;AACDvG,OAAO,CAACW,cAAc,GAAGA,cAAc;AACvC,SAASsH,2BAA2BA,CAAA,EAAG;EACrC,OAAO;IACL3F,GAAG,EAAE,IAAI4D,UAAU,CAAC,CAAC;IACrBgC,IAAI,EAAEvH,cAAc,CAACyF,WAAW,CAAC,CAAC,CAAC,CAAC;IACpC+B,KAAK,EAAExH,cAAc,CAACyF,WAAW,CAAC,CAAC,CAAC;EACtC,CAAC;AACH;AACA,IAAIjG,iBAAiB,GAAG;EACtBmG,MAAM,EAAE,SAASA,MAAMA,CAACC,OAAO,EAAE;IAC/B,IAAIC,MAAM,GAAGC,SAAS,CAACpD,MAAM,GAAG,CAAC,IAAIoD,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAGlF,GAAG,CAACoF,MAAM,CAACC,MAAM,CAAC,CAAC;IACpG,IAAIL,OAAO,CAACjE,GAAG,CAACe,MAAM,KAAK,CAAC,EAAE;MAC5BmD,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACC,KAAK,CAACP,OAAO,CAACjE,GAAG,CAAC;IACtC;IACA,IAAIiE,OAAO,CAAC2B,IAAI,KAAKxB,SAAS,EAAE;MAC9B/F,cAAc,CAAC2F,MAAM,CAACC,OAAO,CAAC2B,IAAI,EAAE1B,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;IACxE;IACA,IAAIT,OAAO,CAAC4B,KAAK,KAAKzB,SAAS,EAAE;MAC/B/F,cAAc,CAAC2F,MAAM,CAACC,OAAO,CAAC4B,KAAK,EAAE3B,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;IACzE;IACA,OAAOR,MAAM;EACf,CAAC;EACDY,MAAM,EAAE,SAASA,MAAMA,CAACC,KAAK,EAAEhE,MAAM,EAAE;IACrC,IAAIiE,MAAM,GAAGD,KAAK,YAAY9F,GAAG,CAACgG,MAAM,GAAGF,KAAK,GAAG,IAAI9F,GAAG,CAACgG,MAAM,CAACF,KAAK,CAAC;IACxE,IAAIG,GAAG,GAAGnE,MAAM,KAAKqD,SAAS,GAAGY,MAAM,CAACxC,GAAG,GAAGwC,MAAM,CAACG,GAAG,GAAGpE,MAAM;IACjE,IAAIkD,OAAO,GAAG0B,2BAA2B,CAAC,CAAC;IAC3C,OAAOX,MAAM,CAACG,GAAG,GAAGD,GAAG,EAAE;MACvB,IAAIE,GAAG,GAAGJ,MAAM,CAACT,MAAM,CAAC,CAAC;MACzB,QAAQa,GAAG,KAAK,CAAC;QACf,KAAK,CAAC;UACJnB,OAAO,CAACjE,GAAG,GAAGgF,MAAM,CAACR,KAAK,CAAC,CAAC;UAC5B;QACF,KAAK,CAAC;UACJP,OAAO,CAAC2B,IAAI,GAAGvH,cAAc,CAACyG,MAAM,CAACE,MAAM,EAAEA,MAAM,CAACT,MAAM,CAAC,CAAC,CAAC;UAC7D;QACF,KAAK,CAAC;UACJN,OAAO,CAAC4B,KAAK,GAAGxH,cAAc,CAACyG,MAAM,CAACE,MAAM,EAAEA,MAAM,CAACT,MAAM,CAAC,CAAC,CAAC;UAC9D;QACF;UACES,MAAM,CAACM,QAAQ,CAACF,GAAG,GAAG,CAAC,CAAC;UACxB;MACJ;IACF;IACA,OAAOnB,OAAO;EAChB,CAAC;EACDH,WAAW,EAAE,SAASA,WAAWA,CAACpB,MAAM,EAAE;IACxC,IAAIoD,YAAY;IAChB,IAAI7B,OAAO,GAAG0B,2BAA2B,CAAC,CAAC;IAC3C1B,OAAO,CAACjE,GAAG,GAAG,CAAC8F,YAAY,GAAGpD,MAAM,CAAC1C,GAAG,MAAM,IAAI,IAAI8F,YAAY,KAAK,KAAK,CAAC,GAAGA,YAAY,GAAG,IAAIlC,UAAU,CAAC,CAAC;IAC/GK,OAAO,CAAC2B,IAAI,GAAGlD,MAAM,CAACkD,IAAI,KAAKxB,SAAS,IAAI1B,MAAM,CAACkD,IAAI,KAAK,IAAI,GAAGvH,cAAc,CAACyF,WAAW,CAACpB,MAAM,CAACkD,IAAI,CAAC,GAAGxB,SAAS;IACtHH,OAAO,CAAC4B,KAAK,GAAGnD,MAAM,CAACmD,KAAK,KAAKzB,SAAS,IAAI1B,MAAM,CAACmD,KAAK,KAAK,IAAI,GAAGxH,cAAc,CAACyF,WAAW,CAACpB,MAAM,CAACmD,KAAK,CAAC,GAAGzB,SAAS;IAC1H,OAAOH,OAAO;EAChB;AACF,CAAC;AACDvG,OAAO,CAACG,iBAAiB,GAAGA,iBAAiB;AAC7C,SAASkI,yBAAyBA,CAAA,EAAG;EACnC,OAAO;IACLC,KAAK,EAAE5B,SAAS;IAChB6B,QAAQ,EAAE7B,SAAS;IACnB8B,KAAK,EAAE9B,SAAS;IAChB+B,UAAU,EAAE/B;EACd,CAAC;AACH;AACA,IAAI1F,eAAe,GAAG;EACpBsF,MAAM,EAAE,SAASA,MAAMA,CAACC,OAAO,EAAE;IAC/B,IAAIC,MAAM,GAAGC,SAAS,CAACpD,MAAM,GAAG,CAAC,IAAIoD,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAGlF,GAAG,CAACoF,MAAM,CAACC,MAAM,CAAC,CAAC;IACpG,IAAIL,OAAO,CAAC+B,KAAK,KAAK5B,SAAS,EAAE;MAC/B/F,cAAc,CAAC2F,MAAM,CAACC,OAAO,CAAC+B,KAAK,EAAE9B,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;IACzE;IACA,IAAIT,OAAO,CAACgC,QAAQ,KAAK7B,SAAS,EAAE;MAClCvG,iBAAiB,CAACmG,MAAM,CAACC,OAAO,CAACgC,QAAQ,EAAE/B,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;IAC/E;IACA,IAAIT,OAAO,CAACiC,KAAK,KAAK9B,SAAS,EAAE;MAC/BzF,UAAU,CAACqF,MAAM,CAACC,OAAO,CAACiC,KAAK,EAAEhC,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;IACrE;IACA,IAAIT,OAAO,CAACkC,UAAU,KAAK/B,SAAS,EAAE;MACpC5F,oBAAoB,CAACwF,MAAM,CAACC,OAAO,CAACkC,UAAU,EAAEjC,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;IACpF;IACA,OAAOR,MAAM;EACf,CAAC;EACDY,MAAM,EAAE,SAASA,MAAMA,CAACC,KAAK,EAAEhE,MAAM,EAAE;IACrC,IAAIiE,MAAM,GAAGD,KAAK,YAAY9F,GAAG,CAACgG,MAAM,GAAGF,KAAK,GAAG,IAAI9F,GAAG,CAACgG,MAAM,CAACF,KAAK,CAAC;IACxE,IAAIG,GAAG,GAAGnE,MAAM,KAAKqD,SAAS,GAAGY,MAAM,CAACxC,GAAG,GAAGwC,MAAM,CAACG,GAAG,GAAGpE,MAAM;IACjE,IAAIkD,OAAO,GAAG8B,yBAAyB,CAAC,CAAC;IACzC,OAAOf,MAAM,CAACG,GAAG,GAAGD,GAAG,EAAE;MACvB,IAAIE,GAAG,GAAGJ,MAAM,CAACT,MAAM,CAAC,CAAC;MACzB,QAAQa,GAAG,KAAK,CAAC;QACf,KAAK,CAAC;UACJnB,OAAO,CAAC+B,KAAK,GAAG3H,cAAc,CAACyG,MAAM,CAACE,MAAM,EAAEA,MAAM,CAACT,MAAM,CAAC,CAAC,CAAC;UAC9D;QACF,KAAK,CAAC;UACJN,OAAO,CAACgC,QAAQ,GAAGpI,iBAAiB,CAACiH,MAAM,CAACE,MAAM,EAAEA,MAAM,CAACT,MAAM,CAAC,CAAC,CAAC;UACpE;QACF,KAAK,CAAC;UACJN,OAAO,CAACiC,KAAK,GAAGvH,UAAU,CAACmG,MAAM,CAACE,MAAM,EAAEA,MAAM,CAACT,MAAM,CAAC,CAAC,CAAC;UAC1D;QACF,KAAK,CAAC;UACJN,OAAO,CAACkC,UAAU,GAAG3H,oBAAoB,CAACsG,MAAM,CAACE,MAAM,EAAEA,MAAM,CAACT,MAAM,CAAC,CAAC,CAAC;UACzE;QACF;UACES,MAAM,CAACM,QAAQ,CAACF,GAAG,GAAG,CAAC,CAAC;UACxB;MACJ;IACF;IACA,OAAOnB,OAAO;EAChB,CAAC;EACDH,WAAW,EAAE,SAASA,WAAWA,CAACpB,MAAM,EAAE;IACxC,IAAIuB,OAAO,GAAG8B,yBAAyB,CAAC,CAAC;IACzC9B,OAAO,CAAC+B,KAAK,GAAGtD,MAAM,CAACsD,KAAK,KAAK5B,SAAS,IAAI1B,MAAM,CAACsD,KAAK,KAAK,IAAI,GAAG3H,cAAc,CAACyF,WAAW,CAACpB,MAAM,CAACsD,KAAK,CAAC,GAAG5B,SAAS;IAC1HH,OAAO,CAACgC,QAAQ,GAAGvD,MAAM,CAACuD,QAAQ,KAAK7B,SAAS,IAAI1B,MAAM,CAACuD,QAAQ,KAAK,IAAI,GAAGpI,iBAAiB,CAACiG,WAAW,CAACpB,MAAM,CAACuD,QAAQ,CAAC,GAAG7B,SAAS;IACzIH,OAAO,CAACiC,KAAK,GAAGxD,MAAM,CAACwD,KAAK,KAAK9B,SAAS,IAAI1B,MAAM,CAACwD,KAAK,KAAK,IAAI,GAAGvH,UAAU,CAACmF,WAAW,CAACpB,MAAM,CAACwD,KAAK,CAAC,GAAG9B,SAAS;IACtHH,OAAO,CAACkC,UAAU,GAAGzD,MAAM,CAACyD,UAAU,KAAK/B,SAAS,IAAI1B,MAAM,CAACyD,UAAU,KAAK,IAAI,GAAG3H,oBAAoB,CAACsF,WAAW,CAACpB,MAAM,CAACyD,UAAU,CAAC,GAAG/B,SAAS;IACpJ,OAAOH,OAAO;EAChB;AACF,CAAC;AACDvG,OAAO,CAACgB,eAAe,GAAGA,eAAe;AACzC,SAAS0H,gBAAgBA,CAAA,EAAG;EAC1B,OAAO;IACLC,IAAI,EAAE,CAAC;IACPC,UAAU,EAAE,CAAC;IACbC,YAAY,EAAE,CAAC;IACfxF,MAAM,EAAE,CAAC;IACTyF,MAAM,EAAE,IAAI5C,UAAU,CAAC;EACzB,CAAC;AACH;AACA,IAAI5F,MAAM,GAAG;EACXgG,MAAM,EAAE,SAASA,MAAMA,CAACC,OAAO,EAAE;IAC/B,IAAIC,MAAM,GAAGC,SAAS,CAACpD,MAAM,GAAG,CAAC,IAAIoD,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAGlF,GAAG,CAACoF,MAAM,CAACC,MAAM,CAAC,CAAC;IACpG,IAAIL,OAAO,CAACoC,IAAI,KAAK,CAAC,EAAE;MACtBnC,MAAM,CAACK,MAAM,CAAC,CAAC,CAAC,CAACkC,KAAK,CAACxC,OAAO,CAACoC,IAAI,CAAC;IACtC;IACA,IAAIpC,OAAO,CAACqC,UAAU,KAAK,CAAC,EAAE;MAC5BpC,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACkC,KAAK,CAACxC,OAAO,CAACqC,UAAU,CAAC;IAC7C;IACA,IAAIrC,OAAO,CAACsC,YAAY,KAAK,CAAC,EAAE;MAC9BrC,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACkC,KAAK,CAACxC,OAAO,CAACsC,YAAY,CAAC;IAC/C;IACA,IAAItC,OAAO,CAAClD,MAAM,KAAK,CAAC,EAAE;MACxBmD,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACkC,KAAK,CAACxC,OAAO,CAAClD,MAAM,CAAC;IACzC;IACA,IAAIkD,OAAO,CAACuC,MAAM,CAACzF,MAAM,KAAK,CAAC,EAAE;MAC/BmD,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACC,KAAK,CAACP,OAAO,CAACuC,MAAM,CAAC;IACzC;IACA,OAAOtC,MAAM;EACf,CAAC;EACDY,MAAM,EAAE,SAASA,MAAMA,CAACC,KAAK,EAAEhE,MAAM,EAAE;IACrC,IAAIiE,MAAM,GAAGD,KAAK,YAAY9F,GAAG,CAACgG,MAAM,GAAGF,KAAK,GAAG,IAAI9F,GAAG,CAACgG,MAAM,CAACF,KAAK,CAAC;IACxE,IAAIG,GAAG,GAAGnE,MAAM,KAAKqD,SAAS,GAAGY,MAAM,CAACxC,GAAG,GAAGwC,MAAM,CAACG,GAAG,GAAGpE,MAAM;IACjE,IAAIkD,OAAO,GAAGmC,gBAAgB,CAAC,CAAC;IAChC,OAAOpB,MAAM,CAACG,GAAG,GAAGD,GAAG,EAAE;MACvB,IAAIE,GAAG,GAAGJ,MAAM,CAACT,MAAM,CAAC,CAAC;MACzB,QAAQa,GAAG,KAAK,CAAC;QACf,KAAK,CAAC;UACJnB,OAAO,CAACoC,IAAI,GAAGrB,MAAM,CAACyB,KAAK,CAAC,CAAC;UAC7B;QACF,KAAK,CAAC;UACJxC,OAAO,CAACqC,UAAU,GAAGtB,MAAM,CAACyB,KAAK,CAAC,CAAC;UACnC;QACF,KAAK,CAAC;UACJxC,OAAO,CAACsC,YAAY,GAAGvB,MAAM,CAACyB,KAAK,CAAC,CAAC;UACrC;QACF,KAAK,CAAC;UACJxC,OAAO,CAAClD,MAAM,GAAGiE,MAAM,CAACyB,KAAK,CAAC,CAAC;UAC/B;QACF,KAAK,CAAC;UACJxC,OAAO,CAACuC,MAAM,GAAGxB,MAAM,CAACR,KAAK,CAAC,CAAC;UAC/B;QACF;UACEQ,MAAM,CAACM,QAAQ,CAACF,GAAG,GAAG,CAAC,CAAC;UACxB;MACJ;IACF;IACA,OAAOnB,OAAO;EAChB,CAAC;EACDH,WAAW,EAAE,SAASA,WAAWA,CAACpB,MAAM,EAAE;IACxC,IAAIgE,YAAY,EAAEC,kBAAkB,EAAEC,oBAAoB,EAAEC,cAAc,EAAEC,cAAc;IAC1F,IAAI7C,OAAO,GAAGmC,gBAAgB,CAAC,CAAC;IAChCnC,OAAO,CAACoC,IAAI,GAAG,CAACK,YAAY,GAAGhE,MAAM,CAAC2D,IAAI,MAAM,IAAI,IAAIK,YAAY,KAAK,KAAK,CAAC,GAAGA,YAAY,GAAG,CAAC;IAClGzC,OAAO,CAACqC,UAAU,GAAG,CAACK,kBAAkB,GAAGjE,MAAM,CAAC4D,UAAU,MAAM,IAAI,IAAIK,kBAAkB,KAAK,KAAK,CAAC,GAAGA,kBAAkB,GAAG,CAAC;IAChI1C,OAAO,CAACsC,YAAY,GAAG,CAACK,oBAAoB,GAAGlE,MAAM,CAAC6D,YAAY,MAAM,IAAI,IAAIK,oBAAoB,KAAK,KAAK,CAAC,GAAGA,oBAAoB,GAAG,CAAC;IAC1I3C,OAAO,CAAClD,MAAM,GAAG,CAAC8F,cAAc,GAAGnE,MAAM,CAAC3B,MAAM,MAAM,IAAI,IAAI8F,cAAc,KAAK,KAAK,CAAC,GAAGA,cAAc,GAAG,CAAC;IAC5G5C,OAAO,CAACuC,MAAM,GAAG,CAACM,cAAc,GAAGpE,MAAM,CAAC8D,MAAM,MAAM,IAAI,IAAIM,cAAc,KAAK,KAAK,CAAC,GAAGA,cAAc,GAAG,IAAIlD,UAAU,CAAC,CAAC;IAC3H,OAAOK,OAAO;EAChB;AACF,CAAC;AACDvG,OAAO,CAACM,MAAM,GAAGA,MAAM;AACvB,SAAS+I,iBAAiBA,CAAA,EAAG;EAC3B,OAAO;IACLV,IAAI,EAAE,CAAC;IACPG,MAAM,EAAE,IAAI5C,UAAU,CAAC,CAAC;IACxBoD,MAAM,EAAE,IAAIpD,UAAU,CAAC;EACzB,CAAC;AACH;AACA,IAAI1F,OAAO,GAAG;EACZ8F,MAAM,EAAE,SAASA,MAAMA,CAACC,OAAO,EAAE;IAC/B,IAAIC,MAAM,GAAGC,SAAS,CAACpD,MAAM,GAAG,CAAC,IAAIoD,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAGlF,GAAG,CAACoF,MAAM,CAACC,MAAM,CAAC,CAAC;IACpG,IAAIL,OAAO,CAACoC,IAAI,KAAK,CAAC,EAAE;MACtBnC,MAAM,CAACK,MAAM,CAAC,CAAC,CAAC,CAACkC,KAAK,CAACxC,OAAO,CAACoC,IAAI,CAAC;IACtC;IACA,IAAIpC,OAAO,CAACuC,MAAM,CAACzF,MAAM,KAAK,CAAC,EAAE;MAC/BmD,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACC,KAAK,CAACP,OAAO,CAACuC,MAAM,CAAC;IACzC;IACA,IAAIvC,OAAO,CAAC+C,MAAM,CAACjG,MAAM,KAAK,CAAC,EAAE;MAC/BmD,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACC,KAAK,CAACP,OAAO,CAAC+C,MAAM,CAAC;IACzC;IACA,OAAO9C,MAAM;EACf,CAAC;EACDY,MAAM,EAAE,SAASA,MAAMA,CAACC,KAAK,EAAEhE,MAAM,EAAE;IACrC,IAAIiE,MAAM,GAAGD,KAAK,YAAY9F,GAAG,CAACgG,MAAM,GAAGF,KAAK,GAAG,IAAI9F,GAAG,CAACgG,MAAM,CAACF,KAAK,CAAC;IACxE,IAAIG,GAAG,GAAGnE,MAAM,KAAKqD,SAAS,GAAGY,MAAM,CAACxC,GAAG,GAAGwC,MAAM,CAACG,GAAG,GAAGpE,MAAM;IACjE,IAAIkD,OAAO,GAAG8C,iBAAiB,CAAC,CAAC;IACjC,OAAO/B,MAAM,CAACG,GAAG,GAAGD,GAAG,EAAE;MACvB,IAAIE,GAAG,GAAGJ,MAAM,CAACT,MAAM,CAAC,CAAC;MACzB,QAAQa,GAAG,KAAK,CAAC;QACf,KAAK,CAAC;UACJnB,OAAO,CAACoC,IAAI,GAAGrB,MAAM,CAACyB,KAAK,CAAC,CAAC;UAC7B;QACF,KAAK,CAAC;UACJxC,OAAO,CAACuC,MAAM,GAAGxB,MAAM,CAACR,KAAK,CAAC,CAAC;UAC/B;QACF,KAAK,CAAC;UACJP,OAAO,CAAC+C,MAAM,GAAGhC,MAAM,CAACR,KAAK,CAAC,CAAC;UAC/B;QACF;UACEQ,MAAM,CAACM,QAAQ,CAACF,GAAG,GAAG,CAAC,CAAC;UACxB;MACJ;IACF;IACA,OAAOnB,OAAO;EAChB,CAAC;EACDH,WAAW,EAAE,SAASA,WAAWA,CAACpB,MAAM,EAAE;IACxC,IAAIuE,aAAa,EAAEC,eAAe,EAAEC,cAAc;IAClD,IAAIlD,OAAO,GAAG8C,iBAAiB,CAAC,CAAC;IACjC9C,OAAO,CAACoC,IAAI,GAAG,CAACY,aAAa,GAAGvE,MAAM,CAAC2D,IAAI,MAAM,IAAI,IAAIY,aAAa,KAAK,KAAK,CAAC,GAAGA,aAAa,GAAG,CAAC;IACrGhD,OAAO,CAACuC,MAAM,GAAG,CAACU,eAAe,GAAGxE,MAAM,CAAC8D,MAAM,MAAM,IAAI,IAAIU,eAAe,KAAK,KAAK,CAAC,GAAGA,eAAe,GAAG,IAAItD,UAAU,CAAC,CAAC;IAC9HK,OAAO,CAAC+C,MAAM,GAAG,CAACG,cAAc,GAAGzE,MAAM,CAACsE,MAAM,MAAM,IAAI,IAAIG,cAAc,KAAK,KAAK,CAAC,GAAGA,cAAc,GAAG,IAAIvD,UAAU,CAAC,CAAC;IAC3H,OAAOK,OAAO;EAChB;AACF,CAAC;AACDvG,OAAO,CAACQ,OAAO,GAAGA,OAAO;AACzB,SAASkJ,mBAAmBA,CAAA,EAAG;EAC7B,OAAO;IACLC,QAAQ,EAAErJ,MAAM,CAAC8F,WAAW,CAAC,CAAC,CAAC,CAAC;IAChCwD,SAAS,EAAErJ,SAAS,CAAC6F,WAAW,CAAC,CAAC,CAAC,CAAC;IACpCyD,QAAQ,EAAE,CAAC;IACXC,QAAQ,EAAE;EACZ,CAAC;AACH;AACA,IAAI5J,SAAS,GAAG;EACdoG,MAAM,EAAE,SAASA,MAAMA,CAACC,OAAO,EAAE;IAC/B,IAAIC,MAAM,GAAGC,SAAS,CAACpD,MAAM,GAAG,CAAC,IAAIoD,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAGlF,GAAG,CAACoF,MAAM,CAACC,MAAM,CAAC,CAAC;IACpG,IAAIL,OAAO,CAACoD,QAAQ,KAAKjD,SAAS,EAAE;MAClCpG,MAAM,CAACgG,MAAM,CAACC,OAAO,CAACoD,QAAQ,EAAEnD,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;IACpE;IACA,IAAIT,OAAO,CAACqD,SAAS,KAAKlD,SAAS,EAAE;MACnCnG,SAAS,CAAC+F,MAAM,CAACC,OAAO,CAACqD,SAAS,EAAEpD,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;IACxE;IACA,IAAIT,OAAO,CAACsD,QAAQ,KAAK,CAAC,EAAE;MAC1BrD,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACkC,KAAK,CAACxC,OAAO,CAACsD,QAAQ,CAAC;IAC3C;IACA,IAAItD,OAAO,CAACuD,QAAQ,KAAK,CAAC,EAAE;MAC1BtD,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACkC,KAAK,CAACxC,OAAO,CAACuD,QAAQ,CAAC;IAC3C;IACA,OAAOtD,MAAM;EACf,CAAC;EACDY,MAAM,EAAE,SAASA,MAAMA,CAACC,KAAK,EAAEhE,MAAM,EAAE;IACrC,IAAIiE,MAAM,GAAGD,KAAK,YAAY9F,GAAG,CAACgG,MAAM,GAAGF,KAAK,GAAG,IAAI9F,GAAG,CAACgG,MAAM,CAACF,KAAK,CAAC;IACxE,IAAIG,GAAG,GAAGnE,MAAM,KAAKqD,SAAS,GAAGY,MAAM,CAACxC,GAAG,GAAGwC,MAAM,CAACG,GAAG,GAAGpE,MAAM;IACjE,IAAIkD,OAAO,GAAGmD,mBAAmB,CAAC,CAAC;IACnC,OAAOpC,MAAM,CAACG,GAAG,GAAGD,GAAG,EAAE;MACvB,IAAIE,GAAG,GAAGJ,MAAM,CAACT,MAAM,CAAC,CAAC;MACzB,QAAQa,GAAG,KAAK,CAAC;QACf,KAAK,CAAC;UACJnB,OAAO,CAACoD,QAAQ,GAAGrJ,MAAM,CAAC8G,MAAM,CAACE,MAAM,EAAEA,MAAM,CAACT,MAAM,CAAC,CAAC,CAAC;UACzD;QACF,KAAK,CAAC;UACJN,OAAO,CAACqD,SAAS,GAAGrJ,SAAS,CAAC6G,MAAM,CAACE,MAAM,EAAEA,MAAM,CAACT,MAAM,CAAC,CAAC,CAAC;UAC7D;QACF,KAAK,CAAC;UACJN,OAAO,CAACsD,QAAQ,GAAGvC,MAAM,CAACyB,KAAK,CAAC,CAAC;UACjC;QACF,KAAK,CAAC;UACJxC,OAAO,CAACuD,QAAQ,GAAGxC,MAAM,CAACyB,KAAK,CAAC,CAAC;UACjC;QACF;UACEzB,MAAM,CAACM,QAAQ,CAACF,GAAG,GAAG,CAAC,CAAC;UACxB;MACJ;IACF;IACA,OAAOnB,OAAO;EAChB,CAAC;EACDH,WAAW,EAAE,SAASA,WAAWA,CAACpB,MAAM,EAAE;IACxC,IAAI+E,gBAAgB,EAAEC,gBAAgB;IACtC,IAAIzD,OAAO,GAAGmD,mBAAmB,CAAC,CAAC;IACnCnD,OAAO,CAACoD,QAAQ,GAAG3E,MAAM,CAAC2E,QAAQ,KAAKjD,SAAS,IAAI1B,MAAM,CAAC2E,QAAQ,KAAK,IAAI,GAAGrJ,MAAM,CAAC8F,WAAW,CAACpB,MAAM,CAAC2E,QAAQ,CAAC,GAAGjD,SAAS;IAC9HH,OAAO,CAACqD,SAAS,GAAG5E,MAAM,CAAC4E,SAAS,KAAKlD,SAAS,IAAI1B,MAAM,CAAC4E,SAAS,KAAK,IAAI,GAAGrJ,SAAS,CAAC6F,WAAW,CAACpB,MAAM,CAAC4E,SAAS,CAAC,GAAGlD,SAAS;IACrIH,OAAO,CAACsD,QAAQ,GAAG,CAACE,gBAAgB,GAAG/E,MAAM,CAAC6E,QAAQ,MAAM,IAAI,IAAIE,gBAAgB,KAAK,KAAK,CAAC,GAAGA,gBAAgB,GAAG,CAAC;IACtHxD,OAAO,CAACuD,QAAQ,GAAG,CAACE,gBAAgB,GAAGhF,MAAM,CAAC8E,QAAQ,MAAM,IAAI,IAAIE,gBAAgB,KAAK,KAAK,CAAC,GAAGA,gBAAgB,GAAG,CAAC;IACtH,OAAOzD,OAAO;EAChB;AACF,CAAC;AACDvG,OAAO,CAACE,SAAS,GAAGA,SAAS;AAC7B,SAAS+J,mBAAmBA,CAAA,EAAG;EAC7B,OAAO;IACLC,UAAU,EAAE,EAAE;IACdC,SAAS,EAAE,CAAC;IACZC,eAAe,EAAE,CAAC;IAClBC,eAAe,EAAE,CAAC;IAClBC,UAAU,EAAE,IAAIpE,UAAU,CAAC,CAAC;IAC5ByC,IAAI,EAAE;EACR,CAAC;AACH;AACA,IAAIpI,SAAS,GAAG;EACd+F,MAAM,EAAE,SAASA,MAAMA,CAACC,OAAO,EAAE;IAC/B,IAAIC,MAAM,GAAGC,SAAS,CAACpD,MAAM,GAAG,CAAC,IAAIoD,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAGlF,GAAG,CAACoF,MAAM,CAACC,MAAM,CAAC,CAAC;IACpGJ,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC;IACxB,IAAIwD,UAAU,GAAG3H,0BAA0B,CAAC2D,OAAO,CAAC2D,UAAU,CAAC;MAC7DM,MAAM;IACR,IAAI;MACF,KAAKD,UAAU,CAAC/G,CAAC,CAAC,CAAC,EAAE,CAAC,CAACgH,MAAM,GAAGD,UAAU,CAAC9G,CAAC,CAAC,CAAC,EAAEC,IAAI,GAAG;QACrD,IAAIyD,CAAC,GAAGqD,MAAM,CAACvK,KAAK;QACpBuG,MAAM,CAACuC,KAAK,CAAC5B,CAAC,CAAC;MACjB;IACF,CAAC,CAAC,OAAOlD,GAAG,EAAE;MACZsG,UAAU,CAAC5G,CAAC,CAACM,GAAG,CAAC;IACnB,CAAC,SAAS;MACRsG,UAAU,CAAC1G,CAAC,CAAC,CAAC;IAChB;IACA2C,MAAM,CAACQ,MAAM,CAAC,CAAC;IACf,IAAIT,OAAO,CAAC4D,SAAS,KAAK,CAAC,EAAE;MAC3B3D,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACkC,KAAK,CAACxC,OAAO,CAAC4D,SAAS,CAAC;IAC5C;IACA,IAAI5D,OAAO,CAAC6D,eAAe,KAAK,CAAC,EAAE;MACjC5D,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACkC,KAAK,CAACxC,OAAO,CAAC6D,eAAe,CAAC;IAClD;IACA,IAAI7D,OAAO,CAAC8D,eAAe,KAAK,CAAC,EAAE;MACjC7D,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACkC,KAAK,CAACxC,OAAO,CAAC8D,eAAe,CAAC;IAClD;IACA,IAAI9D,OAAO,CAAC+D,UAAU,CAACjH,MAAM,KAAK,CAAC,EAAE;MACnCmD,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACC,KAAK,CAACP,OAAO,CAAC+D,UAAU,CAAC;IAC7C;IACA,IAAI/D,OAAO,CAACoC,IAAI,KAAK,CAAC,EAAE;MACtBnC,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACkC,KAAK,CAACxC,OAAO,CAACoC,IAAI,CAAC;IACvC;IACA,OAAOnC,MAAM;EACf,CAAC;EACDY,MAAM,EAAE,SAASA,MAAMA,CAACC,KAAK,EAAEhE,MAAM,EAAE;IACrC,IAAIiE,MAAM,GAAGD,KAAK,YAAY9F,GAAG,CAACgG,MAAM,GAAGF,KAAK,GAAG,IAAI9F,GAAG,CAACgG,MAAM,CAACF,KAAK,CAAC;IACxE,IAAIG,GAAG,GAAGnE,MAAM,KAAKqD,SAAS,GAAGY,MAAM,CAACxC,GAAG,GAAGwC,MAAM,CAACG,GAAG,GAAGpE,MAAM;IACjE,IAAIkD,OAAO,GAAG0D,mBAAmB,CAAC,CAAC;IACnC,OAAO3C,MAAM,CAACG,GAAG,GAAGD,GAAG,EAAE;MACvB,IAAIE,GAAG,GAAGJ,MAAM,CAACT,MAAM,CAAC,CAAC;MACzB,QAAQa,GAAG,KAAK,CAAC;QACf,KAAK,CAAC;UACJ,IAAI,CAACA,GAAG,GAAG,CAAC,MAAM,CAAC,EAAE;YACnB,IAAI+C,IAAI,GAAGnD,MAAM,CAACT,MAAM,CAAC,CAAC,GAAGS,MAAM,CAACG,GAAG;YACvC,OAAOH,MAAM,CAACG,GAAG,GAAGgD,IAAI,EAAE;cACxBlE,OAAO,CAAC2D,UAAU,CAACvC,IAAI,CAACL,MAAM,CAACyB,KAAK,CAAC,CAAC,CAAC;YACzC;UACF,CAAC,MAAM;YACLxC,OAAO,CAAC2D,UAAU,CAACvC,IAAI,CAACL,MAAM,CAACyB,KAAK,CAAC,CAAC,CAAC;UACzC;UACA;QACF,KAAK,CAAC;UACJxC,OAAO,CAAC4D,SAAS,GAAG7C,MAAM,CAACyB,KAAK,CAAC,CAAC;UAClC;QACF,KAAK,CAAC;UACJxC,OAAO,CAAC6D,eAAe,GAAG9C,MAAM,CAACyB,KAAK,CAAC,CAAC;UACxC;QACF,KAAK,CAAC;UACJxC,OAAO,CAAC8D,eAAe,GAAG/C,MAAM,CAACyB,KAAK,CAAC,CAAC;UACxC;QACF,KAAK,CAAC;UACJxC,OAAO,CAAC+D,UAAU,GAAGhD,MAAM,CAACR,KAAK,CAAC,CAAC;UACnC;QACF,KAAK,CAAC;UACJP,OAAO,CAACoC,IAAI,GAAGrB,MAAM,CAACyB,KAAK,CAAC,CAAC;UAC7B;QACF;UACEzB,MAAM,CAACM,QAAQ,CAACF,GAAG,GAAG,CAAC,CAAC;UACxB;MACJ;IACF;IACA,OAAOnB,OAAO;EAChB,CAAC;EACDH,WAAW,EAAE,SAASA,WAAWA,CAACpB,MAAM,EAAE;IACxC,IAAI0F,kBAAkB,EAAEC,iBAAiB,EAAEC,qBAAqB,EAAEC,qBAAqB,EAAEC,kBAAkB,EAAEC,aAAa;IAC1H,IAAIxE,OAAO,GAAG0D,mBAAmB,CAAC,CAAC;IACnC1D,OAAO,CAAC2D,UAAU,GAAG,CAAC,CAACQ,kBAAkB,GAAG1F,MAAM,CAACkF,UAAU,MAAM,IAAI,IAAIQ,kBAAkB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,kBAAkB,CAAC1C,GAAG,CAAC,UAAUrE,CAAC,EAAE;MACtJ,OAAOA,CAAC;IACV,CAAC,CAAC,KAAK,EAAE;IACT4C,OAAO,CAAC4D,SAAS,GAAG,CAACQ,iBAAiB,GAAG3F,MAAM,CAACmF,SAAS,MAAM,IAAI,IAAIQ,iBAAiB,KAAK,KAAK,CAAC,GAAGA,iBAAiB,GAAG,CAAC;IAC3HpE,OAAO,CAAC6D,eAAe,GAAG,CAACQ,qBAAqB,GAAG5F,MAAM,CAACoF,eAAe,MAAM,IAAI,IAAIQ,qBAAqB,KAAK,KAAK,CAAC,GAAGA,qBAAqB,GAAG,CAAC;IACnJrE,OAAO,CAAC8D,eAAe,GAAG,CAACQ,qBAAqB,GAAG7F,MAAM,CAACqF,eAAe,MAAM,IAAI,IAAIQ,qBAAqB,KAAK,KAAK,CAAC,GAAGA,qBAAqB,GAAG,CAAC;IACnJtE,OAAO,CAAC+D,UAAU,GAAG,CAACQ,kBAAkB,GAAG9F,MAAM,CAACsF,UAAU,MAAM,IAAI,IAAIQ,kBAAkB,KAAK,KAAK,CAAC,GAAGA,kBAAkB,GAAG,IAAI5E,UAAU,CAAC,CAAC;IAC/IK,OAAO,CAACoC,IAAI,GAAG,CAACoC,aAAa,GAAG/F,MAAM,CAAC2D,IAAI,MAAM,IAAI,IAAIoC,aAAa,KAAK,KAAK,CAAC,GAAGA,aAAa,GAAG,CAAC;IACrG,OAAOxE,OAAO;EAChB;AACF,CAAC;AACDvG,OAAO,CAACO,SAAS,GAAGA,SAAS;AAC7B,SAASyK,oBAAoBA,CAAA,EAAG;EAC9B,OAAO;IACLC,OAAO,EAAE;EACX,CAAC;AACH;AACA,IAAIhK,UAAU,GAAG;EACfqF,MAAM,EAAE,SAASA,MAAMA,CAACC,OAAO,EAAE;IAC/B,IAAIC,MAAM,GAAGC,SAAS,CAACpD,MAAM,GAAG,CAAC,IAAIoD,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAGlF,GAAG,CAACoF,MAAM,CAACC,MAAM,CAAC,CAAC;IACpG,IAAIsE,UAAU,GAAGtI,0BAA0B,CAAC2D,OAAO,CAAC0E,OAAO,CAAC;MAC1DE,MAAM;IACR,IAAI;MACF,KAAKD,UAAU,CAAC1H,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC2H,MAAM,GAAGD,UAAU,CAACzH,CAAC,CAAC,CAAC,EAAEC,IAAI,GAAG;QACrD,IAAIyD,CAAC,GAAGgE,MAAM,CAAClL,KAAK;QACpBiB,UAAU,CAACoF,MAAM,CAACa,CAAC,EAAEX,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;MACzD;IACF,CAAC,CAAC,OAAO/C,GAAG,EAAE;MACZiH,UAAU,CAACvH,CAAC,CAACM,GAAG,CAAC;IACnB,CAAC,SAAS;MACRiH,UAAU,CAACrH,CAAC,CAAC,CAAC;IAChB;IACA,OAAO2C,MAAM;EACf,CAAC;EACDY,MAAM,EAAE,SAASA,MAAMA,CAACC,KAAK,EAAEhE,MAAM,EAAE;IACrC,IAAIiE,MAAM,GAAGD,KAAK,YAAY9F,GAAG,CAACgG,MAAM,GAAGF,KAAK,GAAG,IAAI9F,GAAG,CAACgG,MAAM,CAACF,KAAK,CAAC;IACxE,IAAIG,GAAG,GAAGnE,MAAM,KAAKqD,SAAS,GAAGY,MAAM,CAACxC,GAAG,GAAGwC,MAAM,CAACG,GAAG,GAAGpE,MAAM;IACjE,IAAIkD,OAAO,GAAGyE,oBAAoB,CAAC,CAAC;IACpC,OAAO1D,MAAM,CAACG,GAAG,GAAGD,GAAG,EAAE;MACvB,IAAIE,GAAG,GAAGJ,MAAM,CAACT,MAAM,CAAC,CAAC;MACzB,QAAQa,GAAG,KAAK,CAAC;QACf,KAAK,CAAC;UACJnB,OAAO,CAAC0E,OAAO,CAACtD,IAAI,CAACzG,UAAU,CAACkG,MAAM,CAACE,MAAM,EAAEA,MAAM,CAACT,MAAM,CAAC,CAAC,CAAC,CAAC;UAChE;QACF;UACES,MAAM,CAACM,QAAQ,CAACF,GAAG,GAAG,CAAC,CAAC;UACxB;MACJ;IACF;IACA,OAAOnB,OAAO;EAChB,CAAC;EACDH,WAAW,EAAE,SAASA,WAAWA,CAACpB,MAAM,EAAE;IACxC,IAAIoG,eAAe;IACnB,IAAI7E,OAAO,GAAGyE,oBAAoB,CAAC,CAAC;IACpCzE,OAAO,CAAC0E,OAAO,GAAG,CAAC,CAACG,eAAe,GAAGpG,MAAM,CAACiG,OAAO,MAAM,IAAI,IAAIG,eAAe,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,eAAe,CAACpD,GAAG,CAAC,UAAUrE,CAAC,EAAE;MACvI,OAAOzC,UAAU,CAACkF,WAAW,CAACzC,CAAC,CAAC;IAClC,CAAC,CAAC,KAAK,EAAE;IACT,OAAO4C,OAAO;EAChB;AACF,CAAC;AACDvG,OAAO,CAACiB,UAAU,GAAGA,UAAU;AAC/B,SAASoK,oBAAoBA,CAAA,EAAG;EAC9B,OAAO;IACL/C,KAAK,EAAE5B,SAAS;IAChB6B,QAAQ,EAAE7B;EACZ,CAAC;AACH;AACA,IAAIxF,UAAU,GAAG;EACfoF,MAAM,EAAE,SAASA,MAAMA,CAACC,OAAO,EAAE;IAC/B,IAAIC,MAAM,GAAGC,SAAS,CAACpD,MAAM,GAAG,CAAC,IAAIoD,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAGlF,GAAG,CAACoF,MAAM,CAACC,MAAM,CAAC,CAAC;IACpG,IAAIL,OAAO,CAAC+B,KAAK,KAAK5B,SAAS,EAAE;MAC/B/F,cAAc,CAAC2F,MAAM,CAACC,OAAO,CAAC+B,KAAK,EAAE9B,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;IACzE;IACA,IAAIT,OAAO,CAACgC,QAAQ,KAAK7B,SAAS,EAAE;MAClCvG,iBAAiB,CAACmG,MAAM,CAACC,OAAO,CAACgC,QAAQ,EAAE/B,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;IAC/E;IACA,OAAOR,MAAM;EACf,CAAC;EACDY,MAAM,EAAE,SAASA,MAAMA,CAACC,KAAK,EAAEhE,MAAM,EAAE;IACrC,IAAIiE,MAAM,GAAGD,KAAK,YAAY9F,GAAG,CAACgG,MAAM,GAAGF,KAAK,GAAG,IAAI9F,GAAG,CAACgG,MAAM,CAACF,KAAK,CAAC;IACxE,IAAIG,GAAG,GAAGnE,MAAM,KAAKqD,SAAS,GAAGY,MAAM,CAACxC,GAAG,GAAGwC,MAAM,CAACG,GAAG,GAAGpE,MAAM;IACjE,IAAIkD,OAAO,GAAG8E,oBAAoB,CAAC,CAAC;IACpC,OAAO/D,MAAM,CAACG,GAAG,GAAGD,GAAG,EAAE;MACvB,IAAIE,GAAG,GAAGJ,MAAM,CAACT,MAAM,CAAC,CAAC;MACzB,QAAQa,GAAG,KAAK,CAAC;QACf,KAAK,CAAC;UACJnB,OAAO,CAAC+B,KAAK,GAAG3H,cAAc,CAACyG,MAAM,CAACE,MAAM,EAAEA,MAAM,CAACT,MAAM,CAAC,CAAC,CAAC;UAC9D;QACF,KAAK,CAAC;UACJN,OAAO,CAACgC,QAAQ,GAAGpI,iBAAiB,CAACiH,MAAM,CAACE,MAAM,EAAEA,MAAM,CAACT,MAAM,CAAC,CAAC,CAAC;UACpE;QACF;UACES,MAAM,CAACM,QAAQ,CAACF,GAAG,GAAG,CAAC,CAAC;UACxB;MACJ;IACF;IACA,OAAOnB,OAAO;EAChB,CAAC;EACDH,WAAW,EAAE,SAASA,WAAWA,CAACpB,MAAM,EAAE;IACxC,IAAIuB,OAAO,GAAG8E,oBAAoB,CAAC,CAAC;IACpC9E,OAAO,CAAC+B,KAAK,GAAGtD,MAAM,CAACsD,KAAK,KAAK5B,SAAS,IAAI1B,MAAM,CAACsD,KAAK,KAAK,IAAI,GAAG3H,cAAc,CAACyF,WAAW,CAACpB,MAAM,CAACsD,KAAK,CAAC,GAAG5B,SAAS;IAC1HH,OAAO,CAACgC,QAAQ,GAAGvD,MAAM,CAACuD,QAAQ,KAAK7B,SAAS,IAAI1B,MAAM,CAACuD,QAAQ,KAAK,IAAI,GAAGpI,iBAAiB,CAACiG,WAAW,CAACpB,MAAM,CAACuD,QAAQ,CAAC,GAAG7B,SAAS;IACzI,OAAOH,OAAO;EAChB;AACF,CAAC;AACDvG,OAAO,CAACkB,UAAU,GAAGA,UAAU;AAC/B,SAASoK,8BAA8BA,CAAA,EAAG;EACxC,OAAO;IACLL,OAAO,EAAE,EAAE;IACXM,YAAY,EAAE;EAChB,CAAC;AACH;AACA,IAAIzK,oBAAoB,GAAG;EACzBwF,MAAM,EAAE,SAASA,MAAMA,CAACC,OAAO,EAAE;IAC/B,IAAIC,MAAM,GAAGC,SAAS,CAACpD,MAAM,GAAG,CAAC,IAAIoD,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAGlF,GAAG,CAACoF,MAAM,CAACC,MAAM,CAAC,CAAC;IACpG,IAAI4E,UAAU,GAAG5I,0BAA0B,CAAC2D,OAAO,CAAC0E,OAAO,CAAC;MAC1DQ,MAAM;IACR,IAAI;MACF,KAAKD,UAAU,CAAChI,CAAC,CAAC,CAAC,EAAE,CAAC,CAACiI,MAAM,GAAGD,UAAU,CAAC/H,CAAC,CAAC,CAAC,EAAEC,IAAI,GAAG;QACrD,IAAIyD,CAAC,GAAGsE,MAAM,CAACxL,KAAK;QACpBc,oBAAoB,CAACuF,MAAM,CAACa,CAAC,EAAEX,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;MACnE;IACF,CAAC,CAAC,OAAO/C,GAAG,EAAE;MACZuH,UAAU,CAAC7H,CAAC,CAACM,GAAG,CAAC;IACnB,CAAC,SAAS;MACRuH,UAAU,CAAC3H,CAAC,CAAC,CAAC;IAChB;IACA,IAAI6H,UAAU,GAAG9I,0BAA0B,CAAC2D,OAAO,CAACgF,YAAY,CAAC;MAC/DI,MAAM;IACR,IAAI;MACF,KAAKD,UAAU,CAAClI,CAAC,CAAC,CAAC,EAAE,CAAC,CAACmI,MAAM,GAAGD,UAAU,CAACjI,CAAC,CAAC,CAAC,EAAEC,IAAI,GAAG;QACrD,IAAIkI,EAAE,GAAGD,MAAM,CAAC1L,KAAK;QACrBO,OAAO,CAAC8F,MAAM,CAACsF,EAAE,EAAEpF,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;MACvD;IACF,CAAC,CAAC,OAAO/C,GAAG,EAAE;MACZyH,UAAU,CAAC/H,CAAC,CAACM,GAAG,CAAC;IACnB,CAAC,SAAS;MACRyH,UAAU,CAAC7H,CAAC,CAAC,CAAC;IAChB;IACA,OAAO2C,MAAM;EACf,CAAC;EACDY,MAAM,EAAE,SAASA,MAAMA,CAACC,KAAK,EAAEhE,MAAM,EAAE;IACrC,IAAIiE,MAAM,GAAGD,KAAK,YAAY9F,GAAG,CAACgG,MAAM,GAAGF,KAAK,GAAG,IAAI9F,GAAG,CAACgG,MAAM,CAACF,KAAK,CAAC;IACxE,IAAIG,GAAG,GAAGnE,MAAM,KAAKqD,SAAS,GAAGY,MAAM,CAACxC,GAAG,GAAGwC,MAAM,CAACG,GAAG,GAAGpE,MAAM;IACjE,IAAIkD,OAAO,GAAG+E,8BAA8B,CAAC,CAAC;IAC9C,OAAOhE,MAAM,CAACG,GAAG,GAAGD,GAAG,EAAE;MACvB,IAAIE,GAAG,GAAGJ,MAAM,CAACT,MAAM,CAAC,CAAC;MACzB,QAAQa,GAAG,KAAK,CAAC;QACf,KAAK,CAAC;UACJnB,OAAO,CAAC0E,OAAO,CAACtD,IAAI,CAAC5G,oBAAoB,CAACqG,MAAM,CAACE,MAAM,EAAEA,MAAM,CAACT,MAAM,CAAC,CAAC,CAAC,CAAC;UAC1E;QACF,KAAK,CAAC;UACJN,OAAO,CAACgF,YAAY,CAAC5D,IAAI,CAACnH,OAAO,CAAC4G,MAAM,CAACE,MAAM,EAAEA,MAAM,CAACT,MAAM,CAAC,CAAC,CAAC,CAAC;UAClE;QACF;UACES,MAAM,CAACM,QAAQ,CAACF,GAAG,GAAG,CAAC,CAAC;UACxB;MACJ;IACF;IACA,OAAOnB,OAAO;EAChB,CAAC;EACDH,WAAW,EAAE,SAASA,WAAWA,CAACpB,MAAM,EAAE;IACxC,IAAI6G,gBAAgB,EAAEC,oBAAoB;IAC1C,IAAIvF,OAAO,GAAG+E,8BAA8B,CAAC,CAAC;IAC9C/E,OAAO,CAAC0E,OAAO,GAAG,CAAC,CAACY,gBAAgB,GAAG7G,MAAM,CAACiG,OAAO,MAAM,IAAI,IAAIY,gBAAgB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,gBAAgB,CAAC7D,GAAG,CAAC,UAAUrE,CAAC,EAAE;MAC1I,OAAO5C,oBAAoB,CAACqF,WAAW,CAACzC,CAAC,CAAC;IAC5C,CAAC,CAAC,KAAK,EAAE;IACT4C,OAAO,CAACgF,YAAY,GAAG,CAAC,CAACO,oBAAoB,GAAG9G,MAAM,CAACuG,YAAY,MAAM,IAAI,IAAIO,oBAAoB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,oBAAoB,CAAC9D,GAAG,CAAC,UAAUrE,CAAC,EAAE;MAChK,OAAOnD,OAAO,CAAC4F,WAAW,CAACzC,CAAC,CAAC;IAC/B,CAAC,CAAC,KAAK,EAAE;IACT,OAAO4C,OAAO;EAChB;AACF,CAAC;AACDvG,OAAO,CAACc,oBAAoB,GAAGA,oBAAoB;AACnD,SAASiL,8BAA8BA,CAAA,EAAG;EACxC,OAAO;IACLzD,KAAK,EAAE5B,SAAS;IAChB6B,QAAQ,EAAE7B;EACZ,CAAC;AACH;AACA,IAAI3F,oBAAoB,GAAG;EACzBuF,MAAM,EAAE,SAASA,MAAMA,CAACC,OAAO,EAAE;IAC/B,IAAIC,MAAM,GAAGC,SAAS,CAACpD,MAAM,GAAG,CAAC,IAAIoD,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAGlF,GAAG,CAACoF,MAAM,CAACC,MAAM,CAAC,CAAC;IACpG,IAAIL,OAAO,CAAC+B,KAAK,KAAK5B,SAAS,EAAE;MAC/B7F,wBAAwB,CAACyF,MAAM,CAACC,OAAO,CAAC+B,KAAK,EAAE9B,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;IACnF;IACA,IAAIT,OAAO,CAACgC,QAAQ,KAAK7B,SAAS,EAAE;MAClC9F,2BAA2B,CAAC0F,MAAM,CAACC,OAAO,CAACgC,QAAQ,EAAE/B,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;IACzF;IACA,OAAOR,MAAM;EACf,CAAC;EACDY,MAAM,EAAE,SAASA,MAAMA,CAACC,KAAK,EAAEhE,MAAM,EAAE;IACrC,IAAIiE,MAAM,GAAGD,KAAK,YAAY9F,GAAG,CAACgG,MAAM,GAAGF,KAAK,GAAG,IAAI9F,GAAG,CAACgG,MAAM,CAACF,KAAK,CAAC;IACxE,IAAIG,GAAG,GAAGnE,MAAM,KAAKqD,SAAS,GAAGY,MAAM,CAACxC,GAAG,GAAGwC,MAAM,CAACG,GAAG,GAAGpE,MAAM;IACjE,IAAIkD,OAAO,GAAGwF,8BAA8B,CAAC,CAAC;IAC9C,OAAOzE,MAAM,CAACG,GAAG,GAAGD,GAAG,EAAE;MACvB,IAAIE,GAAG,GAAGJ,MAAM,CAACT,MAAM,CAAC,CAAC;MACzB,QAAQa,GAAG,KAAK,CAAC;QACf,KAAK,CAAC;UACJnB,OAAO,CAAC+B,KAAK,GAAGzH,wBAAwB,CAACuG,MAAM,CAACE,MAAM,EAAEA,MAAM,CAACT,MAAM,CAAC,CAAC,CAAC;UACxE;QACF,KAAK,CAAC;UACJN,OAAO,CAACgC,QAAQ,GAAG3H,2BAA2B,CAACwG,MAAM,CAACE,MAAM,EAAEA,MAAM,CAACT,MAAM,CAAC,CAAC,CAAC;UAC9E;QACF;UACES,MAAM,CAACM,QAAQ,CAACF,GAAG,GAAG,CAAC,CAAC;UACxB;MACJ;IACF;IACA,OAAOnB,OAAO;EAChB,CAAC;EACDH,WAAW,EAAE,SAASA,WAAWA,CAACpB,MAAM,EAAE;IACxC,IAAIuB,OAAO,GAAGwF,8BAA8B,CAAC,CAAC;IAC9CxF,OAAO,CAAC+B,KAAK,GAAGtD,MAAM,CAACsD,KAAK,KAAK5B,SAAS,IAAI1B,MAAM,CAACsD,KAAK,KAAK,IAAI,GAAGzH,wBAAwB,CAACuF,WAAW,CAACpB,MAAM,CAACsD,KAAK,CAAC,GAAG5B,SAAS;IACpIH,OAAO,CAACgC,QAAQ,GAAGvD,MAAM,CAACuD,QAAQ,KAAK7B,SAAS,IAAI1B,MAAM,CAACuD,QAAQ,KAAK,IAAI,GAAG3H,2BAA2B,CAACwF,WAAW,CAACpB,MAAM,CAACuD,QAAQ,CAAC,GAAG7B,SAAS;IACnJ,OAAOH,OAAO;EAChB;AACF,CAAC;AACDvG,OAAO,CAACe,oBAAoB,GAAGA,oBAAoB;AACnD,SAASiL,kCAAkCA,CAAA,EAAG;EAC5C,OAAO;IACL1J,GAAG,EAAE,IAAI4D,UAAU,CAAC,CAAC;IACrBjG,KAAK,EAAE,IAAIiG,UAAU,CAAC,CAAC;IACvBC,IAAI,EAAE7F,MAAM,CAAC8F,WAAW,CAAC,CAAC,CAAC,CAAC;IAC5BC,IAAI,EAAE;EACR,CAAC;AACH;AACA,IAAIxF,wBAAwB,GAAG;EAC7ByF,MAAM,EAAE,SAASA,MAAMA,CAACC,OAAO,EAAE;IAC/B,IAAIC,MAAM,GAAGC,SAAS,CAACpD,MAAM,GAAG,CAAC,IAAIoD,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAGlF,GAAG,CAACoF,MAAM,CAACC,MAAM,CAAC,CAAC;IACpG,IAAIL,OAAO,CAACjE,GAAG,CAACe,MAAM,KAAK,CAAC,EAAE;MAC5BmD,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACC,KAAK,CAACP,OAAO,CAACjE,GAAG,CAAC;IACtC;IACA,IAAIiE,OAAO,CAACtG,KAAK,CAACoD,MAAM,KAAK,CAAC,EAAE;MAC9BmD,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACC,KAAK,CAACP,OAAO,CAACtG,KAAK,CAAC;IACxC;IACA,IAAIsG,OAAO,CAACJ,IAAI,KAAKO,SAAS,EAAE;MAC9BpG,MAAM,CAACgG,MAAM,CAACC,OAAO,CAACJ,IAAI,EAAEK,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;IAChE;IACAR,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC;IACxB,IAAIkF,UAAU,GAAGrJ,0BAA0B,CAAC2D,OAAO,CAACF,IAAI,CAAC;MACvD6F,MAAM;IACR,IAAI;MACF,KAAKD,UAAU,CAACzI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC0I,MAAM,GAAGD,UAAU,CAACxI,CAAC,CAAC,CAAC,EAAEC,IAAI,GAAG;QACrD,IAAIyD,CAAC,GAAG+E,MAAM,CAACjM,KAAK;QACpBuG,MAAM,CAACuC,KAAK,CAAC5B,CAAC,CAAC;MACjB;IACF,CAAC,CAAC,OAAOlD,GAAG,EAAE;MACZgI,UAAU,CAACtI,CAAC,CAACM,GAAG,CAAC;IACnB,CAAC,SAAS;MACRgI,UAAU,CAACpI,CAAC,CAAC,CAAC;IAChB;IACA2C,MAAM,CAACQ,MAAM,CAAC,CAAC;IACf,OAAOR,MAAM;EACf,CAAC;EACDY,MAAM,EAAE,SAASA,MAAMA,CAACC,KAAK,EAAEhE,MAAM,EAAE;IACrC,IAAIiE,MAAM,GAAGD,KAAK,YAAY9F,GAAG,CAACgG,MAAM,GAAGF,KAAK,GAAG,IAAI9F,GAAG,CAACgG,MAAM,CAACF,KAAK,CAAC;IACxE,IAAIG,GAAG,GAAGnE,MAAM,KAAKqD,SAAS,GAAGY,MAAM,CAACxC,GAAG,GAAGwC,MAAM,CAACG,GAAG,GAAGpE,MAAM;IACjE,IAAIkD,OAAO,GAAGyF,kCAAkC,CAAC,CAAC;IAClD,OAAO1E,MAAM,CAACG,GAAG,GAAGD,GAAG,EAAE;MACvB,IAAIE,GAAG,GAAGJ,MAAM,CAACT,MAAM,CAAC,CAAC;MACzB,QAAQa,GAAG,KAAK,CAAC;QACf,KAAK,CAAC;UACJnB,OAAO,CAACjE,GAAG,GAAGgF,MAAM,CAACR,KAAK,CAAC,CAAC;UAC5B;QACF,KAAK,CAAC;UACJP,OAAO,CAACtG,KAAK,GAAGqH,MAAM,CAACR,KAAK,CAAC,CAAC;UAC9B;QACF,KAAK,CAAC;UACJP,OAAO,CAACJ,IAAI,GAAG7F,MAAM,CAAC8G,MAAM,CAACE,MAAM,EAAEA,MAAM,CAACT,MAAM,CAAC,CAAC,CAAC;UACrD;QACF,KAAK,CAAC;UACJ,IAAI,CAACa,GAAG,GAAG,CAAC,MAAM,CAAC,EAAE;YACnB,IAAI+C,IAAI,GAAGnD,MAAM,CAACT,MAAM,CAAC,CAAC,GAAGS,MAAM,CAACG,GAAG;YACvC,OAAOH,MAAM,CAACG,GAAG,GAAGgD,IAAI,EAAE;cACxBlE,OAAO,CAACF,IAAI,CAACsB,IAAI,CAACL,MAAM,CAACyB,KAAK,CAAC,CAAC,CAAC;YACnC;UACF,CAAC,MAAM;YACLxC,OAAO,CAACF,IAAI,CAACsB,IAAI,CAACL,MAAM,CAACyB,KAAK,CAAC,CAAC,CAAC;UACnC;UACA;QACF;UACEzB,MAAM,CAACM,QAAQ,CAACF,GAAG,GAAG,CAAC,CAAC;UACxB;MACJ;IACF;IACA,OAAOnB,OAAO;EAChB,CAAC;EACDH,WAAW,EAAE,SAASA,WAAWA,CAACpB,MAAM,EAAE;IACxC,IAAImH,YAAY,EAAEC,cAAc,EAAEC,aAAa;IAC/C,IAAI9F,OAAO,GAAGyF,kCAAkC,CAAC,CAAC;IAClDzF,OAAO,CAACjE,GAAG,GAAG,CAAC6J,YAAY,GAAGnH,MAAM,CAAC1C,GAAG,MAAM,IAAI,IAAI6J,YAAY,KAAK,KAAK,CAAC,GAAGA,YAAY,GAAG,IAAIjG,UAAU,CAAC,CAAC;IAC/GK,OAAO,CAACtG,KAAK,GAAG,CAACmM,cAAc,GAAGpH,MAAM,CAAC/E,KAAK,MAAM,IAAI,IAAImM,cAAc,KAAK,KAAK,CAAC,GAAGA,cAAc,GAAG,IAAIlG,UAAU,CAAC,CAAC;IACzHK,OAAO,CAACJ,IAAI,GAAGnB,MAAM,CAACmB,IAAI,KAAKO,SAAS,IAAI1B,MAAM,CAACmB,IAAI,KAAK,IAAI,GAAG7F,MAAM,CAAC8F,WAAW,CAACpB,MAAM,CAACmB,IAAI,CAAC,GAAGO,SAAS;IAC9GH,OAAO,CAACF,IAAI,GAAG,CAAC,CAACgG,aAAa,GAAGrH,MAAM,CAACqB,IAAI,MAAM,IAAI,IAAIgG,aAAa,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,aAAa,CAACrE,GAAG,CAAC,UAAUrE,CAAC,EAAE;MAC3H,OAAOA,CAAC;IACV,CAAC,CAAC,KAAK,EAAE;IACT,OAAO4C,OAAO;EAChB;AACF,CAAC;AACDvG,OAAO,CAACa,wBAAwB,GAAGA,wBAAwB;AAC3D,SAASyL,qCAAqCA,CAAA,EAAG;EAC/C,OAAO;IACLhK,GAAG,EAAE,IAAI4D,UAAU,CAAC,CAAC;IACrBgC,IAAI,EAAErH,wBAAwB,CAACuF,WAAW,CAAC,CAAC,CAAC,CAAC;IAC9C+B,KAAK,EAAEtH,wBAAwB,CAACuF,WAAW,CAAC,CAAC,CAAC;EAChD,CAAC;AACH;AACA,IAAIxF,2BAA2B,GAAG;EAChC0F,MAAM,EAAE,SAASA,MAAMA,CAACC,OAAO,EAAE;IAC/B,IAAIC,MAAM,GAAGC,SAAS,CAACpD,MAAM,GAAG,CAAC,IAAIoD,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAGlF,GAAG,CAACoF,MAAM,CAACC,MAAM,CAAC,CAAC;IACpG,IAAIL,OAAO,CAACjE,GAAG,CAACe,MAAM,KAAK,CAAC,EAAE;MAC5BmD,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACC,KAAK,CAACP,OAAO,CAACjE,GAAG,CAAC;IACtC;IACA,IAAIiE,OAAO,CAAC2B,IAAI,KAAKxB,SAAS,EAAE;MAC9B7F,wBAAwB,CAACyF,MAAM,CAACC,OAAO,CAAC2B,IAAI,EAAE1B,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;IAClF;IACA,IAAIT,OAAO,CAAC4B,KAAK,KAAKzB,SAAS,EAAE;MAC/B7F,wBAAwB,CAACyF,MAAM,CAACC,OAAO,CAAC4B,KAAK,EAAE3B,MAAM,CAACK,MAAM,CAAC,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;IACnF;IACA,OAAOR,MAAM;EACf,CAAC;EACDY,MAAM,EAAE,SAASA,MAAMA,CAACC,KAAK,EAAEhE,MAAM,EAAE;IACrC,IAAIiE,MAAM,GAAGD,KAAK,YAAY9F,GAAG,CAACgG,MAAM,GAAGF,KAAK,GAAG,IAAI9F,GAAG,CAACgG,MAAM,CAACF,KAAK,CAAC;IACxE,IAAIG,GAAG,GAAGnE,MAAM,KAAKqD,SAAS,GAAGY,MAAM,CAACxC,GAAG,GAAGwC,MAAM,CAACG,GAAG,GAAGpE,MAAM;IACjE,IAAIkD,OAAO,GAAG+F,qCAAqC,CAAC,CAAC;IACrD,OAAOhF,MAAM,CAACG,GAAG,GAAGD,GAAG,EAAE;MACvB,IAAIE,GAAG,GAAGJ,MAAM,CAACT,MAAM,CAAC,CAAC;MACzB,QAAQa,GAAG,KAAK,CAAC;QACf,KAAK,CAAC;UACJnB,OAAO,CAACjE,GAAG,GAAGgF,MAAM,CAACR,KAAK,CAAC,CAAC;UAC5B;QACF,KAAK,CAAC;UACJP,OAAO,CAAC2B,IAAI,GAAGrH,wBAAwB,CAACuG,MAAM,CAACE,MAAM,EAAEA,MAAM,CAACT,MAAM,CAAC,CAAC,CAAC;UACvE;QACF,KAAK,CAAC;UACJN,OAAO,CAAC4B,KAAK,GAAGtH,wBAAwB,CAACuG,MAAM,CAACE,MAAM,EAAEA,MAAM,CAACT,MAAM,CAAC,CAAC,CAAC;UACxE;QACF;UACES,MAAM,CAACM,QAAQ,CAACF,GAAG,GAAG,CAAC,CAAC;UACxB;MACJ;IACF;IACA,OAAOnB,OAAO;EAChB,CAAC;EACDH,WAAW,EAAE,SAASA,WAAWA,CAACpB,MAAM,EAAE;IACxC,IAAIuH,YAAY;IAChB,IAAIhG,OAAO,GAAG+F,qCAAqC,CAAC,CAAC;IACrD/F,OAAO,CAACjE,GAAG,GAAG,CAACiK,YAAY,GAAGvH,MAAM,CAAC1C,GAAG,MAAM,IAAI,IAAIiK,YAAY,KAAK,KAAK,CAAC,GAAGA,YAAY,GAAG,IAAIrG,UAAU,CAAC,CAAC;IAC/GK,OAAO,CAAC2B,IAAI,GAAGlD,MAAM,CAACkD,IAAI,KAAKxB,SAAS,IAAI1B,MAAM,CAACkD,IAAI,KAAK,IAAI,GAAGrH,wBAAwB,CAACuF,WAAW,CAACpB,MAAM,CAACkD,IAAI,CAAC,GAAGxB,SAAS;IAChIH,OAAO,CAAC4B,KAAK,GAAGnD,MAAM,CAACmD,KAAK,KAAKzB,SAAS,IAAI1B,MAAM,CAACmD,KAAK,KAAK,IAAI,GAAGtH,wBAAwB,CAACuF,WAAW,CAACpB,MAAM,CAACmD,KAAK,CAAC,GAAGzB,SAAS;IACpI,OAAOH,OAAO;EAChB;AACF,CAAC;AACDvG,OAAO,CAACY,2BAA2B,GAAGA,2BAA2B"},"metadata":{},"sourceType":"script"}