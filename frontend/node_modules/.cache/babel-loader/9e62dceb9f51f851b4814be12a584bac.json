{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/linanqi/Hackathon/GameRoom/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/linanqi/Hackathon/GameRoom/frontend/node_modules/@babel/runtime/helpers/createClass\");\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MsgClientImpl = exports.MsgAcknowledgementResponse = exports.MsgAcknowledgement = exports.MsgTimeoutOnCloseResponse = exports.MsgTimeoutOnClose = exports.MsgTimeoutResponse = exports.MsgTimeout = exports.MsgRecvPacketResponse = exports.MsgRecvPacket = exports.MsgChannelCloseConfirmResponse = exports.MsgChannelCloseConfirm = exports.MsgChannelCloseInitResponse = exports.MsgChannelCloseInit = exports.MsgChannelOpenConfirmResponse = exports.MsgChannelOpenConfirm = exports.MsgChannelOpenAckResponse = exports.MsgChannelOpenAck = exports.MsgChannelOpenTryResponse = exports.MsgChannelOpenTry = exports.MsgChannelOpenInitResponse = exports.MsgChannelOpenInit = exports.responseResultTypeToJSON = exports.responseResultTypeFromJSON = exports.ResponseResultType = exports.protobufPackage = void 0;\n/* eslint-disable */\nvar long_1 = __importDefault(require(\"long\"));\nvar minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nvar client_1 = require(\"../../client/v1/client\");\nvar channel_1 = require(\"./channel\");\nexports.protobufPackage = \"ibc.core.channel.v1\";\n/** ResponseResultType defines the possible outcomes of the execution of a message */\nvar ResponseResultType;\n(function (ResponseResultType) {\n  /** RESPONSE_RESULT_UNSPECIFIED - Default zero value enumeration */\n  ResponseResultType[ResponseResultType[\"RESPONSE_RESULT_UNSPECIFIED\"] = 0] = \"RESPONSE_RESULT_UNSPECIFIED\";\n  /** RESPONSE_RESULT_NOOP - The message did not call the IBC application callbacks (because, for example, the packet had already been relayed) */\n  ResponseResultType[ResponseResultType[\"RESPONSE_RESULT_NOOP\"] = 1] = \"RESPONSE_RESULT_NOOP\";\n  /** RESPONSE_RESULT_SUCCESS - The message was executed successfully */\n  ResponseResultType[ResponseResultType[\"RESPONSE_RESULT_SUCCESS\"] = 2] = \"RESPONSE_RESULT_SUCCESS\";\n  ResponseResultType[ResponseResultType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ResponseResultType = exports.ResponseResultType || (exports.ResponseResultType = {}));\nfunction responseResultTypeFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"RESPONSE_RESULT_UNSPECIFIED\":\n      return ResponseResultType.RESPONSE_RESULT_UNSPECIFIED;\n    case 1:\n    case \"RESPONSE_RESULT_NOOP\":\n      return ResponseResultType.RESPONSE_RESULT_NOOP;\n    case 2:\n    case \"RESPONSE_RESULT_SUCCESS\":\n      return ResponseResultType.RESPONSE_RESULT_SUCCESS;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return ResponseResultType.UNRECOGNIZED;\n  }\n}\nexports.responseResultTypeFromJSON = responseResultTypeFromJSON;\nfunction responseResultTypeToJSON(object) {\n  switch (object) {\n    case ResponseResultType.RESPONSE_RESULT_UNSPECIFIED:\n      return \"RESPONSE_RESULT_UNSPECIFIED\";\n    case ResponseResultType.RESPONSE_RESULT_NOOP:\n      return \"RESPONSE_RESULT_NOOP\";\n    case ResponseResultType.RESPONSE_RESULT_SUCCESS:\n      return \"RESPONSE_RESULT_SUCCESS\";\n    case ResponseResultType.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nexports.responseResultTypeToJSON = responseResultTypeToJSON;\nfunction createBaseMsgChannelOpenInit() {\n  return {\n    portId: \"\",\n    channel: undefined,\n    signer: \"\"\n  };\n}\nexports.MsgChannelOpenInit = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n    if (message.channel !== undefined) {\n      channel_1.Channel.encode(message.channel, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.signer !== \"\") {\n      writer.uint32(26).string(message.signer);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgChannelOpenInit();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n        case 2:\n          message.channel = channel_1.Channel.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.signer = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    return {\n      portId: isSet(object.portId) ? String(object.portId) : \"\",\n      channel: isSet(object.channel) ? channel_1.Channel.fromJSON(object.channel) : undefined,\n      signer: isSet(object.signer) ? String(object.signer) : \"\"\n    };\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.channel !== undefined && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a, _b;\n    var message = createBaseMsgChannelOpenInit();\n    message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : \"\";\n    message.channel = object.channel !== undefined && object.channel !== null ? channel_1.Channel.fromPartial(object.channel) : undefined;\n    message.signer = (_b = object.signer) !== null && _b !== void 0 ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseMsgChannelOpenInitResponse() {\n  return {\n    channelId: \"\"\n  };\n}\nexports.MsgChannelOpenInitResponse = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.channelId !== \"\") {\n      writer.uint32(10).string(message.channelId);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgChannelOpenInitResponse();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.channelId = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    return {\n      channelId: isSet(object.channelId) ? String(object.channelId) : \"\"\n    };\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.channelId !== undefined && (obj.channelId = message.channelId);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a;\n    var message = createBaseMsgChannelOpenInitResponse();\n    message.channelId = (_a = object.channelId) !== null && _a !== void 0 ? _a : \"\";\n    return message;\n  }\n};\nfunction createBaseMsgChannelOpenTry() {\n  return {\n    portId: \"\",\n    previousChannelId: \"\",\n    channel: undefined,\n    counterpartyVersion: \"\",\n    proofInit: new Uint8Array(),\n    proofHeight: undefined,\n    signer: \"\"\n  };\n}\nexports.MsgChannelOpenTry = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n    if (message.previousChannelId !== \"\") {\n      writer.uint32(18).string(message.previousChannelId);\n    }\n    if (message.channel !== undefined) {\n      channel_1.Channel.encode(message.channel, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.counterpartyVersion !== \"\") {\n      writer.uint32(34).string(message.counterpartyVersion);\n    }\n    if (message.proofInit.length !== 0) {\n      writer.uint32(42).bytes(message.proofInit);\n    }\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.signer !== \"\") {\n      writer.uint32(58).string(message.signer);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgChannelOpenTry();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n        case 2:\n          message.previousChannelId = reader.string();\n          break;\n        case 3:\n          message.channel = channel_1.Channel.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.counterpartyVersion = reader.string();\n          break;\n        case 5:\n          message.proofInit = reader.bytes();\n          break;\n        case 6:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n        case 7:\n          message.signer = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    return {\n      portId: isSet(object.portId) ? String(object.portId) : \"\",\n      previousChannelId: isSet(object.previousChannelId) ? String(object.previousChannelId) : \"\",\n      channel: isSet(object.channel) ? channel_1.Channel.fromJSON(object.channel) : undefined,\n      counterpartyVersion: isSet(object.counterpartyVersion) ? String(object.counterpartyVersion) : \"\",\n      proofInit: isSet(object.proofInit) ? bytesFromBase64(object.proofInit) : new Uint8Array(),\n      proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : undefined,\n      signer: isSet(object.signer) ? String(object.signer) : \"\"\n    };\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.previousChannelId !== undefined && (obj.previousChannelId = message.previousChannelId);\n    message.channel !== undefined && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : undefined);\n    message.counterpartyVersion !== undefined && (obj.counterpartyVersion = message.counterpartyVersion);\n    message.proofInit !== undefined && (obj.proofInit = base64FromBytes(message.proofInit !== undefined ? message.proofInit : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    var message = createBaseMsgChannelOpenTry();\n    message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : \"\";\n    message.previousChannelId = (_b = object.previousChannelId) !== null && _b !== void 0 ? _b : \"\";\n    message.channel = object.channel !== undefined && object.channel !== null ? channel_1.Channel.fromPartial(object.channel) : undefined;\n    message.counterpartyVersion = (_c = object.counterpartyVersion) !== null && _c !== void 0 ? _c : \"\";\n    message.proofInit = (_d = object.proofInit) !== null && _d !== void 0 ? _d : new Uint8Array();\n    message.proofHeight = object.proofHeight !== undefined && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : undefined;\n    message.signer = (_e = object.signer) !== null && _e !== void 0 ? _e : \"\";\n    return message;\n  }\n};\nfunction createBaseMsgChannelOpenTryResponse() {\n  return {};\n}\nexports.MsgChannelOpenTryResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgChannelOpenTryResponse();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(_) {\n    return {};\n  },\n  toJSON: function toJSON(_) {\n    var obj = {};\n    return obj;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = createBaseMsgChannelOpenTryResponse();\n    return message;\n  }\n};\nfunction createBaseMsgChannelOpenAck() {\n  return {\n    portId: \"\",\n    channelId: \"\",\n    counterpartyChannelId: \"\",\n    counterpartyVersion: \"\",\n    proofTry: new Uint8Array(),\n    proofHeight: undefined,\n    signer: \"\"\n  };\n}\nexports.MsgChannelOpenAck = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n    if (message.channelId !== \"\") {\n      writer.uint32(18).string(message.channelId);\n    }\n    if (message.counterpartyChannelId !== \"\") {\n      writer.uint32(26).string(message.counterpartyChannelId);\n    }\n    if (message.counterpartyVersion !== \"\") {\n      writer.uint32(34).string(message.counterpartyVersion);\n    }\n    if (message.proofTry.length !== 0) {\n      writer.uint32(42).bytes(message.proofTry);\n    }\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.signer !== \"\") {\n      writer.uint32(58).string(message.signer);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgChannelOpenAck();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n        case 2:\n          message.channelId = reader.string();\n          break;\n        case 3:\n          message.counterpartyChannelId = reader.string();\n          break;\n        case 4:\n          message.counterpartyVersion = reader.string();\n          break;\n        case 5:\n          message.proofTry = reader.bytes();\n          break;\n        case 6:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n        case 7:\n          message.signer = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    return {\n      portId: isSet(object.portId) ? String(object.portId) : \"\",\n      channelId: isSet(object.channelId) ? String(object.channelId) : \"\",\n      counterpartyChannelId: isSet(object.counterpartyChannelId) ? String(object.counterpartyChannelId) : \"\",\n      counterpartyVersion: isSet(object.counterpartyVersion) ? String(object.counterpartyVersion) : \"\",\n      proofTry: isSet(object.proofTry) ? bytesFromBase64(object.proofTry) : new Uint8Array(),\n      proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : undefined,\n      signer: isSet(object.signer) ? String(object.signer) : \"\"\n    };\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.channelId !== undefined && (obj.channelId = message.channelId);\n    message.counterpartyChannelId !== undefined && (obj.counterpartyChannelId = message.counterpartyChannelId);\n    message.counterpartyVersion !== undefined && (obj.counterpartyVersion = message.counterpartyVersion);\n    message.proofTry !== undefined && (obj.proofTry = base64FromBytes(message.proofTry !== undefined ? message.proofTry : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f;\n    var message = createBaseMsgChannelOpenAck();\n    message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : \"\";\n    message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : \"\";\n    message.counterpartyChannelId = (_c = object.counterpartyChannelId) !== null && _c !== void 0 ? _c : \"\";\n    message.counterpartyVersion = (_d = object.counterpartyVersion) !== null && _d !== void 0 ? _d : \"\";\n    message.proofTry = (_e = object.proofTry) !== null && _e !== void 0 ? _e : new Uint8Array();\n    message.proofHeight = object.proofHeight !== undefined && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : undefined;\n    message.signer = (_f = object.signer) !== null && _f !== void 0 ? _f : \"\";\n    return message;\n  }\n};\nfunction createBaseMsgChannelOpenAckResponse() {\n  return {};\n}\nexports.MsgChannelOpenAckResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgChannelOpenAckResponse();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(_) {\n    return {};\n  },\n  toJSON: function toJSON(_) {\n    var obj = {};\n    return obj;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = createBaseMsgChannelOpenAckResponse();\n    return message;\n  }\n};\nfunction createBaseMsgChannelOpenConfirm() {\n  return {\n    portId: \"\",\n    channelId: \"\",\n    proofAck: new Uint8Array(),\n    proofHeight: undefined,\n    signer: \"\"\n  };\n}\nexports.MsgChannelOpenConfirm = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n    if (message.channelId !== \"\") {\n      writer.uint32(18).string(message.channelId);\n    }\n    if (message.proofAck.length !== 0) {\n      writer.uint32(26).bytes(message.proofAck);\n    }\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.signer !== \"\") {\n      writer.uint32(42).string(message.signer);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgChannelOpenConfirm();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n        case 2:\n          message.channelId = reader.string();\n          break;\n        case 3:\n          message.proofAck = reader.bytes();\n          break;\n        case 4:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n        case 5:\n          message.signer = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    return {\n      portId: isSet(object.portId) ? String(object.portId) : \"\",\n      channelId: isSet(object.channelId) ? String(object.channelId) : \"\",\n      proofAck: isSet(object.proofAck) ? bytesFromBase64(object.proofAck) : new Uint8Array(),\n      proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : undefined,\n      signer: isSet(object.signer) ? String(object.signer) : \"\"\n    };\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.channelId !== undefined && (obj.channelId = message.channelId);\n    message.proofAck !== undefined && (obj.proofAck = base64FromBytes(message.proofAck !== undefined ? message.proofAck : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a, _b, _c, _d;\n    var message = createBaseMsgChannelOpenConfirm();\n    message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : \"\";\n    message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : \"\";\n    message.proofAck = (_c = object.proofAck) !== null && _c !== void 0 ? _c : new Uint8Array();\n    message.proofHeight = object.proofHeight !== undefined && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : undefined;\n    message.signer = (_d = object.signer) !== null && _d !== void 0 ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseMsgChannelOpenConfirmResponse() {\n  return {};\n}\nexports.MsgChannelOpenConfirmResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgChannelOpenConfirmResponse();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(_) {\n    return {};\n  },\n  toJSON: function toJSON(_) {\n    var obj = {};\n    return obj;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = createBaseMsgChannelOpenConfirmResponse();\n    return message;\n  }\n};\nfunction createBaseMsgChannelCloseInit() {\n  return {\n    portId: \"\",\n    channelId: \"\",\n    signer: \"\"\n  };\n}\nexports.MsgChannelCloseInit = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n    if (message.channelId !== \"\") {\n      writer.uint32(18).string(message.channelId);\n    }\n    if (message.signer !== \"\") {\n      writer.uint32(26).string(message.signer);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgChannelCloseInit();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n        case 2:\n          message.channelId = reader.string();\n          break;\n        case 3:\n          message.signer = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    return {\n      portId: isSet(object.portId) ? String(object.portId) : \"\",\n      channelId: isSet(object.channelId) ? String(object.channelId) : \"\",\n      signer: isSet(object.signer) ? String(object.signer) : \"\"\n    };\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.channelId !== undefined && (obj.channelId = message.channelId);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a, _b, _c;\n    var message = createBaseMsgChannelCloseInit();\n    message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : \"\";\n    message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : \"\";\n    message.signer = (_c = object.signer) !== null && _c !== void 0 ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseMsgChannelCloseInitResponse() {\n  return {};\n}\nexports.MsgChannelCloseInitResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgChannelCloseInitResponse();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(_) {\n    return {};\n  },\n  toJSON: function toJSON(_) {\n    var obj = {};\n    return obj;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = createBaseMsgChannelCloseInitResponse();\n    return message;\n  }\n};\nfunction createBaseMsgChannelCloseConfirm() {\n  return {\n    portId: \"\",\n    channelId: \"\",\n    proofInit: new Uint8Array(),\n    proofHeight: undefined,\n    signer: \"\"\n  };\n}\nexports.MsgChannelCloseConfirm = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n    if (message.channelId !== \"\") {\n      writer.uint32(18).string(message.channelId);\n    }\n    if (message.proofInit.length !== 0) {\n      writer.uint32(26).bytes(message.proofInit);\n    }\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.signer !== \"\") {\n      writer.uint32(42).string(message.signer);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgChannelCloseConfirm();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n        case 2:\n          message.channelId = reader.string();\n          break;\n        case 3:\n          message.proofInit = reader.bytes();\n          break;\n        case 4:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n        case 5:\n          message.signer = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    return {\n      portId: isSet(object.portId) ? String(object.portId) : \"\",\n      channelId: isSet(object.channelId) ? String(object.channelId) : \"\",\n      proofInit: isSet(object.proofInit) ? bytesFromBase64(object.proofInit) : new Uint8Array(),\n      proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : undefined,\n      signer: isSet(object.signer) ? String(object.signer) : \"\"\n    };\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.channelId !== undefined && (obj.channelId = message.channelId);\n    message.proofInit !== undefined && (obj.proofInit = base64FromBytes(message.proofInit !== undefined ? message.proofInit : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a, _b, _c, _d;\n    var message = createBaseMsgChannelCloseConfirm();\n    message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : \"\";\n    message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : \"\";\n    message.proofInit = (_c = object.proofInit) !== null && _c !== void 0 ? _c : new Uint8Array();\n    message.proofHeight = object.proofHeight !== undefined && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : undefined;\n    message.signer = (_d = object.signer) !== null && _d !== void 0 ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseMsgChannelCloseConfirmResponse() {\n  return {};\n}\nexports.MsgChannelCloseConfirmResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgChannelCloseConfirmResponse();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(_) {\n    return {};\n  },\n  toJSON: function toJSON(_) {\n    var obj = {};\n    return obj;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = createBaseMsgChannelCloseConfirmResponse();\n    return message;\n  }\n};\nfunction createBaseMsgRecvPacket() {\n  return {\n    packet: undefined,\n    proofCommitment: new Uint8Array(),\n    proofHeight: undefined,\n    signer: \"\"\n  };\n}\nexports.MsgRecvPacket = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.packet !== undefined) {\n      channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.proofCommitment.length !== 0) {\n      writer.uint32(18).bytes(message.proofCommitment);\n    }\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.signer !== \"\") {\n      writer.uint32(34).string(message.signer);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgRecvPacket();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.packet = channel_1.Packet.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.proofCommitment = reader.bytes();\n          break;\n        case 3:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.signer = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    return {\n      packet: isSet(object.packet) ? channel_1.Packet.fromJSON(object.packet) : undefined,\n      proofCommitment: isSet(object.proofCommitment) ? bytesFromBase64(object.proofCommitment) : new Uint8Array(),\n      proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : undefined,\n      signer: isSet(object.signer) ? String(object.signer) : \"\"\n    };\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);\n    message.proofCommitment !== undefined && (obj.proofCommitment = base64FromBytes(message.proofCommitment !== undefined ? message.proofCommitment : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a, _b;\n    var message = createBaseMsgRecvPacket();\n    message.packet = object.packet !== undefined && object.packet !== null ? channel_1.Packet.fromPartial(object.packet) : undefined;\n    message.proofCommitment = (_a = object.proofCommitment) !== null && _a !== void 0 ? _a : new Uint8Array();\n    message.proofHeight = object.proofHeight !== undefined && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : undefined;\n    message.signer = (_b = object.signer) !== null && _b !== void 0 ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseMsgRecvPacketResponse() {\n  return {\n    result: 0\n  };\n}\nexports.MsgRecvPacketResponse = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.result !== 0) {\n      writer.uint32(8).int32(message.result);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgRecvPacketResponse();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.result = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    return {\n      result: isSet(object.result) ? responseResultTypeFromJSON(object.result) : 0\n    };\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.result !== undefined && (obj.result = responseResultTypeToJSON(message.result));\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a;\n    var message = createBaseMsgRecvPacketResponse();\n    message.result = (_a = object.result) !== null && _a !== void 0 ? _a : 0;\n    return message;\n  }\n};\nfunction createBaseMsgTimeout() {\n  return {\n    packet: undefined,\n    proofUnreceived: new Uint8Array(),\n    proofHeight: undefined,\n    nextSequenceRecv: long_1.default.UZERO,\n    signer: \"\"\n  };\n}\nexports.MsgTimeout = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.packet !== undefined) {\n      channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.proofUnreceived.length !== 0) {\n      writer.uint32(18).bytes(message.proofUnreceived);\n    }\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();\n    }\n    if (!message.nextSequenceRecv.isZero()) {\n      writer.uint32(32).uint64(message.nextSequenceRecv);\n    }\n    if (message.signer !== \"\") {\n      writer.uint32(42).string(message.signer);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgTimeout();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.packet = channel_1.Packet.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.proofUnreceived = reader.bytes();\n          break;\n        case 3:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.nextSequenceRecv = reader.uint64();\n          break;\n        case 5:\n          message.signer = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    return {\n      packet: isSet(object.packet) ? channel_1.Packet.fromJSON(object.packet) : undefined,\n      proofUnreceived: isSet(object.proofUnreceived) ? bytesFromBase64(object.proofUnreceived) : new Uint8Array(),\n      proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : undefined,\n      nextSequenceRecv: isSet(object.nextSequenceRecv) ? long_1.default.fromValue(object.nextSequenceRecv) : long_1.default.UZERO,\n      signer: isSet(object.signer) ? String(object.signer) : \"\"\n    };\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);\n    message.proofUnreceived !== undefined && (obj.proofUnreceived = base64FromBytes(message.proofUnreceived !== undefined ? message.proofUnreceived : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.nextSequenceRecv !== undefined && (obj.nextSequenceRecv = (message.nextSequenceRecv || long_1.default.UZERO).toString());\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a, _b;\n    var message = createBaseMsgTimeout();\n    message.packet = object.packet !== undefined && object.packet !== null ? channel_1.Packet.fromPartial(object.packet) : undefined;\n    message.proofUnreceived = (_a = object.proofUnreceived) !== null && _a !== void 0 ? _a : new Uint8Array();\n    message.proofHeight = object.proofHeight !== undefined && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : undefined;\n    message.nextSequenceRecv = object.nextSequenceRecv !== undefined && object.nextSequenceRecv !== null ? long_1.default.fromValue(object.nextSequenceRecv) : long_1.default.UZERO;\n    message.signer = (_b = object.signer) !== null && _b !== void 0 ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseMsgTimeoutResponse() {\n  return {\n    result: 0\n  };\n}\nexports.MsgTimeoutResponse = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.result !== 0) {\n      writer.uint32(8).int32(message.result);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgTimeoutResponse();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.result = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    return {\n      result: isSet(object.result) ? responseResultTypeFromJSON(object.result) : 0\n    };\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.result !== undefined && (obj.result = responseResultTypeToJSON(message.result));\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a;\n    var message = createBaseMsgTimeoutResponse();\n    message.result = (_a = object.result) !== null && _a !== void 0 ? _a : 0;\n    return message;\n  }\n};\nfunction createBaseMsgTimeoutOnClose() {\n  return {\n    packet: undefined,\n    proofUnreceived: new Uint8Array(),\n    proofClose: new Uint8Array(),\n    proofHeight: undefined,\n    nextSequenceRecv: long_1.default.UZERO,\n    signer: \"\"\n  };\n}\nexports.MsgTimeoutOnClose = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.packet !== undefined) {\n      channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.proofUnreceived.length !== 0) {\n      writer.uint32(18).bytes(message.proofUnreceived);\n    }\n    if (message.proofClose.length !== 0) {\n      writer.uint32(26).bytes(message.proofClose);\n    }\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();\n    }\n    if (!message.nextSequenceRecv.isZero()) {\n      writer.uint32(40).uint64(message.nextSequenceRecv);\n    }\n    if (message.signer !== \"\") {\n      writer.uint32(50).string(message.signer);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgTimeoutOnClose();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.packet = channel_1.Packet.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.proofUnreceived = reader.bytes();\n          break;\n        case 3:\n          message.proofClose = reader.bytes();\n          break;\n        case 4:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n        case 5:\n          message.nextSequenceRecv = reader.uint64();\n          break;\n        case 6:\n          message.signer = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    return {\n      packet: isSet(object.packet) ? channel_1.Packet.fromJSON(object.packet) : undefined,\n      proofUnreceived: isSet(object.proofUnreceived) ? bytesFromBase64(object.proofUnreceived) : new Uint8Array(),\n      proofClose: isSet(object.proofClose) ? bytesFromBase64(object.proofClose) : new Uint8Array(),\n      proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : undefined,\n      nextSequenceRecv: isSet(object.nextSequenceRecv) ? long_1.default.fromValue(object.nextSequenceRecv) : long_1.default.UZERO,\n      signer: isSet(object.signer) ? String(object.signer) : \"\"\n    };\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);\n    message.proofUnreceived !== undefined && (obj.proofUnreceived = base64FromBytes(message.proofUnreceived !== undefined ? message.proofUnreceived : new Uint8Array()));\n    message.proofClose !== undefined && (obj.proofClose = base64FromBytes(message.proofClose !== undefined ? message.proofClose : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.nextSequenceRecv !== undefined && (obj.nextSequenceRecv = (message.nextSequenceRecv || long_1.default.UZERO).toString());\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a, _b, _c;\n    var message = createBaseMsgTimeoutOnClose();\n    message.packet = object.packet !== undefined && object.packet !== null ? channel_1.Packet.fromPartial(object.packet) : undefined;\n    message.proofUnreceived = (_a = object.proofUnreceived) !== null && _a !== void 0 ? _a : new Uint8Array();\n    message.proofClose = (_b = object.proofClose) !== null && _b !== void 0 ? _b : new Uint8Array();\n    message.proofHeight = object.proofHeight !== undefined && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : undefined;\n    message.nextSequenceRecv = object.nextSequenceRecv !== undefined && object.nextSequenceRecv !== null ? long_1.default.fromValue(object.nextSequenceRecv) : long_1.default.UZERO;\n    message.signer = (_c = object.signer) !== null && _c !== void 0 ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseMsgTimeoutOnCloseResponse() {\n  return {\n    result: 0\n  };\n}\nexports.MsgTimeoutOnCloseResponse = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.result !== 0) {\n      writer.uint32(8).int32(message.result);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgTimeoutOnCloseResponse();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.result = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    return {\n      result: isSet(object.result) ? responseResultTypeFromJSON(object.result) : 0\n    };\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.result !== undefined && (obj.result = responseResultTypeToJSON(message.result));\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a;\n    var message = createBaseMsgTimeoutOnCloseResponse();\n    message.result = (_a = object.result) !== null && _a !== void 0 ? _a : 0;\n    return message;\n  }\n};\nfunction createBaseMsgAcknowledgement() {\n  return {\n    packet: undefined,\n    acknowledgement: new Uint8Array(),\n    proofAcked: new Uint8Array(),\n    proofHeight: undefined,\n    signer: \"\"\n  };\n}\nexports.MsgAcknowledgement = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.packet !== undefined) {\n      channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.acknowledgement.length !== 0) {\n      writer.uint32(18).bytes(message.acknowledgement);\n    }\n    if (message.proofAcked.length !== 0) {\n      writer.uint32(26).bytes(message.proofAcked);\n    }\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.signer !== \"\") {\n      writer.uint32(42).string(message.signer);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgAcknowledgement();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.packet = channel_1.Packet.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.acknowledgement = reader.bytes();\n          break;\n        case 3:\n          message.proofAcked = reader.bytes();\n          break;\n        case 4:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n        case 5:\n          message.signer = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    return {\n      packet: isSet(object.packet) ? channel_1.Packet.fromJSON(object.packet) : undefined,\n      acknowledgement: isSet(object.acknowledgement) ? bytesFromBase64(object.acknowledgement) : new Uint8Array(),\n      proofAcked: isSet(object.proofAcked) ? bytesFromBase64(object.proofAcked) : new Uint8Array(),\n      proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : undefined,\n      signer: isSet(object.signer) ? String(object.signer) : \"\"\n    };\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);\n    message.acknowledgement !== undefined && (obj.acknowledgement = base64FromBytes(message.acknowledgement !== undefined ? message.acknowledgement : new Uint8Array()));\n    message.proofAcked !== undefined && (obj.proofAcked = base64FromBytes(message.proofAcked !== undefined ? message.proofAcked : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a, _b, _c;\n    var message = createBaseMsgAcknowledgement();\n    message.packet = object.packet !== undefined && object.packet !== null ? channel_1.Packet.fromPartial(object.packet) : undefined;\n    message.acknowledgement = (_a = object.acknowledgement) !== null && _a !== void 0 ? _a : new Uint8Array();\n    message.proofAcked = (_b = object.proofAcked) !== null && _b !== void 0 ? _b : new Uint8Array();\n    message.proofHeight = object.proofHeight !== undefined && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : undefined;\n    message.signer = (_c = object.signer) !== null && _c !== void 0 ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseMsgAcknowledgementResponse() {\n  return {\n    result: 0\n  };\n}\nexports.MsgAcknowledgementResponse = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.result !== 0) {\n      writer.uint32(8).int32(message.result);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgAcknowledgementResponse();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.result = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    return {\n      result: isSet(object.result) ? responseResultTypeFromJSON(object.result) : 0\n    };\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.result !== undefined && (obj.result = responseResultTypeToJSON(message.result));\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a;\n    var message = createBaseMsgAcknowledgementResponse();\n    message.result = (_a = object.result) !== null && _a !== void 0 ? _a : 0;\n    return message;\n  }\n};\nvar MsgClientImpl = /*#__PURE__*/function () {\n  function MsgClientImpl(rpc) {\n    _classCallCheck(this, MsgClientImpl);\n    this.rpc = rpc;\n    this.ChannelOpenInit = this.ChannelOpenInit.bind(this);\n    this.ChannelOpenTry = this.ChannelOpenTry.bind(this);\n    this.ChannelOpenAck = this.ChannelOpenAck.bind(this);\n    this.ChannelOpenConfirm = this.ChannelOpenConfirm.bind(this);\n    this.ChannelCloseInit = this.ChannelCloseInit.bind(this);\n    this.ChannelCloseConfirm = this.ChannelCloseConfirm.bind(this);\n    this.RecvPacket = this.RecvPacket.bind(this);\n    this.Timeout = this.Timeout.bind(this);\n    this.TimeoutOnClose = this.TimeoutOnClose.bind(this);\n    this.Acknowledgement = this.Acknowledgement.bind(this);\n  }\n  _createClass(MsgClientImpl, [{\n    key: \"ChannelOpenInit\",\n    value: function ChannelOpenInit(request) {\n      var data = exports.MsgChannelOpenInit.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelOpenInit\", data);\n      return promise.then(function (data) {\n        return exports.MsgChannelOpenInitResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"ChannelOpenTry\",\n    value: function ChannelOpenTry(request) {\n      var data = exports.MsgChannelOpenTry.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelOpenTry\", data);\n      return promise.then(function (data) {\n        return exports.MsgChannelOpenTryResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"ChannelOpenAck\",\n    value: function ChannelOpenAck(request) {\n      var data = exports.MsgChannelOpenAck.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelOpenAck\", data);\n      return promise.then(function (data) {\n        return exports.MsgChannelOpenAckResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"ChannelOpenConfirm\",\n    value: function ChannelOpenConfirm(request) {\n      var data = exports.MsgChannelOpenConfirm.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelOpenConfirm\", data);\n      return promise.then(function (data) {\n        return exports.MsgChannelOpenConfirmResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"ChannelCloseInit\",\n    value: function ChannelCloseInit(request) {\n      var data = exports.MsgChannelCloseInit.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelCloseInit\", data);\n      return promise.then(function (data) {\n        return exports.MsgChannelCloseInitResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"ChannelCloseConfirm\",\n    value: function ChannelCloseConfirm(request) {\n      var data = exports.MsgChannelCloseConfirm.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelCloseConfirm\", data);\n      return promise.then(function (data) {\n        return exports.MsgChannelCloseConfirmResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"RecvPacket\",\n    value: function RecvPacket(request) {\n      var data = exports.MsgRecvPacket.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"RecvPacket\", data);\n      return promise.then(function (data) {\n        return exports.MsgRecvPacketResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"Timeout\",\n    value: function Timeout(request) {\n      var data = exports.MsgTimeout.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"Timeout\", data);\n      return promise.then(function (data) {\n        return exports.MsgTimeoutResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"TimeoutOnClose\",\n    value: function TimeoutOnClose(request) {\n      var data = exports.MsgTimeoutOnClose.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"TimeoutOnClose\", data);\n      return promise.then(function (data) {\n        return exports.MsgTimeoutOnCloseResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"Acknowledgement\",\n    value: function Acknowledgement(request) {\n      var data = exports.MsgAcknowledgement.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"Acknowledgement\", data);\n      return promise.then(function (data) {\n        return exports.MsgAcknowledgementResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }]);\n  return MsgClientImpl;\n}();\nexports.MsgClientImpl = MsgClientImpl;\nvar globalThis = function () {\n  if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  }\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  throw \"Unable to locate global object\";\n}();\nfunction bytesFromBase64(b64) {\n  if (globalThis.Buffer) {\n    return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n  } else {\n    var bin = globalThis.atob(b64);\n    var arr = new Uint8Array(bin.length);\n    for (var i = 0; i < bin.length; ++i) {\n      arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n  }\n}\nfunction base64FromBytes(arr) {\n  if (globalThis.Buffer) {\n    return globalThis.Buffer.from(arr).toString(\"base64\");\n  } else {\n    var bin = [];\n    arr.forEach(function (byte) {\n      bin.push(String.fromCharCode(byte));\n    });\n    return globalThis.btoa(bin.join(\"\"));\n  }\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n  minimal_1.default.util.Long = long_1.default;\n  minimal_1.default.configure();\n}\nfunction isSet(value) {\n  return value !== null && value !== undefined;\n}","map":null,"metadata":{},"sourceType":"script"}