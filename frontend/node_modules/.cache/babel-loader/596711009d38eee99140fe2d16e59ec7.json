{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/linanqi/Hackathon/GameRoom/frontend/node_modules/@babel/runtime/helpers/toConsumableArray\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.doHash = exports.applyInner = exports.applyLeaf = void 0;\nvar ripemd160_1 = require(\"@noble/hashes/ripemd160\");\nvar sha256_1 = require(\"@noble/hashes/sha256\");\nvar sha512_1 = require(\"@noble/hashes/sha512\");\nvar codecimpl_1 = require(\"./generated/codecimpl\");\nfunction applyLeaf(leaf, key, value) {\n  if (key.length === 0) {\n    throw new Error(\"Missing key\");\n  }\n  if (value.length === 0) {\n    throw new Error(\"Missing value\");\n  }\n  var pkey = prepareLeafData(ensureHash(leaf.prehashKey), ensureLength(leaf.length), key);\n  var pvalue = prepareLeafData(ensureHash(leaf.prehashValue), ensureLength(leaf.length), value);\n  var data = new Uint8Array([].concat(_toConsumableArray(ensureBytes(leaf.prefix)), _toConsumableArray(pkey), _toConsumableArray(pvalue)));\n  return doHash(ensureHash(leaf.hash), data);\n}\nexports.applyLeaf = applyLeaf;\nfunction applyInner(inner, child) {\n  if (child.length === 0) {\n    throw new Error(\"Inner op needs child value\");\n  }\n  var preimage = new Uint8Array([].concat(_toConsumableArray(ensureBytes(inner.prefix)), _toConsumableArray(child), _toConsumableArray(ensureBytes(inner.suffix))));\n  return doHash(ensureHash(inner.hash), preimage);\n}\nexports.applyInner = applyInner;\nfunction ensure(maybe, value) {\n  return maybe === undefined || maybe === null ? value : maybe;\n}\nvar ensureHash = function ensureHash(h) {\n  return ensure(h, codecimpl_1.ics23.HashOp.NO_HASH);\n};\nvar ensureLength = function ensureLength(l) {\n  return ensure(l, codecimpl_1.ics23.LengthOp.NO_PREFIX);\n};\nvar ensureBytes = function ensureBytes(b) {\n  return ensure(b, new Uint8Array([]));\n};\nfunction prepareLeafData(hashOp, lengthOp, data) {\n  var h = doHashOrNoop(hashOp, data);\n  return doLengthOp(lengthOp, h);\n}\n// doHashOrNoop will return the preimage untouched if hashOp == NONE,\n// otherwise, perform doHash\nfunction doHashOrNoop(hashOp, preimage) {\n  if (hashOp === codecimpl_1.ics23.HashOp.NO_HASH) {\n    return preimage;\n  }\n  return doHash(hashOp, preimage);\n}\n// doHash will preform the specified hash on the preimage.\n// if hashOp == NONE, it will return an error (use doHashOrNoop if you want different behavior)\nfunction doHash(hashOp, preimage) {\n  switch (hashOp) {\n    case codecimpl_1.ics23.HashOp.SHA256:\n      return (0, sha256_1.sha256)(preimage);\n    case codecimpl_1.ics23.HashOp.SHA512:\n      return (0, sha512_1.sha512)(preimage);\n    case codecimpl_1.ics23.HashOp.RIPEMD160:\n      return (0, ripemd160_1.ripemd160)(preimage);\n    case codecimpl_1.ics23.HashOp.BITCOIN:\n      return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(preimage));\n    case codecimpl_1.ics23.HashOp.SHA512_256:\n      return (0, sha512_1.sha512_256)(preimage);\n  }\n  throw new Error(\"Unsupported hashop: \".concat(hashOp));\n}\nexports.doHash = doHash;\n// doLengthOp will calculate the proper prefix and return it prepended\n//   doLengthOp(op, data) -> length(data) || data\nfunction doLengthOp(lengthOp, data) {\n  switch (lengthOp) {\n    case codecimpl_1.ics23.LengthOp.NO_PREFIX:\n      return data;\n    case codecimpl_1.ics23.LengthOp.VAR_PROTO:\n      return new Uint8Array([].concat(_toConsumableArray(encodeVarintProto(data.length)), _toConsumableArray(data)));\n    case codecimpl_1.ics23.LengthOp.REQUIRE_32_BYTES:\n      if (data.length !== 32) {\n        throw new Error(\"Length is \".concat(data.length, \", not 32 bytes\"));\n      }\n      return data;\n    case codecimpl_1.ics23.LengthOp.REQUIRE_64_BYTES:\n      if (data.length !== 64) {\n        throw new Error(\"Length is \".concat(data.length, \", not 64 bytes\"));\n      }\n      return data;\n    case codecimpl_1.ics23.LengthOp.FIXED32_LITTLE:\n      return new Uint8Array([].concat(_toConsumableArray(encodeFixed32Le(data.length)), _toConsumableArray(data)));\n    // TODO\n    // case LengthOp_VAR_RLP:\n    // case LengthOp_FIXED32_BIG:\n    // case LengthOp_FIXED64_BIG:\n    // case LengthOp_FIXED64_LITTLE:\n  }\n\n  throw new Error(\"Unsupported lengthop: \".concat(lengthOp));\n}\nfunction encodeVarintProto(n) {\n  var enc = [];\n  var l = n;\n  while (l >= 128) {\n    var b = l % 128 + 128;\n    enc = [].concat(_toConsumableArray(enc), [b]);\n    l = l / 128;\n  }\n  enc = [].concat(_toConsumableArray(enc), [l]);\n  return new Uint8Array(enc);\n}\nfunction encodeFixed32Le(n) {\n  var enc = new Uint8Array(4);\n  var l = n;\n  for (var i = enc.length; i > 0; i--) {\n    enc[Math.abs(i - enc.length)] = l % 256;\n    l = Math.floor(l / 256);\n  }\n  return enc;\n}","map":null,"metadata":{},"sourceType":"script"}