{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hashBlock = exports.hashTx = void 0;\nvar crypto_1 = require(\"@cosmjs/crypto\");\nvar encodings_1 = require(\"./encodings\");\n// hash is sha256\n// https://github.com/tendermint/tendermint/blob/master/UPGRADING.md#v0260\nfunction hashTx(tx) {\n  return (0, crypto_1.sha256)(tx);\n}\nexports.hashTx = hashTx;\nfunction getSplitPoint(n) {\n  if (n < 1) throw new Error(\"Cannot split an empty tree\");\n  var largestPowerOf2 = Math.pow(2, Math.floor(Math.log2(n)));\n  return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;\n}\nfunction hashLeaf(leaf) {\n  var hash = new crypto_1.Sha256(Uint8Array.from([0]));\n  hash.update(leaf);\n  return hash.digest();\n}\nfunction hashInner(left, right) {\n  var hash = new crypto_1.Sha256(Uint8Array.from([1]));\n  hash.update(left);\n  hash.update(right);\n  return hash.digest();\n}\n// See https://github.com/tendermint/tendermint/blob/v0.31.8/docs/spec/blockchain/encoding.md#merkleroot\n// Note: the hashes input may not actually be hashes, especially before a recursive call\nfunction hashTree(hashes) {\n  switch (hashes.length) {\n    case 0:\n      throw new Error(\"Cannot hash empty tree\");\n    case 1:\n      return hashLeaf(hashes[0]);\n    default:\n      {\n        var slicePoint = getSplitPoint(hashes.length);\n        var left = hashTree(hashes.slice(0, slicePoint));\n        var right = hashTree(hashes.slice(slicePoint));\n        return hashInner(left, right);\n      }\n  }\n}\nfunction hashBlock(header) {\n  if (!header.lastBlockId) {\n    throw new Error(\"Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.\");\n  }\n  var encodedFields = [(0, encodings_1.encodeVersion)(header.version), (0, encodings_1.encodeString)(header.chainId), (0, encodings_1.encodeUvarint)(header.height), (0, encodings_1.encodeTime)(header.time), (0, encodings_1.encodeBlockId)(header.lastBlockId), (0, encodings_1.encodeBytes)(header.lastCommitHash), (0, encodings_1.encodeBytes)(header.dataHash), (0, encodings_1.encodeBytes)(header.validatorsHash), (0, encodings_1.encodeBytes)(header.nextValidatorsHash), (0, encodings_1.encodeBytes)(header.consensusHash), (0, encodings_1.encodeBytes)(header.appHash), (0, encodings_1.encodeBytes)(header.lastResultsHash), (0, encodings_1.encodeBytes)(header.evidenceHash), (0, encodings_1.encodeBytes)(header.proposerAddress)];\n  return hashTree(encodedFields);\n}\nexports.hashBlock = hashBlock;","map":null,"metadata":{},"sourceType":"script"}