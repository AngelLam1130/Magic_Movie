{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/linanqi/Hackathon/GameRoom/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/linanqi/Hackathon/GameRoom/frontend/node_modules/@babel/runtime/helpers/createClass\");\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MsgClientImpl = exports.MsgUndelegateResponse = exports.MsgUndelegate = exports.MsgBeginRedelegateResponse = exports.MsgBeginRedelegate = exports.MsgDelegateResponse = exports.MsgDelegate = exports.MsgEditValidatorResponse = exports.MsgEditValidator = exports.MsgCreateValidatorResponse = exports.MsgCreateValidator = exports.protobufPackage = void 0;\n/* eslint-disable */\nvar long_1 = __importDefault(require(\"long\"));\nvar minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nvar any_1 = require(\"../../../google/protobuf/any\");\nvar timestamp_1 = require(\"../../../google/protobuf/timestamp\");\nvar coin_1 = require(\"../../base/v1beta1/coin\");\nvar staking_1 = require(\"./staking\");\nexports.protobufPackage = \"cosmos.staking.v1beta1\";\nfunction createBaseMsgCreateValidator() {\n  return {\n    description: undefined,\n    commission: undefined,\n    minSelfDelegation: \"\",\n    delegatorAddress: \"\",\n    validatorAddress: \"\",\n    pubkey: undefined,\n    value: undefined\n  };\n}\nexports.MsgCreateValidator = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.description !== undefined) {\n      staking_1.Description.encode(message.description, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.commission !== undefined) {\n      staking_1.CommissionRates.encode(message.commission, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.minSelfDelegation !== \"\") {\n      writer.uint32(26).string(message.minSelfDelegation);\n    }\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(34).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(42).string(message.validatorAddress);\n    }\n    if (message.pubkey !== undefined) {\n      any_1.Any.encode(message.pubkey, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.value !== undefined) {\n      coin_1.Coin.encode(message.value, writer.uint32(58).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgCreateValidator();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.description = staking_1.Description.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.commission = staking_1.CommissionRates.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.minSelfDelegation = reader.string();\n          break;\n        case 4:\n          message.delegatorAddress = reader.string();\n          break;\n        case 5:\n          message.validatorAddress = reader.string();\n          break;\n        case 6:\n          message.pubkey = any_1.Any.decode(reader, reader.uint32());\n          break;\n        case 7:\n          message.value = coin_1.Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    return {\n      description: isSet(object.description) ? staking_1.Description.fromJSON(object.description) : undefined,\n      commission: isSet(object.commission) ? staking_1.CommissionRates.fromJSON(object.commission) : undefined,\n      minSelfDelegation: isSet(object.minSelfDelegation) ? String(object.minSelfDelegation) : \"\",\n      delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : \"\",\n      validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : \"\",\n      pubkey: isSet(object.pubkey) ? any_1.Any.fromJSON(object.pubkey) : undefined,\n      value: isSet(object.value) ? coin_1.Coin.fromJSON(object.value) : undefined\n    };\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.description !== undefined && (obj.description = message.description ? staking_1.Description.toJSON(message.description) : undefined);\n    message.commission !== undefined && (obj.commission = message.commission ? staking_1.CommissionRates.toJSON(message.commission) : undefined);\n    message.minSelfDelegation !== undefined && (obj.minSelfDelegation = message.minSelfDelegation);\n    message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);\n    message.pubkey !== undefined && (obj.pubkey = message.pubkey ? any_1.Any.toJSON(message.pubkey) : undefined);\n    message.value !== undefined && (obj.value = message.value ? coin_1.Coin.toJSON(message.value) : undefined);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a, _b, _c;\n    var message = createBaseMsgCreateValidator();\n    message.description = object.description !== undefined && object.description !== null ? staking_1.Description.fromPartial(object.description) : undefined;\n    message.commission = object.commission !== undefined && object.commission !== null ? staking_1.CommissionRates.fromPartial(object.commission) : undefined;\n    message.minSelfDelegation = (_a = object.minSelfDelegation) !== null && _a !== void 0 ? _a : \"\";\n    message.delegatorAddress = (_b = object.delegatorAddress) !== null && _b !== void 0 ? _b : \"\";\n    message.validatorAddress = (_c = object.validatorAddress) !== null && _c !== void 0 ? _c : \"\";\n    message.pubkey = object.pubkey !== undefined && object.pubkey !== null ? any_1.Any.fromPartial(object.pubkey) : undefined;\n    message.value = object.value !== undefined && object.value !== null ? coin_1.Coin.fromPartial(object.value) : undefined;\n    return message;\n  }\n};\nfunction createBaseMsgCreateValidatorResponse() {\n  return {};\n}\nexports.MsgCreateValidatorResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgCreateValidatorResponse();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(_) {\n    return {};\n  },\n  toJSON: function toJSON(_) {\n    var obj = {};\n    return obj;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = createBaseMsgCreateValidatorResponse();\n    return message;\n  }\n};\nfunction createBaseMsgEditValidator() {\n  return {\n    description: undefined,\n    validatorAddress: \"\",\n    commissionRate: \"\",\n    minSelfDelegation: \"\"\n  };\n}\nexports.MsgEditValidator = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.description !== undefined) {\n      staking_1.Description.encode(message.description, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    if (message.commissionRate !== \"\") {\n      writer.uint32(26).string(message.commissionRate);\n    }\n    if (message.minSelfDelegation !== \"\") {\n      writer.uint32(34).string(message.minSelfDelegation);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgEditValidator();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.description = staking_1.Description.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        case 3:\n          message.commissionRate = reader.string();\n          break;\n        case 4:\n          message.minSelfDelegation = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    return {\n      description: isSet(object.description) ? staking_1.Description.fromJSON(object.description) : undefined,\n      validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : \"\",\n      commissionRate: isSet(object.commissionRate) ? String(object.commissionRate) : \"\",\n      minSelfDelegation: isSet(object.minSelfDelegation) ? String(object.minSelfDelegation) : \"\"\n    };\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.description !== undefined && (obj.description = message.description ? staking_1.Description.toJSON(message.description) : undefined);\n    message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);\n    message.commissionRate !== undefined && (obj.commissionRate = message.commissionRate);\n    message.minSelfDelegation !== undefined && (obj.minSelfDelegation = message.minSelfDelegation);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a, _b, _c;\n    var message = createBaseMsgEditValidator();\n    message.description = object.description !== undefined && object.description !== null ? staking_1.Description.fromPartial(object.description) : undefined;\n    message.validatorAddress = (_a = object.validatorAddress) !== null && _a !== void 0 ? _a : \"\";\n    message.commissionRate = (_b = object.commissionRate) !== null && _b !== void 0 ? _b : \"\";\n    message.minSelfDelegation = (_c = object.minSelfDelegation) !== null && _c !== void 0 ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseMsgEditValidatorResponse() {\n  return {};\n}\nexports.MsgEditValidatorResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgEditValidatorResponse();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(_) {\n    return {};\n  },\n  toJSON: function toJSON(_) {\n    var obj = {};\n    return obj;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = createBaseMsgEditValidatorResponse();\n    return message;\n  }\n};\nfunction createBaseMsgDelegate() {\n  return {\n    delegatorAddress: \"\",\n    validatorAddress: \"\",\n    amount: undefined\n  };\n}\nexports.MsgDelegate = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    if (message.amount !== undefined) {\n      coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgDelegate();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        case 3:\n          message.amount = coin_1.Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : \"\",\n      validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : \"\",\n      amount: isSet(object.amount) ? coin_1.Coin.fromJSON(object.amount) : undefined\n    };\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);\n    message.amount !== undefined && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : undefined);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a, _b;\n    var message = createBaseMsgDelegate();\n    message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : \"\";\n    message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : \"\";\n    message.amount = object.amount !== undefined && object.amount !== null ? coin_1.Coin.fromPartial(object.amount) : undefined;\n    return message;\n  }\n};\nfunction createBaseMsgDelegateResponse() {\n  return {};\n}\nexports.MsgDelegateResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgDelegateResponse();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(_) {\n    return {};\n  },\n  toJSON: function toJSON(_) {\n    var obj = {};\n    return obj;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = createBaseMsgDelegateResponse();\n    return message;\n  }\n};\nfunction createBaseMsgBeginRedelegate() {\n  return {\n    delegatorAddress: \"\",\n    validatorSrcAddress: \"\",\n    validatorDstAddress: \"\",\n    amount: undefined\n  };\n}\nexports.MsgBeginRedelegate = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorSrcAddress !== \"\") {\n      writer.uint32(18).string(message.validatorSrcAddress);\n    }\n    if (message.validatorDstAddress !== \"\") {\n      writer.uint32(26).string(message.validatorDstAddress);\n    }\n    if (message.amount !== undefined) {\n      coin_1.Coin.encode(message.amount, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgBeginRedelegate();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorSrcAddress = reader.string();\n          break;\n        case 3:\n          message.validatorDstAddress = reader.string();\n          break;\n        case 4:\n          message.amount = coin_1.Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : \"\",\n      validatorSrcAddress: isSet(object.validatorSrcAddress) ? String(object.validatorSrcAddress) : \"\",\n      validatorDstAddress: isSet(object.validatorDstAddress) ? String(object.validatorDstAddress) : \"\",\n      amount: isSet(object.amount) ? coin_1.Coin.fromJSON(object.amount) : undefined\n    };\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorSrcAddress !== undefined && (obj.validatorSrcAddress = message.validatorSrcAddress);\n    message.validatorDstAddress !== undefined && (obj.validatorDstAddress = message.validatorDstAddress);\n    message.amount !== undefined && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : undefined);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a, _b, _c;\n    var message = createBaseMsgBeginRedelegate();\n    message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : \"\";\n    message.validatorSrcAddress = (_b = object.validatorSrcAddress) !== null && _b !== void 0 ? _b : \"\";\n    message.validatorDstAddress = (_c = object.validatorDstAddress) !== null && _c !== void 0 ? _c : \"\";\n    message.amount = object.amount !== undefined && object.amount !== null ? coin_1.Coin.fromPartial(object.amount) : undefined;\n    return message;\n  }\n};\nfunction createBaseMsgBeginRedelegateResponse() {\n  return {\n    completionTime: undefined\n  };\n}\nexports.MsgBeginRedelegateResponse = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.completionTime !== undefined) {\n      timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgBeginRedelegateResponse();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    return {\n      completionTime: isSet(object.completionTime) ? fromJsonTimestamp(object.completionTime) : undefined\n    };\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.completionTime !== undefined && (obj.completionTime = fromTimestamp(message.completionTime).toISOString());\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = createBaseMsgBeginRedelegateResponse();\n    message.completionTime = object.completionTime !== undefined && object.completionTime !== null ? timestamp_1.Timestamp.fromPartial(object.completionTime) : undefined;\n    return message;\n  }\n};\nfunction createBaseMsgUndelegate() {\n  return {\n    delegatorAddress: \"\",\n    validatorAddress: \"\",\n    amount: undefined\n  };\n}\nexports.MsgUndelegate = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    if (message.amount !== undefined) {\n      coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgUndelegate();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        case 3:\n          message.amount = coin_1.Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : \"\",\n      validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : \"\",\n      amount: isSet(object.amount) ? coin_1.Coin.fromJSON(object.amount) : undefined\n    };\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);\n    message.amount !== undefined && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : undefined);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a, _b;\n    var message = createBaseMsgUndelegate();\n    message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : \"\";\n    message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : \"\";\n    message.amount = object.amount !== undefined && object.amount !== null ? coin_1.Coin.fromPartial(object.amount) : undefined;\n    return message;\n  }\n};\nfunction createBaseMsgUndelegateResponse() {\n  return {\n    completionTime: undefined\n  };\n}\nexports.MsgUndelegateResponse = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.completionTime !== undefined) {\n      timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgUndelegateResponse();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    return {\n      completionTime: isSet(object.completionTime) ? fromJsonTimestamp(object.completionTime) : undefined\n    };\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.completionTime !== undefined && (obj.completionTime = fromTimestamp(message.completionTime).toISOString());\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = createBaseMsgUndelegateResponse();\n    message.completionTime = object.completionTime !== undefined && object.completionTime !== null ? timestamp_1.Timestamp.fromPartial(object.completionTime) : undefined;\n    return message;\n  }\n};\nvar MsgClientImpl = /*#__PURE__*/function () {\n  function MsgClientImpl(rpc) {\n    _classCallCheck(this, MsgClientImpl);\n    this.rpc = rpc;\n    this.CreateValidator = this.CreateValidator.bind(this);\n    this.EditValidator = this.EditValidator.bind(this);\n    this.Delegate = this.Delegate.bind(this);\n    this.BeginRedelegate = this.BeginRedelegate.bind(this);\n    this.Undelegate = this.Undelegate.bind(this);\n  }\n  _createClass(MsgClientImpl, [{\n    key: \"CreateValidator\",\n    value: function CreateValidator(request) {\n      var data = exports.MsgCreateValidator.encode(request).finish();\n      var promise = this.rpc.request(\"cosmos.staking.v1beta1.Msg\", \"CreateValidator\", data);\n      return promise.then(function (data) {\n        return exports.MsgCreateValidatorResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"EditValidator\",\n    value: function EditValidator(request) {\n      var data = exports.MsgEditValidator.encode(request).finish();\n      var promise = this.rpc.request(\"cosmos.staking.v1beta1.Msg\", \"EditValidator\", data);\n      return promise.then(function (data) {\n        return exports.MsgEditValidatorResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"Delegate\",\n    value: function Delegate(request) {\n      var data = exports.MsgDelegate.encode(request).finish();\n      var promise = this.rpc.request(\"cosmos.staking.v1beta1.Msg\", \"Delegate\", data);\n      return promise.then(function (data) {\n        return exports.MsgDelegateResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"BeginRedelegate\",\n    value: function BeginRedelegate(request) {\n      var data = exports.MsgBeginRedelegate.encode(request).finish();\n      var promise = this.rpc.request(\"cosmos.staking.v1beta1.Msg\", \"BeginRedelegate\", data);\n      return promise.then(function (data) {\n        return exports.MsgBeginRedelegateResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"Undelegate\",\n    value: function Undelegate(request) {\n      var data = exports.MsgUndelegate.encode(request).finish();\n      var promise = this.rpc.request(\"cosmos.staking.v1beta1.Msg\", \"Undelegate\", data);\n      return promise.then(function (data) {\n        return exports.MsgUndelegateResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }]);\n  return MsgClientImpl;\n}();\nexports.MsgClientImpl = MsgClientImpl;\nfunction toTimestamp(date) {\n  var seconds = numberToLong(date.getTime() / 1000);\n  var nanos = date.getTime() % 1000 * 1000000;\n  return {\n    seconds: seconds,\n    nanos: nanos\n  };\n}\nfunction fromTimestamp(t) {\n  var millis = t.seconds.toNumber() * 1000;\n  millis += t.nanos / 1000000;\n  return new Date(millis);\n}\nfunction fromJsonTimestamp(o) {\n  if (o instanceof Date) {\n    return toTimestamp(o);\n  } else if (typeof o === \"string\") {\n    return toTimestamp(new Date(o));\n  } else {\n    return timestamp_1.Timestamp.fromJSON(o);\n  }\n}\nfunction numberToLong(number) {\n  return long_1.default.fromNumber(number);\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n  minimal_1.default.util.Long = long_1.default;\n  minimal_1.default.configure();\n}\nfunction isSet(value) {\n  return value !== null && value !== undefined;\n}","map":null,"metadata":{},"sourceType":"script"}