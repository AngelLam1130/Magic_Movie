{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/linanqi/Hackathon/GameRoom/frontend/node_modules/@babel/runtime/helpers/slicedToArray\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.batchVerifyNonMembership = exports.batchVerifyMembership = exports.verifyNonMembership = exports.verifyMembership = void 0;\nvar compress_1 = require(\"./compress\");\nvar proofs_1 = require(\"./proofs\");\nvar specs_1 = require(\"./specs\");\n/*\nThis implements the client side functions as specified in\nhttps://github.com/cosmos/ics/tree/master/spec/ics-023-vector-commitments\n\nIn particular:\n\n  // Assumes ExistenceProof\n  type verifyMembership = (root: CommitmentRoot, proof: CommitmentProof, key: Key, value: Value) => boolean\n\n  // Assumes NonExistenceProof\n  type verifyNonMembership = (root: CommitmentRoot, proof: CommitmentProof, key: Key) => boolean\n\n  // Assumes BatchProof - required ExistenceProofs may be a subset of all items proven\n  type batchVerifyMembership = (root: CommitmentRoot, proof: CommitmentProof, items: Map<Key, Value>) => boolean\n\n  // Assumes BatchProof - required NonExistenceProofs may be a subset of all items proven\n  type batchVerifyNonMembership = (root: CommitmentRoot, proof: CommitmentProof, keys: Set<Key>) => boolean\n\nWe make an adjustment to accept a Spec to ensure the provided proof is in the format of the expected merkle store.\nThis can avoid an range of attacks on fake preimages, as we need to be careful on how to map key, value -> leaf\nand determine neighbors\n*/\n/**\n * verifyMembership ensures proof is (contains) a valid existence proof for the given\n */\nfunction verifyMembership(proof, spec, root, key, value) {\n  var norm = (0, compress_1.decompress)(proof);\n  var exist = getExistForKey(norm, key);\n  if (!exist) {\n    return false;\n  }\n  try {\n    (0, proofs_1.verifyExistence)(exist, spec, root, key, value);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\nexports.verifyMembership = verifyMembership;\n/**\n * verifyNonMembership ensures proof is (contains) a valid non-existence proof for the given key\n */\nfunction verifyNonMembership(proof, spec, root, key) {\n  var norm = (0, compress_1.decompress)(proof);\n  var nonexist = getNonExistForKey(norm, key);\n  if (!nonexist) {\n    return false;\n  }\n  try {\n    (0, proofs_1.verifyNonExistence)(nonexist, spec, root, key);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\nexports.verifyNonMembership = verifyNonMembership;\n/**\n * batchVerifyMembership ensures proof is (contains) a valid existence proof for the given\n */\nfunction batchVerifyMembership(proof, spec, root, items) {\n  var norm = (0, compress_1.decompress)(proof);\n  var _iterator = _createForOfIteratorHelper(items.entries()),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n        key = _step$value[0],\n        value = _step$value[1];\n      if (!verifyMembership(norm, spec, root, key, value)) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return true;\n}\nexports.batchVerifyMembership = batchVerifyMembership;\n/**\n * batchVerifyNonMembership ensures proof is (contains) a valid existence proof for the given\n */\nfunction batchVerifyNonMembership(proof, spec, root, keys) {\n  var norm = (0, compress_1.decompress)(proof);\n  var _iterator2 = _createForOfIteratorHelper(keys),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var key = _step2.value;\n      if (!verifyNonMembership(norm, spec, root, key)) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return true;\n}\nexports.batchVerifyNonMembership = batchVerifyNonMembership;\nfunction getExistForKey(proof, key) {\n  var match = function match(p) {\n    return !!p && (0, specs_1.bytesEqual)(key, p.key);\n  };\n  if (match(proof.exist)) {\n    return proof.exist;\n  } else if (proof.batch) {\n    return proof.batch.entries.map(function (x) {\n      return x.exist || null;\n    }).find(match);\n  }\n  return undefined;\n}\nfunction getNonExistForKey(proof, key) {\n  var match = function match(p) {\n    return !!p && (!p.left || (0, specs_1.bytesBefore)(p.left.key, key)) && (!p.right || (0, specs_1.bytesBefore)(key, p.right.key));\n  };\n  if (match(proof.nonexist)) {\n    return proof.nonexist;\n  } else if (proof.batch) {\n    return proof.batch.entries.map(function (x) {\n      return x.nonexist || null;\n    }).find(match);\n  }\n  return undefined;\n}","map":null,"metadata":{},"sourceType":"script"}