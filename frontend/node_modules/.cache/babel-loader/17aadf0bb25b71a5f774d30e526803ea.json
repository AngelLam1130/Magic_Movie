{"ast":null,"code":"'use strict';\n\nvar _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault');\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.verifyArbitrary = void 0;\nvar _regenerator = _interopRequireDefault(require('@babel/runtime/regenerator'));\nvar _asyncToGenerator2 = _interopRequireDefault(require('@babel/runtime/helpers/asyncToGenerator'));\nvar _amino = require('@cosmjs/amino');\nvar _encoding = require('@cosmjs/encoding');\nvar _bech = require('./bech32');\nvar _address = require('./address');\nvar _hash = require('./hash');\nfunction checkAndValidateADR36AminoSignDoc(signDoc) {\n  var hasOnlyMsgSignData = function () {\n    if (signDoc && signDoc.msgs && Array.isArray(signDoc.msgs) && signDoc.msgs.length === 1) {\n      var _msg = signDoc.msgs[0];\n      return _msg.type === 'sign/MsgSignData';\n    } else {\n      return false;\n    }\n  }();\n  if (!hasOnlyMsgSignData) {\n    return false;\n  }\n  if (signDoc.chain_id !== '') {\n    throw new Error('Chain id should be empty string for ADR-36 signing');\n  }\n  if (signDoc.memo !== '') {\n    throw new Error('Memo should be empty string for ADR-36 signing');\n  }\n  if (signDoc.account_number !== '0') {\n    throw new Error('Account number should be \"0\" for ADR-36 signing');\n  }\n  if (signDoc.sequence !== '0') {\n    throw new Error('Sequence should be \"0\" for ADR-36 signing');\n  }\n  if (signDoc.fee.gas !== '0') {\n    throw new Error('Gas should be \"0\" for ADR-36 signing');\n  }\n  if (signDoc.fee.amount.length !== 0) {\n    throw new Error('Fee amount should be empty array for ADR-36 signing');\n  }\n  var msg = signDoc.msgs[0];\n  if (msg.type !== 'sign/MsgSignData') {\n    throw new Error('Invalid type of ADR-36 sign msg: '.concat(msg.type));\n  }\n  if (!msg.value) {\n    throw new Error('Empty value in the msg');\n  }\n  var signer = msg.value.signer;\n  if (!signer) {\n    throw new Error('Empty signer in the ADR-36 msg');\n  }\n  (0, _address.isValidSeiAddress)(signer);\n  var data = msg.value.data;\n  if (!data) {\n    throw new Error('Empty data in the ADR-36 msg');\n  }\n  var rawData = Buffer.from(data, 'base64');\n  // Validate the data is encoded as base64.\n  if (rawData.toString('base64') !== data) {\n    throw new Error('Data is not encoded by base64');\n  }\n  if (rawData.length === 0) {\n    throw new Error('Empty data in the ADR-36 msg');\n  }\n  return true;\n}\nfunction makeADR36AminoSignDoc(signer, data) {\n  // If data is already a base64 string, convert it to a Buffer and back to a string.\n  data = Buffer.from(data).toString('base64');\n\n  //According to ADR-36 specifications https://github.com/cosmos/cosmos-sdk/blob/main/docs/architecture/adr-036-arbitrary-signature.md\n  return {\n    // chain-id must be equal to “”\n    chain_id: '',\n    // must be invalid value\n    account_number: '0',\n    // nonce, sequence number must be equal to 0\n    sequence: '0',\n    fee: {\n      // fee gas must be equal to 0\n      gas: '0',\n      //fee amount must be an empty array\n      amount: []\n    },\n    msgs: [{\n      type: 'sign/MsgSignData',\n      value: {\n        signer: signer,\n        // Data is arbitrary bytes which can represent text, files, objects. It's applications developers decision how Data should be deserialized, serialized and the object it can represent in their context\n        // It's applications developers decision how Data should be treated, by treated we mean the serialization and deserialization process and the Object Data should represent.\n        data: data\n      }\n    }],\n    // the memo must be empty\n    memo: ''\n  };\n}\nfunction verifyADR36AminoSignDoc(signDoc, pubKey, signature) {\n  if (!checkAndValidateADR36AminoSignDoc(signDoc)) {\n    throw new Error('Invalid sign doc for ADR-36');\n  }\n  var pubKeyAddress = (0, _address.getAddressFromPubKey)(pubKey);\n  var expectedSigner = (0, _bech.toBech32)(pubKeyAddress);\n  var signer = signDoc.msgs[0].value.signer;\n  if (expectedSigner !== signer) {\n    throw new Error('Unmatched signer');\n  }\n  var msg = (0, _amino.serializeSignDoc)(signDoc);\n  return (0, _address.verifyDigest32)((0, _hash.sha256)(msg), signature, pubKey);\n}\nfunction verifyADR36Amino(signer, data, pubKey, signature) {\n  var signDoc = makeADR36AminoSignDoc(signer, data);\n  return verifyADR36AminoSignDoc(signDoc, pubKey, signature);\n}\nvar verifyArbitrary = /*#__PURE__*/function () {\n  var _ref = (0, _asyncToGenerator2['default'])( /*#__PURE__*/_regenerator['default'].mark(function _callee(signerAddress, expectedMessage, signatureToVerify) {\n    var pubKey, signature;\n    return _regenerator['default'].wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.prev = 0;\n          pubKey = signatureToVerify.pub_key, signature = signatureToVerify.signature;\n          return _context.abrupt('return', verifyADR36Amino(signerAddress, expectedMessage, (0, _encoding.fromBase64)(pubKey.value), (0, _encoding.fromBase64)(signature)));\n        case 5:\n          _context.prev = 5;\n          _context.t0 = _context['catch'](0);\n          console.log('error verifying signature', _context.t0);\n          return _context.abrupt('return', false);\n        case 9:\n        case 'end':\n          return _context.stop();\n      }\n    }, _callee, null, [[0, 5]]);\n  }));\n  return function verifyArbitrary(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexports.verifyArbitrary = verifyArbitrary;","map":{"version":3,"names":["_amino","require","_encoding","_bech","_address","_hash","checkAndValidateADR36AminoSignDoc","signDoc","hasOnlyMsgSignData","msgs","Array","isArray","length","_msg","type","chain_id","Error","memo","account_number","sequence","fee","gas","amount","msg","concat","value","signer","isValidSeiAddress","data","rawData","Buffer","from","toString","makeADR36AminoSignDoc","verifyADR36AminoSignDoc","pubKey","signature","pubKeyAddress","getAddressFromPubKey","expectedSigner","toBech32","serializeSignDoc","verifyDigest32","sha256","verifyADR36Amino","verifyArbitrary","_ref","_asyncToGenerator2","_regenerator","mark","_callee","signerAddress","expectedMessage","signatureToVerify","wrap","_callee$","_context","prev","next","pub_key","abrupt","fromBase64","t0","console","log","stop"],"sources":["../../../src/lib/utils/signing.ts"],"sourcesContent":["import { serializeSignDoc, StdSignature, StdSignDoc } from '@cosmjs/amino';\nimport { fromBase64 } from '@cosmjs/encoding';\nimport { toBech32 } from './bech32';\nimport { getAddressFromPubKey, isValidSeiAddress, verifyDigest32 } from './address';\nimport { sha256 } from './hash';\n\nfunction checkAndValidateADR36AminoSignDoc(signDoc: StdSignDoc): boolean {\n\tconst hasOnlyMsgSignData = (() => {\n\t\tif (signDoc && signDoc.msgs && Array.isArray(signDoc.msgs) && signDoc.msgs.length === 1) {\n\t\t\tconst msg = signDoc.msgs[0];\n\t\t\treturn msg.type === 'sign/MsgSignData';\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t})();\n\n\tif (!hasOnlyMsgSignData) {\n\t\treturn false;\n\t}\n\n\tif (signDoc.chain_id !== '') {\n\t\tthrow new Error('Chain id should be empty string for ADR-36 signing');\n\t}\n\n\tif (signDoc.memo !== '') {\n\t\tthrow new Error('Memo should be empty string for ADR-36 signing');\n\t}\n\n\tif (signDoc.account_number !== '0') {\n\t\tthrow new Error('Account number should be \"0\" for ADR-36 signing');\n\t}\n\n\tif (signDoc.sequence !== '0') {\n\t\tthrow new Error('Sequence should be \"0\" for ADR-36 signing');\n\t}\n\n\tif (signDoc.fee.gas !== '0') {\n\t\tthrow new Error('Gas should be \"0\" for ADR-36 signing');\n\t}\n\n\tif (signDoc.fee.amount.length !== 0) {\n\t\tthrow new Error('Fee amount should be empty array for ADR-36 signing');\n\t}\n\n\tconst msg = signDoc.msgs[0];\n\tif (msg.type !== 'sign/MsgSignData') {\n\t\tthrow new Error(`Invalid type of ADR-36 sign msg: ${msg.type}`);\n\t}\n\tif (!msg.value) {\n\t\tthrow new Error('Empty value in the msg');\n\t}\n\tconst signer = msg.value.signer;\n\tif (!signer) {\n\t\tthrow new Error('Empty signer in the ADR-36 msg');\n\t}\n\tisValidSeiAddress(signer);\n\tconst data = msg.value.data;\n\tif (!data) {\n\t\tthrow new Error('Empty data in the ADR-36 msg');\n\t}\n\tconst rawData = Buffer.from(data, 'base64');\n\t// Validate the data is encoded as base64.\n\tif (rawData.toString('base64') !== data) {\n\t\tthrow new Error('Data is not encoded by base64');\n\t}\n\tif (rawData.length === 0) {\n\t\tthrow new Error('Empty data in the ADR-36 msg');\n\t}\n\n\treturn true;\n}\n\nfunction makeADR36AminoSignDoc(signer: string, data: string | Uint8Array): StdSignDoc {\n\t// If data is already a base64 string, convert it to a Buffer and back to a string.\n\tdata = Buffer.from(data).toString('base64');\n\n\t//According to ADR-36 specifications https://github.com/cosmos/cosmos-sdk/blob/main/docs/architecture/adr-036-arbitrary-signature.md\n\treturn {\n\t\t// chain-id must be equal to “”\n\t\tchain_id: '',\n\t\t// must be invalid value\n\t\taccount_number: '0',\n\t\t// nonce, sequence number must be equal to 0\n\t\tsequence: '0',\n\t\tfee: {\n\t\t\t// fee gas must be equal to 0\n\t\t\tgas: '0',\n\t\t\t//fee amount must be an empty array\n\t\t\tamount: []\n\t\t},\n\t\tmsgs: [\n\t\t\t{\n\t\t\t\ttype: 'sign/MsgSignData',\n\t\t\t\tvalue: {\n\t\t\t\t\tsigner,\n\t\t\t\t\t// Data is arbitrary bytes which can represent text, files, objects. It's applications developers decision how Data should be deserialized, serialized and the object it can represent in their context\n\t\t\t\t\t// It's applications developers decision how Data should be treated, by treated we mean the serialization and deserialization process and the Object Data should represent.\n\t\t\t\t\tdata\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t// the memo must be empty\n\t\tmemo: ''\n\t};\n}\n\nfunction verifyADR36AminoSignDoc(signDoc: StdSignDoc, pubKey: Uint8Array, signature: Uint8Array): boolean {\n\tif (!checkAndValidateADR36AminoSignDoc(signDoc)) {\n\t\tthrow new Error('Invalid sign doc for ADR-36');\n\t}\n\n\tconst pubKeyAddress = getAddressFromPubKey(pubKey);\n\tconst expectedSigner = toBech32(pubKeyAddress);\n\tconst signer = signDoc.msgs[0].value.signer;\n\tif (expectedSigner !== signer) {\n\t\tthrow new Error('Unmatched signer');\n\t}\n\n\tconst msg = serializeSignDoc(signDoc);\n\n\treturn verifyDigest32(sha256(msg), signature, pubKey);\n}\n\nfunction verifyADR36Amino(signer: string, data: string | Uint8Array, pubKey: Uint8Array, signature: Uint8Array): boolean {\n\tconst signDoc = makeADR36AminoSignDoc(signer, data);\n\n\treturn verifyADR36AminoSignDoc(signDoc, pubKey, signature);\n}\n\nexport const verifyArbitrary = async (signerAddress: string, expectedMessage: string, signatureToVerify: StdSignature): Promise<boolean> => {\n\ttry {\n\t\tconst { pub_key: pubKey, signature } = signatureToVerify;\n\t\treturn verifyADR36Amino(signerAddress, expectedMessage, fromBase64(pubKey.value), fromBase64(signature));\n\t} catch (e) {\n\t\tconsole.log('error verifying signature', e);\n\t\treturn false;\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}