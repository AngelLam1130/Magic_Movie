{"ast":null,"code":"\"use strict\";\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VoteInfo = exports.ValidatorUpdate = exports.Validator = exports.TxResult = exports.Snapshot = exports.ResponseSetOption = exports.ResponseQuery = exports.ResponseOfferSnapshot_ResultSDKType = exports.ResponseOfferSnapshot_Result = exports.ResponseOfferSnapshot = exports.ResponseLoadSnapshotChunk = exports.ResponseListSnapshots = exports.ResponseInitChain = exports.ResponseInfo = exports.ResponseFlush = exports.ResponseException = exports.ResponseEndBlock = exports.ResponseEcho = exports.ResponseDeliverTx = exports.ResponseCommit = exports.ResponseCheckTx = exports.ResponseBeginBlock = exports.ResponseApplySnapshotChunk_ResultSDKType = exports.ResponseApplySnapshotChunk_Result = exports.ResponseApplySnapshotChunk = exports.Response = exports.RequestSetOption = exports.RequestQuery = exports.RequestOfferSnapshot = exports.RequestLoadSnapshotChunk = exports.RequestListSnapshots = exports.RequestInitChain = exports.RequestInfo = exports.RequestFlush = exports.RequestEndBlock = exports.RequestEcho = exports.RequestDeliverTx = exports.RequestCommit = exports.RequestCheckTx = exports.RequestBeginBlock = exports.RequestApplySnapshotChunk = exports.Request = exports.LastCommitInfo = exports.EvidenceTypeSDKType = exports.EvidenceType = exports.Evidence = exports.EventAttribute = exports.Event = exports.ConsensusParams = exports.CheckTxTypeSDKType = exports.CheckTxType = exports.BlockParams = void 0;\nexports.checkTxTypeFromJSON = checkTxTypeFromJSON;\nexports.checkTxTypeToJSON = checkTxTypeToJSON;\nexports.evidenceTypeFromJSON = evidenceTypeFromJSON;\nexports.evidenceTypeToJSON = evidenceTypeToJSON;\nexports.responseApplySnapshotChunk_ResultFromJSON = responseApplySnapshotChunk_ResultFromJSON;\nexports.responseApplySnapshotChunk_ResultToJSON = responseApplySnapshotChunk_ResultToJSON;\nexports.responseOfferSnapshot_ResultFromJSON = responseOfferSnapshot_ResultFromJSON;\nexports.responseOfferSnapshot_ResultToJSON = responseOfferSnapshot_ResultToJSON;\nvar _timestamp = require(\"../../google/protobuf/timestamp\");\nvar _types = require(\"../types/types\");\nvar _proof = require(\"../crypto/proof\");\nvar _params = require(\"../types/params\");\nvar _keys = require(\"../crypto/keys\");\nvar _helpers = require(\"../../helpers\");\nvar _m0 = _interopRequireWildcard(require(\"protobufjs/minimal\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj[\"default\"] = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nvar CheckTxType;\nexports.CheckTxType = CheckTxType;\n(function (CheckTxType) {\n  CheckTxType[CheckTxType[\"NEW\"] = 0] = \"NEW\";\n  CheckTxType[CheckTxType[\"RECHECK\"] = 1] = \"RECHECK\";\n  CheckTxType[CheckTxType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(CheckTxType || (exports.CheckTxType = CheckTxType = {}));\nvar CheckTxTypeSDKType = CheckTxType;\nexports.CheckTxTypeSDKType = CheckTxTypeSDKType;\nfunction checkTxTypeFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"NEW\":\n      return CheckTxType.NEW;\n    case 1:\n    case \"RECHECK\":\n      return CheckTxType.RECHECK;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return CheckTxType.UNRECOGNIZED;\n  }\n}\nfunction checkTxTypeToJSON(object) {\n  switch (object) {\n    case CheckTxType.NEW:\n      return \"NEW\";\n    case CheckTxType.RECHECK:\n      return \"RECHECK\";\n    case CheckTxType.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar ResponseOfferSnapshot_Result;\nexports.ResponseOfferSnapshot_Result = ResponseOfferSnapshot_Result;\n(function (ResponseOfferSnapshot_Result) {\n  ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result[\"ACCEPT\"] = 1] = \"ACCEPT\";\n  ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result[\"ABORT\"] = 2] = \"ABORT\";\n  ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result[\"REJECT\"] = 3] = \"REJECT\";\n  ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result[\"REJECT_FORMAT\"] = 4] = \"REJECT_FORMAT\";\n  ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result[\"REJECT_SENDER\"] = 5] = \"REJECT_SENDER\";\n  ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ResponseOfferSnapshot_Result || (exports.ResponseOfferSnapshot_Result = ResponseOfferSnapshot_Result = {}));\nvar ResponseOfferSnapshot_ResultSDKType = ResponseOfferSnapshot_Result;\nexports.ResponseOfferSnapshot_ResultSDKType = ResponseOfferSnapshot_ResultSDKType;\nfunction responseOfferSnapshot_ResultFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"UNKNOWN\":\n      return ResponseOfferSnapshot_Result.UNKNOWN;\n    case 1:\n    case \"ACCEPT\":\n      return ResponseOfferSnapshot_Result.ACCEPT;\n    case 2:\n    case \"ABORT\":\n      return ResponseOfferSnapshot_Result.ABORT;\n    case 3:\n    case \"REJECT\":\n      return ResponseOfferSnapshot_Result.REJECT;\n    case 4:\n    case \"REJECT_FORMAT\":\n      return ResponseOfferSnapshot_Result.REJECT_FORMAT;\n    case 5:\n    case \"REJECT_SENDER\":\n      return ResponseOfferSnapshot_Result.REJECT_SENDER;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return ResponseOfferSnapshot_Result.UNRECOGNIZED;\n  }\n}\nfunction responseOfferSnapshot_ResultToJSON(object) {\n  switch (object) {\n    case ResponseOfferSnapshot_Result.UNKNOWN:\n      return \"UNKNOWN\";\n    case ResponseOfferSnapshot_Result.ACCEPT:\n      return \"ACCEPT\";\n    case ResponseOfferSnapshot_Result.ABORT:\n      return \"ABORT\";\n    case ResponseOfferSnapshot_Result.REJECT:\n      return \"REJECT\";\n    case ResponseOfferSnapshot_Result.REJECT_FORMAT:\n      return \"REJECT_FORMAT\";\n    case ResponseOfferSnapshot_Result.REJECT_SENDER:\n      return \"REJECT_SENDER\";\n    case ResponseOfferSnapshot_Result.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar ResponseApplySnapshotChunk_Result;\nexports.ResponseApplySnapshotChunk_Result = ResponseApplySnapshotChunk_Result;\n(function (ResponseApplySnapshotChunk_Result) {\n  ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result[\"ACCEPT\"] = 1] = \"ACCEPT\";\n  ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result[\"ABORT\"] = 2] = \"ABORT\";\n  ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result[\"RETRY\"] = 3] = \"RETRY\";\n  ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result[\"RETRY_SNAPSHOT\"] = 4] = \"RETRY_SNAPSHOT\";\n  ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result[\"REJECT_SNAPSHOT\"] = 5] = \"REJECT_SNAPSHOT\";\n  ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ResponseApplySnapshotChunk_Result || (exports.ResponseApplySnapshotChunk_Result = ResponseApplySnapshotChunk_Result = {}));\nvar ResponseApplySnapshotChunk_ResultSDKType = ResponseApplySnapshotChunk_Result;\nexports.ResponseApplySnapshotChunk_ResultSDKType = ResponseApplySnapshotChunk_ResultSDKType;\nfunction responseApplySnapshotChunk_ResultFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"UNKNOWN\":\n      return ResponseApplySnapshotChunk_Result.UNKNOWN;\n    case 1:\n    case \"ACCEPT\":\n      return ResponseApplySnapshotChunk_Result.ACCEPT;\n    case 2:\n    case \"ABORT\":\n      return ResponseApplySnapshotChunk_Result.ABORT;\n    case 3:\n    case \"RETRY\":\n      return ResponseApplySnapshotChunk_Result.RETRY;\n    case 4:\n    case \"RETRY_SNAPSHOT\":\n      return ResponseApplySnapshotChunk_Result.RETRY_SNAPSHOT;\n    case 5:\n    case \"REJECT_SNAPSHOT\":\n      return ResponseApplySnapshotChunk_Result.REJECT_SNAPSHOT;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return ResponseApplySnapshotChunk_Result.UNRECOGNIZED;\n  }\n}\nfunction responseApplySnapshotChunk_ResultToJSON(object) {\n  switch (object) {\n    case ResponseApplySnapshotChunk_Result.UNKNOWN:\n      return \"UNKNOWN\";\n    case ResponseApplySnapshotChunk_Result.ACCEPT:\n      return \"ACCEPT\";\n    case ResponseApplySnapshotChunk_Result.ABORT:\n      return \"ABORT\";\n    case ResponseApplySnapshotChunk_Result.RETRY:\n      return \"RETRY\";\n    case ResponseApplySnapshotChunk_Result.RETRY_SNAPSHOT:\n      return \"RETRY_SNAPSHOT\";\n    case ResponseApplySnapshotChunk_Result.REJECT_SNAPSHOT:\n      return \"REJECT_SNAPSHOT\";\n    case ResponseApplySnapshotChunk_Result.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar EvidenceType;\nexports.EvidenceType = EvidenceType;\n(function (EvidenceType) {\n  EvidenceType[EvidenceType[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  EvidenceType[EvidenceType[\"DUPLICATE_VOTE\"] = 1] = \"DUPLICATE_VOTE\";\n  EvidenceType[EvidenceType[\"LIGHT_CLIENT_ATTACK\"] = 2] = \"LIGHT_CLIENT_ATTACK\";\n  EvidenceType[EvidenceType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(EvidenceType || (exports.EvidenceType = EvidenceType = {}));\nvar EvidenceTypeSDKType = EvidenceType;\nexports.EvidenceTypeSDKType = EvidenceTypeSDKType;\nfunction evidenceTypeFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"UNKNOWN\":\n      return EvidenceType.UNKNOWN;\n    case 1:\n    case \"DUPLICATE_VOTE\":\n      return EvidenceType.DUPLICATE_VOTE;\n    case 2:\n    case \"LIGHT_CLIENT_ATTACK\":\n      return EvidenceType.LIGHT_CLIENT_ATTACK;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return EvidenceType.UNRECOGNIZED;\n  }\n}\nfunction evidenceTypeToJSON(object) {\n  switch (object) {\n    case EvidenceType.UNKNOWN:\n      return \"UNKNOWN\";\n    case EvidenceType.DUPLICATE_VOTE:\n      return \"DUPLICATE_VOTE\";\n    case EvidenceType.LIGHT_CLIENT_ATTACK:\n      return \"LIGHT_CLIENT_ATTACK\";\n    case EvidenceType.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nfunction createBaseRequest() {\n  return {\n    echo: undefined,\n    flush: undefined,\n    info: undefined,\n    setOption: undefined,\n    initChain: undefined,\n    query: undefined,\n    beginBlock: undefined,\n    checkTx: undefined,\n    deliverTx: undefined,\n    endBlock: undefined,\n    commit: undefined,\n    listSnapshots: undefined,\n    offerSnapshot: undefined,\n    loadSnapshotChunk: undefined,\n    applySnapshotChunk: undefined\n  };\n}\nvar Request = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.echo !== undefined) {\n      RequestEcho.encode(message.echo, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.flush !== undefined) {\n      RequestFlush.encode(message.flush, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.info !== undefined) {\n      RequestInfo.encode(message.info, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.setOption !== undefined) {\n      RequestSetOption.encode(message.setOption, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.initChain !== undefined) {\n      RequestInitChain.encode(message.initChain, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.query !== undefined) {\n      RequestQuery.encode(message.query, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.beginBlock !== undefined) {\n      RequestBeginBlock.encode(message.beginBlock, writer.uint32(58).fork()).ldelim();\n    }\n    if (message.checkTx !== undefined) {\n      RequestCheckTx.encode(message.checkTx, writer.uint32(66).fork()).ldelim();\n    }\n    if (message.deliverTx !== undefined) {\n      RequestDeliverTx.encode(message.deliverTx, writer.uint32(74).fork()).ldelim();\n    }\n    if (message.endBlock !== undefined) {\n      RequestEndBlock.encode(message.endBlock, writer.uint32(82).fork()).ldelim();\n    }\n    if (message.commit !== undefined) {\n      RequestCommit.encode(message.commit, writer.uint32(90).fork()).ldelim();\n    }\n    if (message.listSnapshots !== undefined) {\n      RequestListSnapshots.encode(message.listSnapshots, writer.uint32(98).fork()).ldelim();\n    }\n    if (message.offerSnapshot !== undefined) {\n      RequestOfferSnapshot.encode(message.offerSnapshot, writer.uint32(106).fork()).ldelim();\n    }\n    if (message.loadSnapshotChunk !== undefined) {\n      RequestLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(114).fork()).ldelim();\n    }\n    if (message.applySnapshotChunk !== undefined) {\n      RequestApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(122).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseRequest();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.echo = RequestEcho.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.flush = RequestFlush.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.info = RequestInfo.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.setOption = RequestSetOption.decode(reader, reader.uint32());\n          break;\n        case 5:\n          message.initChain = RequestInitChain.decode(reader, reader.uint32());\n          break;\n        case 6:\n          message.query = RequestQuery.decode(reader, reader.uint32());\n          break;\n        case 7:\n          message.beginBlock = RequestBeginBlock.decode(reader, reader.uint32());\n          break;\n        case 8:\n          message.checkTx = RequestCheckTx.decode(reader, reader.uint32());\n          break;\n        case 9:\n          message.deliverTx = RequestDeliverTx.decode(reader, reader.uint32());\n          break;\n        case 10:\n          message.endBlock = RequestEndBlock.decode(reader, reader.uint32());\n          break;\n        case 11:\n          message.commit = RequestCommit.decode(reader, reader.uint32());\n          break;\n        case 12:\n          message.listSnapshots = RequestListSnapshots.decode(reader, reader.uint32());\n          break;\n        case 13:\n          message.offerSnapshot = RequestOfferSnapshot.decode(reader, reader.uint32());\n          break;\n        case 14:\n          message.loadSnapshotChunk = RequestLoadSnapshotChunk.decode(reader, reader.uint32());\n          break;\n        case 15:\n          message.applySnapshotChunk = RequestApplySnapshotChunk.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = createBaseRequest();\n    message.echo = object.echo !== undefined && object.echo !== null ? RequestEcho.fromPartial(object.echo) : undefined;\n    message.flush = object.flush !== undefined && object.flush !== null ? RequestFlush.fromPartial(object.flush) : undefined;\n    message.info = object.info !== undefined && object.info !== null ? RequestInfo.fromPartial(object.info) : undefined;\n    message.setOption = object.setOption !== undefined && object.setOption !== null ? RequestSetOption.fromPartial(object.setOption) : undefined;\n    message.initChain = object.initChain !== undefined && object.initChain !== null ? RequestInitChain.fromPartial(object.initChain) : undefined;\n    message.query = object.query !== undefined && object.query !== null ? RequestQuery.fromPartial(object.query) : undefined;\n    message.beginBlock = object.beginBlock !== undefined && object.beginBlock !== null ? RequestBeginBlock.fromPartial(object.beginBlock) : undefined;\n    message.checkTx = object.checkTx !== undefined && object.checkTx !== null ? RequestCheckTx.fromPartial(object.checkTx) : undefined;\n    message.deliverTx = object.deliverTx !== undefined && object.deliverTx !== null ? RequestDeliverTx.fromPartial(object.deliverTx) : undefined;\n    message.endBlock = object.endBlock !== undefined && object.endBlock !== null ? RequestEndBlock.fromPartial(object.endBlock) : undefined;\n    message.commit = object.commit !== undefined && object.commit !== null ? RequestCommit.fromPartial(object.commit) : undefined;\n    message.listSnapshots = object.listSnapshots !== undefined && object.listSnapshots !== null ? RequestListSnapshots.fromPartial(object.listSnapshots) : undefined;\n    message.offerSnapshot = object.offerSnapshot !== undefined && object.offerSnapshot !== null ? RequestOfferSnapshot.fromPartial(object.offerSnapshot) : undefined;\n    message.loadSnapshotChunk = object.loadSnapshotChunk !== undefined && object.loadSnapshotChunk !== null ? RequestLoadSnapshotChunk.fromPartial(object.loadSnapshotChunk) : undefined;\n    message.applySnapshotChunk = object.applySnapshotChunk !== undefined && object.applySnapshotChunk !== null ? RequestApplySnapshotChunk.fromPartial(object.applySnapshotChunk) : undefined;\n    return message;\n  }\n};\nexports.Request = Request;\nfunction createBaseRequestEcho() {\n  return {\n    message: \"\"\n  };\n}\nvar RequestEcho = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.message !== \"\") {\n      writer.uint32(10).string(message.message);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseRequestEcho();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.message = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$message;\n    var message = createBaseRequestEcho();\n    message.message = (_object$message = object.message) !== null && _object$message !== void 0 ? _object$message : \"\";\n    return message;\n  }\n};\nexports.RequestEcho = RequestEcho;\nfunction createBaseRequestFlush() {\n  return {};\n}\nvar RequestFlush = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseRequestFlush();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = createBaseRequestFlush();\n    return message;\n  }\n};\nexports.RequestFlush = RequestFlush;\nfunction createBaseRequestInfo() {\n  return {\n    version: \"\",\n    blockVersion: _helpers.Long.UZERO,\n    p2pVersion: _helpers.Long.UZERO\n  };\n}\nvar RequestInfo = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.version !== \"\") {\n      writer.uint32(10).string(message.version);\n    }\n    if (!message.blockVersion.isZero()) {\n      writer.uint32(16).uint64(message.blockVersion);\n    }\n    if (!message.p2pVersion.isZero()) {\n      writer.uint32(24).uint64(message.p2pVersion);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseRequestInfo();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.version = reader.string();\n          break;\n        case 2:\n          message.blockVersion = reader.uint64();\n          break;\n        case 3:\n          message.p2pVersion = reader.uint64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$version;\n    var message = createBaseRequestInfo();\n    message.version = (_object$version = object.version) !== null && _object$version !== void 0 ? _object$version : \"\";\n    message.blockVersion = object.blockVersion !== undefined && object.blockVersion !== null ? _helpers.Long.fromValue(object.blockVersion) : _helpers.Long.UZERO;\n    message.p2pVersion = object.p2pVersion !== undefined && object.p2pVersion !== null ? _helpers.Long.fromValue(object.p2pVersion) : _helpers.Long.UZERO;\n    return message;\n  }\n};\nexports.RequestInfo = RequestInfo;\nfunction createBaseRequestSetOption() {\n  return {\n    key: \"\",\n    value: \"\"\n  };\n}\nvar RequestSetOption = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.key !== \"\") {\n      writer.uint32(10).string(message.key);\n    }\n    if (message.value !== \"\") {\n      writer.uint32(18).string(message.value);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseRequestSetOption();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.string();\n          break;\n        case 2:\n          message.value = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$key, _object$value;\n    var message = createBaseRequestSetOption();\n    message.key = (_object$key = object.key) !== null && _object$key !== void 0 ? _object$key : \"\";\n    message.value = (_object$value = object.value) !== null && _object$value !== void 0 ? _object$value : \"\";\n    return message;\n  }\n};\nexports.RequestSetOption = RequestSetOption;\nfunction createBaseRequestInitChain() {\n  return {\n    time: undefined,\n    chainId: \"\",\n    consensusParams: ConsensusParams.fromPartial({}),\n    validators: [],\n    appStateBytes: new Uint8Array(),\n    initialHeight: _helpers.Long.ZERO\n  };\n}\nvar RequestInitChain = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.time !== undefined) {\n      _timestamp.Timestamp.encode((0, _helpers.toTimestamp)(message.time), writer.uint32(10).fork()).ldelim();\n    }\n    if (message.chainId !== \"\") {\n      writer.uint32(18).string(message.chainId);\n    }\n    if (message.consensusParams !== undefined) {\n      ConsensusParams.encode(message.consensusParams, writer.uint32(26).fork()).ldelim();\n    }\n    var _iterator = _createForOfIteratorHelper(message.validators),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var v = _step.value;\n        ValidatorUpdate.encode(v, writer.uint32(34).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    if (message.appStateBytes.length !== 0) {\n      writer.uint32(42).bytes(message.appStateBytes);\n    }\n    if (!message.initialHeight.isZero()) {\n      writer.uint32(48).int64(message.initialHeight);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseRequestInitChain();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.time = (0, _helpers.fromTimestamp)(_timestamp.Timestamp.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.chainId = reader.string();\n          break;\n        case 3:\n          message.consensusParams = ConsensusParams.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.validators.push(ValidatorUpdate.decode(reader, reader.uint32()));\n          break;\n        case 5:\n          message.appStateBytes = reader.bytes();\n          break;\n        case 6:\n          message.initialHeight = reader.int64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$time, _object$chainId, _object$validators, _object$appStateBytes;\n    var message = createBaseRequestInitChain();\n    message.time = (_object$time = object.time) !== null && _object$time !== void 0 ? _object$time : undefined;\n    message.chainId = (_object$chainId = object.chainId) !== null && _object$chainId !== void 0 ? _object$chainId : \"\";\n    message.consensusParams = object.consensusParams !== undefined && object.consensusParams !== null ? ConsensusParams.fromPartial(object.consensusParams) : undefined;\n    message.validators = ((_object$validators = object.validators) === null || _object$validators === void 0 ? void 0 : _object$validators.map(function (e) {\n      return ValidatorUpdate.fromPartial(e);\n    })) || [];\n    message.appStateBytes = (_object$appStateBytes = object.appStateBytes) !== null && _object$appStateBytes !== void 0 ? _object$appStateBytes : new Uint8Array();\n    message.initialHeight = object.initialHeight !== undefined && object.initialHeight !== null ? _helpers.Long.fromValue(object.initialHeight) : _helpers.Long.ZERO;\n    return message;\n  }\n};\nexports.RequestInitChain = RequestInitChain;\nfunction createBaseRequestQuery() {\n  return {\n    data: new Uint8Array(),\n    path: \"\",\n    height: _helpers.Long.ZERO,\n    prove: false\n  };\n}\nvar RequestQuery = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.data.length !== 0) {\n      writer.uint32(10).bytes(message.data);\n    }\n    if (message.path !== \"\") {\n      writer.uint32(18).string(message.path);\n    }\n    if (!message.height.isZero()) {\n      writer.uint32(24).int64(message.height);\n    }\n    if (message.prove === true) {\n      writer.uint32(32).bool(message.prove);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseRequestQuery();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.data = reader.bytes();\n          break;\n        case 2:\n          message.path = reader.string();\n          break;\n        case 3:\n          message.height = reader.int64();\n          break;\n        case 4:\n          message.prove = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$data, _object$path, _object$prove;\n    var message = createBaseRequestQuery();\n    message.data = (_object$data = object.data) !== null && _object$data !== void 0 ? _object$data : new Uint8Array();\n    message.path = (_object$path = object.path) !== null && _object$path !== void 0 ? _object$path : \"\";\n    message.height = object.height !== undefined && object.height !== null ? _helpers.Long.fromValue(object.height) : _helpers.Long.ZERO;\n    message.prove = (_object$prove = object.prove) !== null && _object$prove !== void 0 ? _object$prove : false;\n    return message;\n  }\n};\nexports.RequestQuery = RequestQuery;\nfunction createBaseRequestBeginBlock() {\n  return {\n    hash: new Uint8Array(),\n    header: _types.Header.fromPartial({}),\n    lastCommitInfo: LastCommitInfo.fromPartial({}),\n    byzantineValidators: []\n  };\n}\nvar RequestBeginBlock = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.hash.length !== 0) {\n      writer.uint32(10).bytes(message.hash);\n    }\n    if (message.header !== undefined) {\n      _types.Header.encode(message.header, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.lastCommitInfo !== undefined) {\n      LastCommitInfo.encode(message.lastCommitInfo, writer.uint32(26).fork()).ldelim();\n    }\n    var _iterator2 = _createForOfIteratorHelper(message.byzantineValidators),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var v = _step2.value;\n        Evidence.encode(v, writer.uint32(34).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseRequestBeginBlock();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.bytes();\n          break;\n        case 2:\n          message.header = _types.Header.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.lastCommitInfo = LastCommitInfo.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.byzantineValidators.push(Evidence.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$hash, _object$byzantineVali;\n    var message = createBaseRequestBeginBlock();\n    message.hash = (_object$hash = object.hash) !== null && _object$hash !== void 0 ? _object$hash : new Uint8Array();\n    message.header = object.header !== undefined && object.header !== null ? _types.Header.fromPartial(object.header) : undefined;\n    message.lastCommitInfo = object.lastCommitInfo !== undefined && object.lastCommitInfo !== null ? LastCommitInfo.fromPartial(object.lastCommitInfo) : undefined;\n    message.byzantineValidators = ((_object$byzantineVali = object.byzantineValidators) === null || _object$byzantineVali === void 0 ? void 0 : _object$byzantineVali.map(function (e) {\n      return Evidence.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.RequestBeginBlock = RequestBeginBlock;\nfunction createBaseRequestCheckTx() {\n  return {\n    tx: new Uint8Array(),\n    type: 0\n  };\n}\nvar RequestCheckTx = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.tx.length !== 0) {\n      writer.uint32(10).bytes(message.tx);\n    }\n    if (message.type !== 0) {\n      writer.uint32(16).int32(message.type);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseRequestCheckTx();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.tx = reader.bytes();\n          break;\n        case 2:\n          message.type = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$tx, _object$type;\n    var message = createBaseRequestCheckTx();\n    message.tx = (_object$tx = object.tx) !== null && _object$tx !== void 0 ? _object$tx : new Uint8Array();\n    message.type = (_object$type = object.type) !== null && _object$type !== void 0 ? _object$type : 0;\n    return message;\n  }\n};\nexports.RequestCheckTx = RequestCheckTx;\nfunction createBaseRequestDeliverTx() {\n  return {\n    tx: new Uint8Array()\n  };\n}\nvar RequestDeliverTx = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.tx.length !== 0) {\n      writer.uint32(10).bytes(message.tx);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseRequestDeliverTx();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.tx = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$tx2;\n    var message = createBaseRequestDeliverTx();\n    message.tx = (_object$tx2 = object.tx) !== null && _object$tx2 !== void 0 ? _object$tx2 : new Uint8Array();\n    return message;\n  }\n};\nexports.RequestDeliverTx = RequestDeliverTx;\nfunction createBaseRequestEndBlock() {\n  return {\n    height: _helpers.Long.ZERO\n  };\n}\nvar RequestEndBlock = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (!message.height.isZero()) {\n      writer.uint32(8).int64(message.height);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseRequestEndBlock();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.height = reader.int64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = createBaseRequestEndBlock();\n    message.height = object.height !== undefined && object.height !== null ? _helpers.Long.fromValue(object.height) : _helpers.Long.ZERO;\n    return message;\n  }\n};\nexports.RequestEndBlock = RequestEndBlock;\nfunction createBaseRequestCommit() {\n  return {};\n}\nvar RequestCommit = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseRequestCommit();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = createBaseRequestCommit();\n    return message;\n  }\n};\nexports.RequestCommit = RequestCommit;\nfunction createBaseRequestListSnapshots() {\n  return {};\n}\nvar RequestListSnapshots = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseRequestListSnapshots();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = createBaseRequestListSnapshots();\n    return message;\n  }\n};\nexports.RequestListSnapshots = RequestListSnapshots;\nfunction createBaseRequestOfferSnapshot() {\n  return {\n    snapshot: Snapshot.fromPartial({}),\n    appHash: new Uint8Array()\n  };\n}\nvar RequestOfferSnapshot = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.snapshot !== undefined) {\n      Snapshot.encode(message.snapshot, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.appHash.length !== 0) {\n      writer.uint32(18).bytes(message.appHash);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseRequestOfferSnapshot();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.snapshot = Snapshot.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.appHash = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$appHash;\n    var message = createBaseRequestOfferSnapshot();\n    message.snapshot = object.snapshot !== undefined && object.snapshot !== null ? Snapshot.fromPartial(object.snapshot) : undefined;\n    message.appHash = (_object$appHash = object.appHash) !== null && _object$appHash !== void 0 ? _object$appHash : new Uint8Array();\n    return message;\n  }\n};\nexports.RequestOfferSnapshot = RequestOfferSnapshot;\nfunction createBaseRequestLoadSnapshotChunk() {\n  return {\n    height: _helpers.Long.UZERO,\n    format: 0,\n    chunk: 0\n  };\n}\nvar RequestLoadSnapshotChunk = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (!message.height.isZero()) {\n      writer.uint32(8).uint64(message.height);\n    }\n    if (message.format !== 0) {\n      writer.uint32(16).uint32(message.format);\n    }\n    if (message.chunk !== 0) {\n      writer.uint32(24).uint32(message.chunk);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseRequestLoadSnapshotChunk();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.height = reader.uint64();\n          break;\n        case 2:\n          message.format = reader.uint32();\n          break;\n        case 3:\n          message.chunk = reader.uint32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$format, _object$chunk;\n    var message = createBaseRequestLoadSnapshotChunk();\n    message.height = object.height !== undefined && object.height !== null ? _helpers.Long.fromValue(object.height) : _helpers.Long.UZERO;\n    message.format = (_object$format = object.format) !== null && _object$format !== void 0 ? _object$format : 0;\n    message.chunk = (_object$chunk = object.chunk) !== null && _object$chunk !== void 0 ? _object$chunk : 0;\n    return message;\n  }\n};\nexports.RequestLoadSnapshotChunk = RequestLoadSnapshotChunk;\nfunction createBaseRequestApplySnapshotChunk() {\n  return {\n    index: 0,\n    chunk: new Uint8Array(),\n    sender: \"\"\n  };\n}\nvar RequestApplySnapshotChunk = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.index !== 0) {\n      writer.uint32(8).uint32(message.index);\n    }\n    if (message.chunk.length !== 0) {\n      writer.uint32(18).bytes(message.chunk);\n    }\n    if (message.sender !== \"\") {\n      writer.uint32(26).string(message.sender);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseRequestApplySnapshotChunk();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.index = reader.uint32();\n          break;\n        case 2:\n          message.chunk = reader.bytes();\n          break;\n        case 3:\n          message.sender = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$index, _object$chunk2, _object$sender;\n    var message = createBaseRequestApplySnapshotChunk();\n    message.index = (_object$index = object.index) !== null && _object$index !== void 0 ? _object$index : 0;\n    message.chunk = (_object$chunk2 = object.chunk) !== null && _object$chunk2 !== void 0 ? _object$chunk2 : new Uint8Array();\n    message.sender = (_object$sender = object.sender) !== null && _object$sender !== void 0 ? _object$sender : \"\";\n    return message;\n  }\n};\nexports.RequestApplySnapshotChunk = RequestApplySnapshotChunk;\nfunction createBaseResponse() {\n  return {\n    exception: undefined,\n    echo: undefined,\n    flush: undefined,\n    info: undefined,\n    setOption: undefined,\n    initChain: undefined,\n    query: undefined,\n    beginBlock: undefined,\n    checkTx: undefined,\n    deliverTx: undefined,\n    endBlock: undefined,\n    commit: undefined,\n    listSnapshots: undefined,\n    offerSnapshot: undefined,\n    loadSnapshotChunk: undefined,\n    applySnapshotChunk: undefined\n  };\n}\nvar Response = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.exception !== undefined) {\n      ResponseException.encode(message.exception, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.echo !== undefined) {\n      ResponseEcho.encode(message.echo, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.flush !== undefined) {\n      ResponseFlush.encode(message.flush, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.info !== undefined) {\n      ResponseInfo.encode(message.info, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.setOption !== undefined) {\n      ResponseSetOption.encode(message.setOption, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.initChain !== undefined) {\n      ResponseInitChain.encode(message.initChain, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.query !== undefined) {\n      ResponseQuery.encode(message.query, writer.uint32(58).fork()).ldelim();\n    }\n    if (message.beginBlock !== undefined) {\n      ResponseBeginBlock.encode(message.beginBlock, writer.uint32(66).fork()).ldelim();\n    }\n    if (message.checkTx !== undefined) {\n      ResponseCheckTx.encode(message.checkTx, writer.uint32(74).fork()).ldelim();\n    }\n    if (message.deliverTx !== undefined) {\n      ResponseDeliverTx.encode(message.deliverTx, writer.uint32(82).fork()).ldelim();\n    }\n    if (message.endBlock !== undefined) {\n      ResponseEndBlock.encode(message.endBlock, writer.uint32(90).fork()).ldelim();\n    }\n    if (message.commit !== undefined) {\n      ResponseCommit.encode(message.commit, writer.uint32(98).fork()).ldelim();\n    }\n    if (message.listSnapshots !== undefined) {\n      ResponseListSnapshots.encode(message.listSnapshots, writer.uint32(106).fork()).ldelim();\n    }\n    if (message.offerSnapshot !== undefined) {\n      ResponseOfferSnapshot.encode(message.offerSnapshot, writer.uint32(114).fork()).ldelim();\n    }\n    if (message.loadSnapshotChunk !== undefined) {\n      ResponseLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(122).fork()).ldelim();\n    }\n    if (message.applySnapshotChunk !== undefined) {\n      ResponseApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(130).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseResponse();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.exception = ResponseException.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.echo = ResponseEcho.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.flush = ResponseFlush.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.info = ResponseInfo.decode(reader, reader.uint32());\n          break;\n        case 5:\n          message.setOption = ResponseSetOption.decode(reader, reader.uint32());\n          break;\n        case 6:\n          message.initChain = ResponseInitChain.decode(reader, reader.uint32());\n          break;\n        case 7:\n          message.query = ResponseQuery.decode(reader, reader.uint32());\n          break;\n        case 8:\n          message.beginBlock = ResponseBeginBlock.decode(reader, reader.uint32());\n          break;\n        case 9:\n          message.checkTx = ResponseCheckTx.decode(reader, reader.uint32());\n          break;\n        case 10:\n          message.deliverTx = ResponseDeliverTx.decode(reader, reader.uint32());\n          break;\n        case 11:\n          message.endBlock = ResponseEndBlock.decode(reader, reader.uint32());\n          break;\n        case 12:\n          message.commit = ResponseCommit.decode(reader, reader.uint32());\n          break;\n        case 13:\n          message.listSnapshots = ResponseListSnapshots.decode(reader, reader.uint32());\n          break;\n        case 14:\n          message.offerSnapshot = ResponseOfferSnapshot.decode(reader, reader.uint32());\n          break;\n        case 15:\n          message.loadSnapshotChunk = ResponseLoadSnapshotChunk.decode(reader, reader.uint32());\n          break;\n        case 16:\n          message.applySnapshotChunk = ResponseApplySnapshotChunk.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = createBaseResponse();\n    message.exception = object.exception !== undefined && object.exception !== null ? ResponseException.fromPartial(object.exception) : undefined;\n    message.echo = object.echo !== undefined && object.echo !== null ? ResponseEcho.fromPartial(object.echo) : undefined;\n    message.flush = object.flush !== undefined && object.flush !== null ? ResponseFlush.fromPartial(object.flush) : undefined;\n    message.info = object.info !== undefined && object.info !== null ? ResponseInfo.fromPartial(object.info) : undefined;\n    message.setOption = object.setOption !== undefined && object.setOption !== null ? ResponseSetOption.fromPartial(object.setOption) : undefined;\n    message.initChain = object.initChain !== undefined && object.initChain !== null ? ResponseInitChain.fromPartial(object.initChain) : undefined;\n    message.query = object.query !== undefined && object.query !== null ? ResponseQuery.fromPartial(object.query) : undefined;\n    message.beginBlock = object.beginBlock !== undefined && object.beginBlock !== null ? ResponseBeginBlock.fromPartial(object.beginBlock) : undefined;\n    message.checkTx = object.checkTx !== undefined && object.checkTx !== null ? ResponseCheckTx.fromPartial(object.checkTx) : undefined;\n    message.deliverTx = object.deliverTx !== undefined && object.deliverTx !== null ? ResponseDeliverTx.fromPartial(object.deliverTx) : undefined;\n    message.endBlock = object.endBlock !== undefined && object.endBlock !== null ? ResponseEndBlock.fromPartial(object.endBlock) : undefined;\n    message.commit = object.commit !== undefined && object.commit !== null ? ResponseCommit.fromPartial(object.commit) : undefined;\n    message.listSnapshots = object.listSnapshots !== undefined && object.listSnapshots !== null ? ResponseListSnapshots.fromPartial(object.listSnapshots) : undefined;\n    message.offerSnapshot = object.offerSnapshot !== undefined && object.offerSnapshot !== null ? ResponseOfferSnapshot.fromPartial(object.offerSnapshot) : undefined;\n    message.loadSnapshotChunk = object.loadSnapshotChunk !== undefined && object.loadSnapshotChunk !== null ? ResponseLoadSnapshotChunk.fromPartial(object.loadSnapshotChunk) : undefined;\n    message.applySnapshotChunk = object.applySnapshotChunk !== undefined && object.applySnapshotChunk !== null ? ResponseApplySnapshotChunk.fromPartial(object.applySnapshotChunk) : undefined;\n    return message;\n  }\n};\nexports.Response = Response;\nfunction createBaseResponseException() {\n  return {\n    error: \"\"\n  };\n}\nvar ResponseException = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.error !== \"\") {\n      writer.uint32(10).string(message.error);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseResponseException();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.error = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$error;\n    var message = createBaseResponseException();\n    message.error = (_object$error = object.error) !== null && _object$error !== void 0 ? _object$error : \"\";\n    return message;\n  }\n};\nexports.ResponseException = ResponseException;\nfunction createBaseResponseEcho() {\n  return {\n    message: \"\"\n  };\n}\nvar ResponseEcho = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.message !== \"\") {\n      writer.uint32(10).string(message.message);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseResponseEcho();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.message = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$message2;\n    var message = createBaseResponseEcho();\n    message.message = (_object$message2 = object.message) !== null && _object$message2 !== void 0 ? _object$message2 : \"\";\n    return message;\n  }\n};\nexports.ResponseEcho = ResponseEcho;\nfunction createBaseResponseFlush() {\n  return {};\n}\nvar ResponseFlush = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseResponseFlush();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = createBaseResponseFlush();\n    return message;\n  }\n};\nexports.ResponseFlush = ResponseFlush;\nfunction createBaseResponseInfo() {\n  return {\n    data: \"\",\n    version: \"\",\n    appVersion: _helpers.Long.UZERO,\n    lastBlockHeight: _helpers.Long.ZERO,\n    lastBlockAppHash: new Uint8Array()\n  };\n}\nvar ResponseInfo = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.data !== \"\") {\n      writer.uint32(10).string(message.data);\n    }\n    if (message.version !== \"\") {\n      writer.uint32(18).string(message.version);\n    }\n    if (!message.appVersion.isZero()) {\n      writer.uint32(24).uint64(message.appVersion);\n    }\n    if (!message.lastBlockHeight.isZero()) {\n      writer.uint32(32).int64(message.lastBlockHeight);\n    }\n    if (message.lastBlockAppHash.length !== 0) {\n      writer.uint32(42).bytes(message.lastBlockAppHash);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseResponseInfo();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.data = reader.string();\n          break;\n        case 2:\n          message.version = reader.string();\n          break;\n        case 3:\n          message.appVersion = reader.uint64();\n          break;\n        case 4:\n          message.lastBlockHeight = reader.int64();\n          break;\n        case 5:\n          message.lastBlockAppHash = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$data2, _object$version2, _object$lastBlockAppH;\n    var message = createBaseResponseInfo();\n    message.data = (_object$data2 = object.data) !== null && _object$data2 !== void 0 ? _object$data2 : \"\";\n    message.version = (_object$version2 = object.version) !== null && _object$version2 !== void 0 ? _object$version2 : \"\";\n    message.appVersion = object.appVersion !== undefined && object.appVersion !== null ? _helpers.Long.fromValue(object.appVersion) : _helpers.Long.UZERO;\n    message.lastBlockHeight = object.lastBlockHeight !== undefined && object.lastBlockHeight !== null ? _helpers.Long.fromValue(object.lastBlockHeight) : _helpers.Long.ZERO;\n    message.lastBlockAppHash = (_object$lastBlockAppH = object.lastBlockAppHash) !== null && _object$lastBlockAppH !== void 0 ? _object$lastBlockAppH : new Uint8Array();\n    return message;\n  }\n};\nexports.ResponseInfo = ResponseInfo;\nfunction createBaseResponseSetOption() {\n  return {\n    code: 0,\n    log: \"\",\n    info: \"\"\n  };\n}\nvar ResponseSetOption = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.code !== 0) {\n      writer.uint32(8).uint32(message.code);\n    }\n    if (message.log !== \"\") {\n      writer.uint32(26).string(message.log);\n    }\n    if (message.info !== \"\") {\n      writer.uint32(34).string(message.info);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseResponseSetOption();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.code = reader.uint32();\n          break;\n        case 3:\n          message.log = reader.string();\n          break;\n        case 4:\n          message.info = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$code, _object$log, _object$info;\n    var message = createBaseResponseSetOption();\n    message.code = (_object$code = object.code) !== null && _object$code !== void 0 ? _object$code : 0;\n    message.log = (_object$log = object.log) !== null && _object$log !== void 0 ? _object$log : \"\";\n    message.info = (_object$info = object.info) !== null && _object$info !== void 0 ? _object$info : \"\";\n    return message;\n  }\n};\nexports.ResponseSetOption = ResponseSetOption;\nfunction createBaseResponseInitChain() {\n  return {\n    consensusParams: ConsensusParams.fromPartial({}),\n    validators: [],\n    appHash: new Uint8Array()\n  };\n}\nvar ResponseInitChain = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.consensusParams !== undefined) {\n      ConsensusParams.encode(message.consensusParams, writer.uint32(10).fork()).ldelim();\n    }\n    var _iterator3 = _createForOfIteratorHelper(message.validators),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var v = _step3.value;\n        ValidatorUpdate.encode(v, writer.uint32(18).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    if (message.appHash.length !== 0) {\n      writer.uint32(26).bytes(message.appHash);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseResponseInitChain();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.consensusParams = ConsensusParams.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.validators.push(ValidatorUpdate.decode(reader, reader.uint32()));\n          break;\n        case 3:\n          message.appHash = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$validators2, _object$appHash2;\n    var message = createBaseResponseInitChain();\n    message.consensusParams = object.consensusParams !== undefined && object.consensusParams !== null ? ConsensusParams.fromPartial(object.consensusParams) : undefined;\n    message.validators = ((_object$validators2 = object.validators) === null || _object$validators2 === void 0 ? void 0 : _object$validators2.map(function (e) {\n      return ValidatorUpdate.fromPartial(e);\n    })) || [];\n    message.appHash = (_object$appHash2 = object.appHash) !== null && _object$appHash2 !== void 0 ? _object$appHash2 : new Uint8Array();\n    return message;\n  }\n};\nexports.ResponseInitChain = ResponseInitChain;\nfunction createBaseResponseQuery() {\n  return {\n    code: 0,\n    log: \"\",\n    info: \"\",\n    index: _helpers.Long.ZERO,\n    key: new Uint8Array(),\n    value: new Uint8Array(),\n    proofOps: _proof.ProofOps.fromPartial({}),\n    height: _helpers.Long.ZERO,\n    codespace: \"\"\n  };\n}\nvar ResponseQuery = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.code !== 0) {\n      writer.uint32(8).uint32(message.code);\n    }\n    if (message.log !== \"\") {\n      writer.uint32(26).string(message.log);\n    }\n    if (message.info !== \"\") {\n      writer.uint32(34).string(message.info);\n    }\n    if (!message.index.isZero()) {\n      writer.uint32(40).int64(message.index);\n    }\n    if (message.key.length !== 0) {\n      writer.uint32(50).bytes(message.key);\n    }\n    if (message.value.length !== 0) {\n      writer.uint32(58).bytes(message.value);\n    }\n    if (message.proofOps !== undefined) {\n      _proof.ProofOps.encode(message.proofOps, writer.uint32(66).fork()).ldelim();\n    }\n    if (!message.height.isZero()) {\n      writer.uint32(72).int64(message.height);\n    }\n    if (message.codespace !== \"\") {\n      writer.uint32(82).string(message.codespace);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseResponseQuery();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.code = reader.uint32();\n          break;\n        case 3:\n          message.log = reader.string();\n          break;\n        case 4:\n          message.info = reader.string();\n          break;\n        case 5:\n          message.index = reader.int64();\n          break;\n        case 6:\n          message.key = reader.bytes();\n          break;\n        case 7:\n          message.value = reader.bytes();\n          break;\n        case 8:\n          message.proofOps = _proof.ProofOps.decode(reader, reader.uint32());\n          break;\n        case 9:\n          message.height = reader.int64();\n          break;\n        case 10:\n          message.codespace = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$code2, _object$log2, _object$info2, _object$key2, _object$value2, _object$codespace;\n    var message = createBaseResponseQuery();\n    message.code = (_object$code2 = object.code) !== null && _object$code2 !== void 0 ? _object$code2 : 0;\n    message.log = (_object$log2 = object.log) !== null && _object$log2 !== void 0 ? _object$log2 : \"\";\n    message.info = (_object$info2 = object.info) !== null && _object$info2 !== void 0 ? _object$info2 : \"\";\n    message.index = object.index !== undefined && object.index !== null ? _helpers.Long.fromValue(object.index) : _helpers.Long.ZERO;\n    message.key = (_object$key2 = object.key) !== null && _object$key2 !== void 0 ? _object$key2 : new Uint8Array();\n    message.value = (_object$value2 = object.value) !== null && _object$value2 !== void 0 ? _object$value2 : new Uint8Array();\n    message.proofOps = object.proofOps !== undefined && object.proofOps !== null ? _proof.ProofOps.fromPartial(object.proofOps) : undefined;\n    message.height = object.height !== undefined && object.height !== null ? _helpers.Long.fromValue(object.height) : _helpers.Long.ZERO;\n    message.codespace = (_object$codespace = object.codespace) !== null && _object$codespace !== void 0 ? _object$codespace : \"\";\n    return message;\n  }\n};\nexports.ResponseQuery = ResponseQuery;\nfunction createBaseResponseBeginBlock() {\n  return {\n    events: []\n  };\n}\nvar ResponseBeginBlock = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    var _iterator4 = _createForOfIteratorHelper(message.events),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var v = _step4.value;\n        Event.encode(v, writer.uint32(10).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseResponseBeginBlock();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.events.push(Event.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$events;\n    var message = createBaseResponseBeginBlock();\n    message.events = ((_object$events = object.events) === null || _object$events === void 0 ? void 0 : _object$events.map(function (e) {\n      return Event.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.ResponseBeginBlock = ResponseBeginBlock;\nfunction createBaseResponseCheckTx() {\n  return {\n    code: 0,\n    data: new Uint8Array(),\n    log: \"\",\n    info: \"\",\n    gasWanted: _helpers.Long.ZERO,\n    gasUsed: _helpers.Long.ZERO,\n    events: [],\n    codespace: \"\"\n  };\n}\nvar ResponseCheckTx = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.code !== 0) {\n      writer.uint32(8).uint32(message.code);\n    }\n    if (message.data.length !== 0) {\n      writer.uint32(18).bytes(message.data);\n    }\n    if (message.log !== \"\") {\n      writer.uint32(26).string(message.log);\n    }\n    if (message.info !== \"\") {\n      writer.uint32(34).string(message.info);\n    }\n    if (!message.gasWanted.isZero()) {\n      writer.uint32(40).int64(message.gasWanted);\n    }\n    if (!message.gasUsed.isZero()) {\n      writer.uint32(48).int64(message.gasUsed);\n    }\n    var _iterator5 = _createForOfIteratorHelper(message.events),\n      _step5;\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var v = _step5.value;\n        Event.encode(v, writer.uint32(58).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n    if (message.codespace !== \"\") {\n      writer.uint32(66).string(message.codespace);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseResponseCheckTx();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.code = reader.uint32();\n          break;\n        case 2:\n          message.data = reader.bytes();\n          break;\n        case 3:\n          message.log = reader.string();\n          break;\n        case 4:\n          message.info = reader.string();\n          break;\n        case 5:\n          message.gasWanted = reader.int64();\n          break;\n        case 6:\n          message.gasUsed = reader.int64();\n          break;\n        case 7:\n          message.events.push(Event.decode(reader, reader.uint32()));\n          break;\n        case 8:\n          message.codespace = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$code3, _object$data3, _object$log3, _object$info3, _object$events2, _object$codespace2;\n    var message = createBaseResponseCheckTx();\n    message.code = (_object$code3 = object.code) !== null && _object$code3 !== void 0 ? _object$code3 : 0;\n    message.data = (_object$data3 = object.data) !== null && _object$data3 !== void 0 ? _object$data3 : new Uint8Array();\n    message.log = (_object$log3 = object.log) !== null && _object$log3 !== void 0 ? _object$log3 : \"\";\n    message.info = (_object$info3 = object.info) !== null && _object$info3 !== void 0 ? _object$info3 : \"\";\n    message.gasWanted = object.gasWanted !== undefined && object.gasWanted !== null ? _helpers.Long.fromValue(object.gasWanted) : _helpers.Long.ZERO;\n    message.gasUsed = object.gasUsed !== undefined && object.gasUsed !== null ? _helpers.Long.fromValue(object.gasUsed) : _helpers.Long.ZERO;\n    message.events = ((_object$events2 = object.events) === null || _object$events2 === void 0 ? void 0 : _object$events2.map(function (e) {\n      return Event.fromPartial(e);\n    })) || [];\n    message.codespace = (_object$codespace2 = object.codespace) !== null && _object$codespace2 !== void 0 ? _object$codespace2 : \"\";\n    return message;\n  }\n};\nexports.ResponseCheckTx = ResponseCheckTx;\nfunction createBaseResponseDeliverTx() {\n  return {\n    code: 0,\n    data: new Uint8Array(),\n    log: \"\",\n    info: \"\",\n    gasWanted: _helpers.Long.ZERO,\n    gasUsed: _helpers.Long.ZERO,\n    events: [],\n    codespace: \"\"\n  };\n}\nvar ResponseDeliverTx = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.code !== 0) {\n      writer.uint32(8).uint32(message.code);\n    }\n    if (message.data.length !== 0) {\n      writer.uint32(18).bytes(message.data);\n    }\n    if (message.log !== \"\") {\n      writer.uint32(26).string(message.log);\n    }\n    if (message.info !== \"\") {\n      writer.uint32(34).string(message.info);\n    }\n    if (!message.gasWanted.isZero()) {\n      writer.uint32(40).int64(message.gasWanted);\n    }\n    if (!message.gasUsed.isZero()) {\n      writer.uint32(48).int64(message.gasUsed);\n    }\n    var _iterator6 = _createForOfIteratorHelper(message.events),\n      _step6;\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var v = _step6.value;\n        Event.encode(v, writer.uint32(58).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n    if (message.codespace !== \"\") {\n      writer.uint32(66).string(message.codespace);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseResponseDeliverTx();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.code = reader.uint32();\n          break;\n        case 2:\n          message.data = reader.bytes();\n          break;\n        case 3:\n          message.log = reader.string();\n          break;\n        case 4:\n          message.info = reader.string();\n          break;\n        case 5:\n          message.gasWanted = reader.int64();\n          break;\n        case 6:\n          message.gasUsed = reader.int64();\n          break;\n        case 7:\n          message.events.push(Event.decode(reader, reader.uint32()));\n          break;\n        case 8:\n          message.codespace = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$code4, _object$data4, _object$log4, _object$info4, _object$events3, _object$codespace3;\n    var message = createBaseResponseDeliverTx();\n    message.code = (_object$code4 = object.code) !== null && _object$code4 !== void 0 ? _object$code4 : 0;\n    message.data = (_object$data4 = object.data) !== null && _object$data4 !== void 0 ? _object$data4 : new Uint8Array();\n    message.log = (_object$log4 = object.log) !== null && _object$log4 !== void 0 ? _object$log4 : \"\";\n    message.info = (_object$info4 = object.info) !== null && _object$info4 !== void 0 ? _object$info4 : \"\";\n    message.gasWanted = object.gasWanted !== undefined && object.gasWanted !== null ? _helpers.Long.fromValue(object.gasWanted) : _helpers.Long.ZERO;\n    message.gasUsed = object.gasUsed !== undefined && object.gasUsed !== null ? _helpers.Long.fromValue(object.gasUsed) : _helpers.Long.ZERO;\n    message.events = ((_object$events3 = object.events) === null || _object$events3 === void 0 ? void 0 : _object$events3.map(function (e) {\n      return Event.fromPartial(e);\n    })) || [];\n    message.codespace = (_object$codespace3 = object.codespace) !== null && _object$codespace3 !== void 0 ? _object$codespace3 : \"\";\n    return message;\n  }\n};\nexports.ResponseDeliverTx = ResponseDeliverTx;\nfunction createBaseResponseEndBlock() {\n  return {\n    validatorUpdates: [],\n    consensusParamUpdates: ConsensusParams.fromPartial({}),\n    events: []\n  };\n}\nvar ResponseEndBlock = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    var _iterator7 = _createForOfIteratorHelper(message.validatorUpdates),\n      _step7;\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var v = _step7.value;\n        ValidatorUpdate.encode(v, writer.uint32(10).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n    if (message.consensusParamUpdates !== undefined) {\n      ConsensusParams.encode(message.consensusParamUpdates, writer.uint32(18).fork()).ldelim();\n    }\n    var _iterator8 = _createForOfIteratorHelper(message.events),\n      _step8;\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var _v = _step8.value;\n        Event.encode(_v, writer.uint32(26).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseResponseEndBlock();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.validatorUpdates.push(ValidatorUpdate.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.consensusParamUpdates = ConsensusParams.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.events.push(Event.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$validatorUpda, _object$events4;\n    var message = createBaseResponseEndBlock();\n    message.validatorUpdates = ((_object$validatorUpda = object.validatorUpdates) === null || _object$validatorUpda === void 0 ? void 0 : _object$validatorUpda.map(function (e) {\n      return ValidatorUpdate.fromPartial(e);\n    })) || [];\n    message.consensusParamUpdates = object.consensusParamUpdates !== undefined && object.consensusParamUpdates !== null ? ConsensusParams.fromPartial(object.consensusParamUpdates) : undefined;\n    message.events = ((_object$events4 = object.events) === null || _object$events4 === void 0 ? void 0 : _object$events4.map(function (e) {\n      return Event.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.ResponseEndBlock = ResponseEndBlock;\nfunction createBaseResponseCommit() {\n  return {\n    data: new Uint8Array(),\n    retainHeight: _helpers.Long.ZERO\n  };\n}\nvar ResponseCommit = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.data.length !== 0) {\n      writer.uint32(18).bytes(message.data);\n    }\n    if (!message.retainHeight.isZero()) {\n      writer.uint32(24).int64(message.retainHeight);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseResponseCommit();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 2:\n          message.data = reader.bytes();\n          break;\n        case 3:\n          message.retainHeight = reader.int64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$data5;\n    var message = createBaseResponseCommit();\n    message.data = (_object$data5 = object.data) !== null && _object$data5 !== void 0 ? _object$data5 : new Uint8Array();\n    message.retainHeight = object.retainHeight !== undefined && object.retainHeight !== null ? _helpers.Long.fromValue(object.retainHeight) : _helpers.Long.ZERO;\n    return message;\n  }\n};\nexports.ResponseCommit = ResponseCommit;\nfunction createBaseResponseListSnapshots() {\n  return {\n    snapshots: []\n  };\n}\nvar ResponseListSnapshots = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    var _iterator9 = _createForOfIteratorHelper(message.snapshots),\n      _step9;\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var v = _step9.value;\n        Snapshot.encode(v, writer.uint32(10).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseResponseListSnapshots();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.snapshots.push(Snapshot.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$snapshots;\n    var message = createBaseResponseListSnapshots();\n    message.snapshots = ((_object$snapshots = object.snapshots) === null || _object$snapshots === void 0 ? void 0 : _object$snapshots.map(function (e) {\n      return Snapshot.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.ResponseListSnapshots = ResponseListSnapshots;\nfunction createBaseResponseOfferSnapshot() {\n  return {\n    result: 0\n  };\n}\nvar ResponseOfferSnapshot = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.result !== 0) {\n      writer.uint32(8).int32(message.result);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseResponseOfferSnapshot();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.result = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$result;\n    var message = createBaseResponseOfferSnapshot();\n    message.result = (_object$result = object.result) !== null && _object$result !== void 0 ? _object$result : 0;\n    return message;\n  }\n};\nexports.ResponseOfferSnapshot = ResponseOfferSnapshot;\nfunction createBaseResponseLoadSnapshotChunk() {\n  return {\n    chunk: new Uint8Array()\n  };\n}\nvar ResponseLoadSnapshotChunk = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.chunk.length !== 0) {\n      writer.uint32(10).bytes(message.chunk);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseResponseLoadSnapshotChunk();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.chunk = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$chunk3;\n    var message = createBaseResponseLoadSnapshotChunk();\n    message.chunk = (_object$chunk3 = object.chunk) !== null && _object$chunk3 !== void 0 ? _object$chunk3 : new Uint8Array();\n    return message;\n  }\n};\nexports.ResponseLoadSnapshotChunk = ResponseLoadSnapshotChunk;\nfunction createBaseResponseApplySnapshotChunk() {\n  return {\n    result: 0,\n    refetchChunks: [],\n    rejectSenders: []\n  };\n}\nvar ResponseApplySnapshotChunk = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.result !== 0) {\n      writer.uint32(8).int32(message.result);\n    }\n    writer.uint32(18).fork();\n    var _iterator10 = _createForOfIteratorHelper(message.refetchChunks),\n      _step10;\n    try {\n      for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n        var v = _step10.value;\n        writer.uint32(v);\n      }\n    } catch (err) {\n      _iterator10.e(err);\n    } finally {\n      _iterator10.f();\n    }\n    writer.ldelim();\n    var _iterator11 = _createForOfIteratorHelper(message.rejectSenders),\n      _step11;\n    try {\n      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n        var _v2 = _step11.value;\n        writer.uint32(26).string(_v2);\n      }\n    } catch (err) {\n      _iterator11.e(err);\n    } finally {\n      _iterator11.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseResponseApplySnapshotChunk();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.result = reader.int32();\n          break;\n        case 2:\n          if ((tag & 7) === 2) {\n            var end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.refetchChunks.push(reader.uint32());\n            }\n          } else {\n            message.refetchChunks.push(reader.uint32());\n          }\n          break;\n        case 3:\n          message.rejectSenders.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$result2, _object$refetchChunks, _object$rejectSenders;\n    var message = createBaseResponseApplySnapshotChunk();\n    message.result = (_object$result2 = object.result) !== null && _object$result2 !== void 0 ? _object$result2 : 0;\n    message.refetchChunks = ((_object$refetchChunks = object.refetchChunks) === null || _object$refetchChunks === void 0 ? void 0 : _object$refetchChunks.map(function (e) {\n      return e;\n    })) || [];\n    message.rejectSenders = ((_object$rejectSenders = object.rejectSenders) === null || _object$rejectSenders === void 0 ? void 0 : _object$rejectSenders.map(function (e) {\n      return e;\n    })) || [];\n    return message;\n  }\n};\nexports.ResponseApplySnapshotChunk = ResponseApplySnapshotChunk;\nfunction createBaseConsensusParams() {\n  return {\n    block: BlockParams.fromPartial({}),\n    evidence: _params.EvidenceParams.fromPartial({}),\n    validator: _params.ValidatorParams.fromPartial({}),\n    version: _params.VersionParams.fromPartial({})\n  };\n}\nvar ConsensusParams = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.block !== undefined) {\n      BlockParams.encode(message.block, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.evidence !== undefined) {\n      _params.EvidenceParams.encode(message.evidence, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.validator !== undefined) {\n      _params.ValidatorParams.encode(message.validator, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.version !== undefined) {\n      _params.VersionParams.encode(message.version, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseConsensusParams();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.block = BlockParams.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.evidence = _params.EvidenceParams.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.validator = _params.ValidatorParams.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.version = _params.VersionParams.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = createBaseConsensusParams();\n    message.block = object.block !== undefined && object.block !== null ? BlockParams.fromPartial(object.block) : undefined;\n    message.evidence = object.evidence !== undefined && object.evidence !== null ? _params.EvidenceParams.fromPartial(object.evidence) : undefined;\n    message.validator = object.validator !== undefined && object.validator !== null ? _params.ValidatorParams.fromPartial(object.validator) : undefined;\n    message.version = object.version !== undefined && object.version !== null ? _params.VersionParams.fromPartial(object.version) : undefined;\n    return message;\n  }\n};\nexports.ConsensusParams = ConsensusParams;\nfunction createBaseBlockParams() {\n  return {\n    maxBytes: _helpers.Long.ZERO,\n    maxGas: _helpers.Long.ZERO\n  };\n}\nvar BlockParams = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (!message.maxBytes.isZero()) {\n      writer.uint32(8).int64(message.maxBytes);\n    }\n    if (!message.maxGas.isZero()) {\n      writer.uint32(16).int64(message.maxGas);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseBlockParams();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.maxBytes = reader.int64();\n          break;\n        case 2:\n          message.maxGas = reader.int64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = createBaseBlockParams();\n    message.maxBytes = object.maxBytes !== undefined && object.maxBytes !== null ? _helpers.Long.fromValue(object.maxBytes) : _helpers.Long.ZERO;\n    message.maxGas = object.maxGas !== undefined && object.maxGas !== null ? _helpers.Long.fromValue(object.maxGas) : _helpers.Long.ZERO;\n    return message;\n  }\n};\nexports.BlockParams = BlockParams;\nfunction createBaseLastCommitInfo() {\n  return {\n    round: 0,\n    votes: []\n  };\n}\nvar LastCommitInfo = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.round !== 0) {\n      writer.uint32(8).int32(message.round);\n    }\n    var _iterator12 = _createForOfIteratorHelper(message.votes),\n      _step12;\n    try {\n      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n        var v = _step12.value;\n        VoteInfo.encode(v, writer.uint32(18).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator12.e(err);\n    } finally {\n      _iterator12.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseLastCommitInfo();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.round = reader.int32();\n          break;\n        case 2:\n          message.votes.push(VoteInfo.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$round, _object$votes;\n    var message = createBaseLastCommitInfo();\n    message.round = (_object$round = object.round) !== null && _object$round !== void 0 ? _object$round : 0;\n    message.votes = ((_object$votes = object.votes) === null || _object$votes === void 0 ? void 0 : _object$votes.map(function (e) {\n      return VoteInfo.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.LastCommitInfo = LastCommitInfo;\nfunction createBaseEvent() {\n  return {\n    type: \"\",\n    attributes: []\n  };\n}\nvar Event = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.type !== \"\") {\n      writer.uint32(10).string(message.type);\n    }\n    var _iterator13 = _createForOfIteratorHelper(message.attributes),\n      _step13;\n    try {\n      for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n        var v = _step13.value;\n        EventAttribute.encode(v, writer.uint32(18).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator13.e(err);\n    } finally {\n      _iterator13.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseEvent();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.string();\n          break;\n        case 2:\n          message.attributes.push(EventAttribute.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$type2, _object$attributes;\n    var message = createBaseEvent();\n    message.type = (_object$type2 = object.type) !== null && _object$type2 !== void 0 ? _object$type2 : \"\";\n    message.attributes = ((_object$attributes = object.attributes) === null || _object$attributes === void 0 ? void 0 : _object$attributes.map(function (e) {\n      return EventAttribute.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.Event = Event;\nfunction createBaseEventAttribute() {\n  return {\n    key: new Uint8Array(),\n    value: new Uint8Array(),\n    index: false\n  };\n}\nvar EventAttribute = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    if (message.value.length !== 0) {\n      writer.uint32(18).bytes(message.value);\n    }\n    if (message.index === true) {\n      writer.uint32(24).bool(message.index);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseEventAttribute();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        case 2:\n          message.value = reader.bytes();\n          break;\n        case 3:\n          message.index = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$key3, _object$value3, _object$index2;\n    var message = createBaseEventAttribute();\n    message.key = (_object$key3 = object.key) !== null && _object$key3 !== void 0 ? _object$key3 : new Uint8Array();\n    message.value = (_object$value3 = object.value) !== null && _object$value3 !== void 0 ? _object$value3 : new Uint8Array();\n    message.index = (_object$index2 = object.index) !== null && _object$index2 !== void 0 ? _object$index2 : false;\n    return message;\n  }\n};\nexports.EventAttribute = EventAttribute;\nfunction createBaseTxResult() {\n  return {\n    height: _helpers.Long.ZERO,\n    index: 0,\n    tx: new Uint8Array(),\n    result: ResponseDeliverTx.fromPartial({})\n  };\n}\nvar TxResult = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (!message.height.isZero()) {\n      writer.uint32(8).int64(message.height);\n    }\n    if (message.index !== 0) {\n      writer.uint32(16).uint32(message.index);\n    }\n    if (message.tx.length !== 0) {\n      writer.uint32(26).bytes(message.tx);\n    }\n    if (message.result !== undefined) {\n      ResponseDeliverTx.encode(message.result, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseTxResult();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.height = reader.int64();\n          break;\n        case 2:\n          message.index = reader.uint32();\n          break;\n        case 3:\n          message.tx = reader.bytes();\n          break;\n        case 4:\n          message.result = ResponseDeliverTx.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$index3, _object$tx3;\n    var message = createBaseTxResult();\n    message.height = object.height !== undefined && object.height !== null ? _helpers.Long.fromValue(object.height) : _helpers.Long.ZERO;\n    message.index = (_object$index3 = object.index) !== null && _object$index3 !== void 0 ? _object$index3 : 0;\n    message.tx = (_object$tx3 = object.tx) !== null && _object$tx3 !== void 0 ? _object$tx3 : new Uint8Array();\n    message.result = object.result !== undefined && object.result !== null ? ResponseDeliverTx.fromPartial(object.result) : undefined;\n    return message;\n  }\n};\nexports.TxResult = TxResult;\nfunction createBaseValidator() {\n  return {\n    address: new Uint8Array(),\n    power: _helpers.Long.ZERO\n  };\n}\nvar Validator = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.address.length !== 0) {\n      writer.uint32(10).bytes(message.address);\n    }\n    if (!message.power.isZero()) {\n      writer.uint32(24).int64(message.power);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseValidator();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.address = reader.bytes();\n          break;\n        case 3:\n          message.power = reader.int64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$address;\n    var message = createBaseValidator();\n    message.address = (_object$address = object.address) !== null && _object$address !== void 0 ? _object$address : new Uint8Array();\n    message.power = object.power !== undefined && object.power !== null ? _helpers.Long.fromValue(object.power) : _helpers.Long.ZERO;\n    return message;\n  }\n};\nexports.Validator = Validator;\nfunction createBaseValidatorUpdate() {\n  return {\n    pubKey: _keys.PublicKey.fromPartial({}),\n    power: _helpers.Long.ZERO\n  };\n}\nvar ValidatorUpdate = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.pubKey !== undefined) {\n      _keys.PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();\n    }\n    if (!message.power.isZero()) {\n      writer.uint32(16).int64(message.power);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseValidatorUpdate();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.pubKey = _keys.PublicKey.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.power = reader.int64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = createBaseValidatorUpdate();\n    message.pubKey = object.pubKey !== undefined && object.pubKey !== null ? _keys.PublicKey.fromPartial(object.pubKey) : undefined;\n    message.power = object.power !== undefined && object.power !== null ? _helpers.Long.fromValue(object.power) : _helpers.Long.ZERO;\n    return message;\n  }\n};\nexports.ValidatorUpdate = ValidatorUpdate;\nfunction createBaseVoteInfo() {\n  return {\n    validator: Validator.fromPartial({}),\n    signedLastBlock: false\n  };\n}\nvar VoteInfo = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.validator !== undefined) {\n      Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.signedLastBlock === true) {\n      writer.uint32(16).bool(message.signedLastBlock);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseVoteInfo();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.validator = Validator.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.signedLastBlock = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$signedLastBlo;\n    var message = createBaseVoteInfo();\n    message.validator = object.validator !== undefined && object.validator !== null ? Validator.fromPartial(object.validator) : undefined;\n    message.signedLastBlock = (_object$signedLastBlo = object.signedLastBlock) !== null && _object$signedLastBlo !== void 0 ? _object$signedLastBlo : false;\n    return message;\n  }\n};\nexports.VoteInfo = VoteInfo;\nfunction createBaseEvidence() {\n  return {\n    type: 0,\n    validator: Validator.fromPartial({}),\n    height: _helpers.Long.ZERO,\n    time: undefined,\n    totalVotingPower: _helpers.Long.ZERO\n  };\n}\nvar Evidence = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.type !== 0) {\n      writer.uint32(8).int32(message.type);\n    }\n    if (message.validator !== undefined) {\n      Validator.encode(message.validator, writer.uint32(18).fork()).ldelim();\n    }\n    if (!message.height.isZero()) {\n      writer.uint32(24).int64(message.height);\n    }\n    if (message.time !== undefined) {\n      _timestamp.Timestamp.encode((0, _helpers.toTimestamp)(message.time), writer.uint32(34).fork()).ldelim();\n    }\n    if (!message.totalVotingPower.isZero()) {\n      writer.uint32(40).int64(message.totalVotingPower);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseEvidence();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.int32();\n          break;\n        case 2:\n          message.validator = Validator.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.height = reader.int64();\n          break;\n        case 4:\n          message.time = (0, _helpers.fromTimestamp)(_timestamp.Timestamp.decode(reader, reader.uint32()));\n          break;\n        case 5:\n          message.totalVotingPower = reader.int64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$type3, _object$time2;\n    var message = createBaseEvidence();\n    message.type = (_object$type3 = object.type) !== null && _object$type3 !== void 0 ? _object$type3 : 0;\n    message.validator = object.validator !== undefined && object.validator !== null ? Validator.fromPartial(object.validator) : undefined;\n    message.height = object.height !== undefined && object.height !== null ? _helpers.Long.fromValue(object.height) : _helpers.Long.ZERO;\n    message.time = (_object$time2 = object.time) !== null && _object$time2 !== void 0 ? _object$time2 : undefined;\n    message.totalVotingPower = object.totalVotingPower !== undefined && object.totalVotingPower !== null ? _helpers.Long.fromValue(object.totalVotingPower) : _helpers.Long.ZERO;\n    return message;\n  }\n};\nexports.Evidence = Evidence;\nfunction createBaseSnapshot() {\n  return {\n    height: _helpers.Long.UZERO,\n    format: 0,\n    chunks: 0,\n    hash: new Uint8Array(),\n    metadata: new Uint8Array()\n  };\n}\nvar Snapshot = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (!message.height.isZero()) {\n      writer.uint32(8).uint64(message.height);\n    }\n    if (message.format !== 0) {\n      writer.uint32(16).uint32(message.format);\n    }\n    if (message.chunks !== 0) {\n      writer.uint32(24).uint32(message.chunks);\n    }\n    if (message.hash.length !== 0) {\n      writer.uint32(34).bytes(message.hash);\n    }\n    if (message.metadata.length !== 0) {\n      writer.uint32(42).bytes(message.metadata);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseSnapshot();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.height = reader.uint64();\n          break;\n        case 2:\n          message.format = reader.uint32();\n          break;\n        case 3:\n          message.chunks = reader.uint32();\n          break;\n        case 4:\n          message.hash = reader.bytes();\n          break;\n        case 5:\n          message.metadata = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$format2, _object$chunks, _object$hash2, _object$metadata;\n    var message = createBaseSnapshot();\n    message.height = object.height !== undefined && object.height !== null ? _helpers.Long.fromValue(object.height) : _helpers.Long.UZERO;\n    message.format = (_object$format2 = object.format) !== null && _object$format2 !== void 0 ? _object$format2 : 0;\n    message.chunks = (_object$chunks = object.chunks) !== null && _object$chunks !== void 0 ? _object$chunks : 0;\n    message.hash = (_object$hash2 = object.hash) !== null && _object$hash2 !== void 0 ? _object$hash2 : new Uint8Array();\n    message.metadata = (_object$metadata = object.metadata) !== null && _object$metadata !== void 0 ? _object$metadata : new Uint8Array();\n    return message;\n  }\n};\nexports.Snapshot = Snapshot;","map":null,"metadata":{},"sourceType":"script"}