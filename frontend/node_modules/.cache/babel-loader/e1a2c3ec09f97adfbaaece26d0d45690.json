{"ast":null,"code":"\"use strict\";\n\nvar _possibleConstructorReturn = require(\"/Users/linanqi/Hackathon/GameRoom/frontend/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/Users/linanqi/Hackathon/GameRoom/frontend/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/Users/linanqi/Hackathon/GameRoom/frontend/node_modules/@babel/runtime/helpers/inherits\");\nvar _toConsumableArray = require(\"/Users/linanqi/Hackathon/GameRoom/frontend/node_modules/@babel/runtime/helpers/toConsumableArray\");\nvar _classCallCheck = require(\"/Users/linanqi/Hackathon/GameRoom/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/linanqi/Hackathon/GameRoom/frontend/node_modules/@babel/runtime/helpers/createClass\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExtendedSecp256k1Signature = exports.Secp256k1Signature = void 0;\nfunction trimLeadingNullBytes(inData) {\n  var numberOfLeadingNullBytes = 0;\n  var _iterator = _createForOfIteratorHelper(inData),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var byte = _step.value;\n      if (byte === 0x00) {\n        numberOfLeadingNullBytes++;\n      } else {\n        break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return inData.slice(numberOfLeadingNullBytes);\n}\nvar derTagInteger = 0x02;\nvar Secp256k1Signature = /*#__PURE__*/function () {\n  function Secp256k1Signature(r, s) {\n    _classCallCheck(this, Secp256k1Signature);\n    if (r.length > 32 || r.length === 0 || r[0] === 0x00) {\n      throw new Error(\"Unsigned integer r must be encoded as unpadded big endian.\");\n    }\n    if (s.length > 32 || s.length === 0 || s[0] === 0x00) {\n      throw new Error(\"Unsigned integer s must be encoded as unpadded big endian.\");\n    }\n    this.data = {\n      r: r,\n      s: s\n    };\n  }\n  /**\n   * Takes the pair of integers (r, s) as 2x32 byte of binary data.\n   *\n   * Note: This is the format Cosmos SDK uses natively.\n   *\n   * @param data a 64 byte value containing integers r and s.\n   */\n  _createClass(Secp256k1Signature, [{\n    key: \"r\",\n    value: function r(length) {\n      if (length === undefined) {\n        return this.data.r;\n      } else {\n        var paddingLength = length - this.data.r.length;\n        if (paddingLength < 0) {\n          throw new Error(\"Length too small to hold parameter r\");\n        }\n        var padding = new Uint8Array(paddingLength);\n        return new Uint8Array([].concat(_toConsumableArray(padding), _toConsumableArray(this.data.r)));\n      }\n    }\n  }, {\n    key: \"s\",\n    value: function s(length) {\n      if (length === undefined) {\n        return this.data.s;\n      } else {\n        var paddingLength = length - this.data.s.length;\n        if (paddingLength < 0) {\n          throw new Error(\"Length too small to hold parameter s\");\n        }\n        var padding = new Uint8Array(paddingLength);\n        return new Uint8Array([].concat(_toConsumableArray(padding), _toConsumableArray(this.data.s)));\n      }\n    }\n  }, {\n    key: \"toFixedLength\",\n    value: function toFixedLength() {\n      return new Uint8Array([].concat(_toConsumableArray(this.r(32)), _toConsumableArray(this.s(32))));\n    }\n  }, {\n    key: \"toDer\",\n    value: function toDer() {\n      // DER supports negative integers but our data is unsigned. Thus we need to prepend\n      // a leading 0 byte when the higest bit is set to differentiate nagative values\n      var rEncoded = this.data.r[0] >= 0x80 ? new Uint8Array([0].concat(_toConsumableArray(this.data.r))) : this.data.r;\n      var sEncoded = this.data.s[0] >= 0x80 ? new Uint8Array([0].concat(_toConsumableArray(this.data.s))) : this.data.s;\n      var rLength = rEncoded.length;\n      var sLength = sEncoded.length;\n      var data = new Uint8Array([derTagInteger, rLength].concat(_toConsumableArray(rEncoded), [derTagInteger, sLength], _toConsumableArray(sEncoded)));\n      return new Uint8Array([0x30, data.length].concat(_toConsumableArray(data)));\n    }\n  }], [{\n    key: \"fromFixedLength\",\n    value: function fromFixedLength(data) {\n      if (data.length !== 64) {\n        throw new Error(\"Got invalid data length: \".concat(data.length, \". Expected 2x 32 bytes for the pair (r, s)\"));\n      }\n      return new Secp256k1Signature(trimLeadingNullBytes(data.slice(0, 32)), trimLeadingNullBytes(data.slice(32, 64)));\n    }\n  }, {\n    key: \"fromDer\",\n    value: function fromDer(data) {\n      var pos = 0;\n      if (data[pos++] !== 0x30) {\n        throw new Error(\"Prefix 0x30 expected\");\n      }\n      var bodyLength = data[pos++];\n      if (data.length - pos !== bodyLength) {\n        throw new Error(\"Data length mismatch detected\");\n      }\n      // r\n      var rTag = data[pos++];\n      if (rTag !== derTagInteger) {\n        throw new Error(\"INTEGER tag expected\");\n      }\n      var rLength = data[pos++];\n      if (rLength >= 0x80) {\n        throw new Error(\"Decoding length values above 127 not supported\");\n      }\n      var rData = data.slice(pos, pos + rLength);\n      pos += rLength;\n      // s\n      var sTag = data[pos++];\n      if (sTag !== derTagInteger) {\n        throw new Error(\"INTEGER tag expected\");\n      }\n      var sLength = data[pos++];\n      if (sLength >= 0x80) {\n        throw new Error(\"Decoding length values above 127 not supported\");\n      }\n      var sData = data.slice(pos, pos + sLength);\n      pos += sLength;\n      return new Secp256k1Signature(\n      // r/s data can contain leading 0 bytes to express integers being non-negative in DER\n      trimLeadingNullBytes(rData), trimLeadingNullBytes(sData));\n    }\n  }]);\n  return Secp256k1Signature;\n}();\nexports.Secp256k1Signature = Secp256k1Signature;\n/**\n * A Secp256k1Signature plus the recovery parameter\n */\nvar ExtendedSecp256k1Signature = /*#__PURE__*/function (_Secp256k1Signature) {\n  _inherits(ExtendedSecp256k1Signature, _Secp256k1Signature);\n  function ExtendedSecp256k1Signature(r, s, recovery) {\n    var _this;\n    _classCallCheck(this, ExtendedSecp256k1Signature);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ExtendedSecp256k1Signature).call(this, r, s));\n    if (!Number.isInteger(recovery)) {\n      throw new Error(\"The recovery parameter must be an integer.\");\n    }\n    if (recovery < 0 || recovery > 4) {\n      throw new Error(\"The recovery parameter must be one of 0, 1, 2, 3.\");\n    }\n    _this.recovery = recovery;\n    return _this;\n  }\n  /**\n   * Decode extended signature from the simple fixed length encoding\n   * described in toFixedLength().\n   */\n  _createClass(ExtendedSecp256k1Signature, [{\n    key: \"toFixedLength\",\n    /**\n     * A simple custom encoding that encodes the extended signature as\n     * r (32 bytes) | s (32 bytes) | recovery param (1 byte)\n     * where | denotes concatenation of bonary data.\n     */\n    value: function toFixedLength() {\n      return new Uint8Array([].concat(_toConsumableArray(this.r(32)), _toConsumableArray(this.s(32)), [this.recovery]));\n    }\n  }], [{\n    key: \"fromFixedLength\",\n    value: function fromFixedLength(data) {\n      if (data.length !== 65) {\n        throw new Error(\"Got invalid data length \".concat(data.length, \". Expected 32 + 32 + 1\"));\n      }\n      return new ExtendedSecp256k1Signature(trimLeadingNullBytes(data.slice(0, 32)), trimLeadingNullBytes(data.slice(32, 64)), data[64]);\n    }\n  }]);\n  return ExtendedSecp256k1Signature;\n}(Secp256k1Signature);\nexports.ExtendedSecp256k1Signature = ExtendedSecp256k1Signature;","map":null,"metadata":{},"sourceType":"script"}