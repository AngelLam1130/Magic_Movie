{"ast":null,"code":"\"use strict\";\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TimestampedSignatureData = exports.SignatureAndData = exports.SignBytes = exports.PacketReceiptAbsenceData = exports.PacketCommitmentData = exports.PacketAcknowledgementData = exports.NextSequenceRecvData = exports.Misbehaviour = exports.HeaderData = exports.Header = exports.DataTypeSDKType = exports.DataType = exports.ConsensusStateData = exports.ConsensusState = exports.ConnectionStateData = exports.ClientStateData = exports.ClientState = exports.ChannelStateData = void 0;\nexports.dataTypeFromJSON = dataTypeFromJSON;\nexports.dataTypeToJSON = dataTypeToJSON;\nvar _any = require(\"../../../../google/protobuf/any\");\nvar _connection = require(\"../../../core/connection/v1/connection\");\nvar _channel = require(\"../../../core/channel/v1/channel\");\nvar _helpers = require(\"../../../../helpers\");\nvar _m0 = _interopRequireWildcard(require(\"protobufjs/minimal\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj[\"default\"] = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n/**\n * DataType defines the type of solo machine proof being created. This is done\n * to preserve uniqueness of different data sign byte encodings.\n */\nvar DataType;\nexports.DataType = DataType;\n(function (DataType) {\n  DataType[DataType[\"DATA_TYPE_UNINITIALIZED_UNSPECIFIED\"] = 0] = \"DATA_TYPE_UNINITIALIZED_UNSPECIFIED\";\n  DataType[DataType[\"DATA_TYPE_CLIENT_STATE\"] = 1] = \"DATA_TYPE_CLIENT_STATE\";\n  DataType[DataType[\"DATA_TYPE_CONSENSUS_STATE\"] = 2] = \"DATA_TYPE_CONSENSUS_STATE\";\n  DataType[DataType[\"DATA_TYPE_CONNECTION_STATE\"] = 3] = \"DATA_TYPE_CONNECTION_STATE\";\n  DataType[DataType[\"DATA_TYPE_CHANNEL_STATE\"] = 4] = \"DATA_TYPE_CHANNEL_STATE\";\n  DataType[DataType[\"DATA_TYPE_PACKET_COMMITMENT\"] = 5] = \"DATA_TYPE_PACKET_COMMITMENT\";\n  DataType[DataType[\"DATA_TYPE_PACKET_ACKNOWLEDGEMENT\"] = 6] = \"DATA_TYPE_PACKET_ACKNOWLEDGEMENT\";\n  DataType[DataType[\"DATA_TYPE_PACKET_RECEIPT_ABSENCE\"] = 7] = \"DATA_TYPE_PACKET_RECEIPT_ABSENCE\";\n  DataType[DataType[\"DATA_TYPE_NEXT_SEQUENCE_RECV\"] = 8] = \"DATA_TYPE_NEXT_SEQUENCE_RECV\";\n  DataType[DataType[\"DATA_TYPE_HEADER\"] = 9] = \"DATA_TYPE_HEADER\";\n  DataType[DataType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(DataType || (exports.DataType = DataType = {}));\nvar DataTypeSDKType = DataType;\nexports.DataTypeSDKType = DataTypeSDKType;\nfunction dataTypeFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"DATA_TYPE_UNINITIALIZED_UNSPECIFIED\":\n      return DataType.DATA_TYPE_UNINITIALIZED_UNSPECIFIED;\n    case 1:\n    case \"DATA_TYPE_CLIENT_STATE\":\n      return DataType.DATA_TYPE_CLIENT_STATE;\n    case 2:\n    case \"DATA_TYPE_CONSENSUS_STATE\":\n      return DataType.DATA_TYPE_CONSENSUS_STATE;\n    case 3:\n    case \"DATA_TYPE_CONNECTION_STATE\":\n      return DataType.DATA_TYPE_CONNECTION_STATE;\n    case 4:\n    case \"DATA_TYPE_CHANNEL_STATE\":\n      return DataType.DATA_TYPE_CHANNEL_STATE;\n    case 5:\n    case \"DATA_TYPE_PACKET_COMMITMENT\":\n      return DataType.DATA_TYPE_PACKET_COMMITMENT;\n    case 6:\n    case \"DATA_TYPE_PACKET_ACKNOWLEDGEMENT\":\n      return DataType.DATA_TYPE_PACKET_ACKNOWLEDGEMENT;\n    case 7:\n    case \"DATA_TYPE_PACKET_RECEIPT_ABSENCE\":\n      return DataType.DATA_TYPE_PACKET_RECEIPT_ABSENCE;\n    case 8:\n    case \"DATA_TYPE_NEXT_SEQUENCE_RECV\":\n      return DataType.DATA_TYPE_NEXT_SEQUENCE_RECV;\n    case 9:\n    case \"DATA_TYPE_HEADER\":\n      return DataType.DATA_TYPE_HEADER;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return DataType.UNRECOGNIZED;\n  }\n}\nfunction dataTypeToJSON(object) {\n  switch (object) {\n    case DataType.DATA_TYPE_UNINITIALIZED_UNSPECIFIED:\n      return \"DATA_TYPE_UNINITIALIZED_UNSPECIFIED\";\n    case DataType.DATA_TYPE_CLIENT_STATE:\n      return \"DATA_TYPE_CLIENT_STATE\";\n    case DataType.DATA_TYPE_CONSENSUS_STATE:\n      return \"DATA_TYPE_CONSENSUS_STATE\";\n    case DataType.DATA_TYPE_CONNECTION_STATE:\n      return \"DATA_TYPE_CONNECTION_STATE\";\n    case DataType.DATA_TYPE_CHANNEL_STATE:\n      return \"DATA_TYPE_CHANNEL_STATE\";\n    case DataType.DATA_TYPE_PACKET_COMMITMENT:\n      return \"DATA_TYPE_PACKET_COMMITMENT\";\n    case DataType.DATA_TYPE_PACKET_ACKNOWLEDGEMENT:\n      return \"DATA_TYPE_PACKET_ACKNOWLEDGEMENT\";\n    case DataType.DATA_TYPE_PACKET_RECEIPT_ABSENCE:\n      return \"DATA_TYPE_PACKET_RECEIPT_ABSENCE\";\n    case DataType.DATA_TYPE_NEXT_SEQUENCE_RECV:\n      return \"DATA_TYPE_NEXT_SEQUENCE_RECV\";\n    case DataType.DATA_TYPE_HEADER:\n      return \"DATA_TYPE_HEADER\";\n    case DataType.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n/**\n * ClientState defines a solo machine client that tracks the current consensus\n * state and if the client is frozen.\n */\n\nfunction createBaseClientState() {\n  return {\n    sequence: _helpers.Long.UZERO,\n    frozenSequence: _helpers.Long.UZERO,\n    consensusState: ConsensusState.fromPartial({}),\n    allowUpdateAfterProposal: false\n  };\n}\nvar ClientState = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (!message.sequence.isZero()) {\n      writer.uint32(8).uint64(message.sequence);\n    }\n    if (!message.frozenSequence.isZero()) {\n      writer.uint32(16).uint64(message.frozenSequence);\n    }\n    if (message.consensusState !== undefined) {\n      ConsensusState.encode(message.consensusState, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.allowUpdateAfterProposal === true) {\n      writer.uint32(32).bool(message.allowUpdateAfterProposal);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseClientState();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.sequence = reader.uint64();\n          break;\n        case 2:\n          message.frozenSequence = reader.uint64();\n          break;\n        case 3:\n          message.consensusState = ConsensusState.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.allowUpdateAfterProposal = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$allowUpdateAf;\n    var message = createBaseClientState();\n    message.sequence = object.sequence !== undefined && object.sequence !== null ? _helpers.Long.fromValue(object.sequence) : _helpers.Long.UZERO;\n    message.frozenSequence = object.frozenSequence !== undefined && object.frozenSequence !== null ? _helpers.Long.fromValue(object.frozenSequence) : _helpers.Long.UZERO;\n    message.consensusState = object.consensusState !== undefined && object.consensusState !== null ? ConsensusState.fromPartial(object.consensusState) : undefined;\n    message.allowUpdateAfterProposal = (_object$allowUpdateAf = object.allowUpdateAfterProposal) !== null && _object$allowUpdateAf !== void 0 ? _object$allowUpdateAf : false;\n    return message;\n  }\n};\nexports.ClientState = ClientState;\nfunction createBaseConsensusState() {\n  return {\n    publicKey: undefined,\n    diversifier: \"\",\n    timestamp: _helpers.Long.UZERO\n  };\n}\nvar ConsensusState = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.publicKey !== undefined) {\n      _any.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.diversifier !== \"\") {\n      writer.uint32(18).string(message.diversifier);\n    }\n    if (!message.timestamp.isZero()) {\n      writer.uint32(24).uint64(message.timestamp);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseConsensusState();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.publicKey = _any.Any.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.diversifier = reader.string();\n          break;\n        case 3:\n          message.timestamp = reader.uint64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$diversifier;\n    var message = createBaseConsensusState();\n    message.publicKey = object.publicKey !== undefined && object.publicKey !== null ? _any.Any.fromPartial(object.publicKey) : undefined;\n    message.diversifier = (_object$diversifier = object.diversifier) !== null && _object$diversifier !== void 0 ? _object$diversifier : \"\";\n    message.timestamp = object.timestamp !== undefined && object.timestamp !== null ? _helpers.Long.fromValue(object.timestamp) : _helpers.Long.UZERO;\n    return message;\n  }\n};\nexports.ConsensusState = ConsensusState;\nfunction createBaseHeader() {\n  return {\n    sequence: _helpers.Long.UZERO,\n    timestamp: _helpers.Long.UZERO,\n    signature: new Uint8Array(),\n    newPublicKey: undefined,\n    newDiversifier: \"\"\n  };\n}\nvar Header = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (!message.sequence.isZero()) {\n      writer.uint32(8).uint64(message.sequence);\n    }\n    if (!message.timestamp.isZero()) {\n      writer.uint32(16).uint64(message.timestamp);\n    }\n    if (message.signature.length !== 0) {\n      writer.uint32(26).bytes(message.signature);\n    }\n    if (message.newPublicKey !== undefined) {\n      _any.Any.encode(message.newPublicKey, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.newDiversifier !== \"\") {\n      writer.uint32(42).string(message.newDiversifier);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseHeader();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.sequence = reader.uint64();\n          break;\n        case 2:\n          message.timestamp = reader.uint64();\n          break;\n        case 3:\n          message.signature = reader.bytes();\n          break;\n        case 4:\n          message.newPublicKey = _any.Any.decode(reader, reader.uint32());\n          break;\n        case 5:\n          message.newDiversifier = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$signature, _object$newDiversifie;\n    var message = createBaseHeader();\n    message.sequence = object.sequence !== undefined && object.sequence !== null ? _helpers.Long.fromValue(object.sequence) : _helpers.Long.UZERO;\n    message.timestamp = object.timestamp !== undefined && object.timestamp !== null ? _helpers.Long.fromValue(object.timestamp) : _helpers.Long.UZERO;\n    message.signature = (_object$signature = object.signature) !== null && _object$signature !== void 0 ? _object$signature : new Uint8Array();\n    message.newPublicKey = object.newPublicKey !== undefined && object.newPublicKey !== null ? _any.Any.fromPartial(object.newPublicKey) : undefined;\n    message.newDiversifier = (_object$newDiversifie = object.newDiversifier) !== null && _object$newDiversifie !== void 0 ? _object$newDiversifie : \"\";\n    return message;\n  }\n};\nexports.Header = Header;\nfunction createBaseMisbehaviour() {\n  return {\n    clientId: \"\",\n    sequence: _helpers.Long.UZERO,\n    signatureOne: SignatureAndData.fromPartial({}),\n    signatureTwo: SignatureAndData.fromPartial({})\n  };\n}\nvar Misbehaviour = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.clientId !== \"\") {\n      writer.uint32(10).string(message.clientId);\n    }\n    if (!message.sequence.isZero()) {\n      writer.uint32(16).uint64(message.sequence);\n    }\n    if (message.signatureOne !== undefined) {\n      SignatureAndData.encode(message.signatureOne, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.signatureTwo !== undefined) {\n      SignatureAndData.encode(message.signatureTwo, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMisbehaviour();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clientId = reader.string();\n          break;\n        case 2:\n          message.sequence = reader.uint64();\n          break;\n        case 3:\n          message.signatureOne = SignatureAndData.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.signatureTwo = SignatureAndData.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$clientId;\n    var message = createBaseMisbehaviour();\n    message.clientId = (_object$clientId = object.clientId) !== null && _object$clientId !== void 0 ? _object$clientId : \"\";\n    message.sequence = object.sequence !== undefined && object.sequence !== null ? _helpers.Long.fromValue(object.sequence) : _helpers.Long.UZERO;\n    message.signatureOne = object.signatureOne !== undefined && object.signatureOne !== null ? SignatureAndData.fromPartial(object.signatureOne) : undefined;\n    message.signatureTwo = object.signatureTwo !== undefined && object.signatureTwo !== null ? SignatureAndData.fromPartial(object.signatureTwo) : undefined;\n    return message;\n  }\n};\nexports.Misbehaviour = Misbehaviour;\nfunction createBaseSignatureAndData() {\n  return {\n    signature: new Uint8Array(),\n    dataType: 0,\n    data: new Uint8Array(),\n    timestamp: _helpers.Long.UZERO\n  };\n}\nvar SignatureAndData = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.signature.length !== 0) {\n      writer.uint32(10).bytes(message.signature);\n    }\n    if (message.dataType !== 0) {\n      writer.uint32(16).int32(message.dataType);\n    }\n    if (message.data.length !== 0) {\n      writer.uint32(26).bytes(message.data);\n    }\n    if (!message.timestamp.isZero()) {\n      writer.uint32(32).uint64(message.timestamp);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseSignatureAndData();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.signature = reader.bytes();\n          break;\n        case 2:\n          message.dataType = reader.int32();\n          break;\n        case 3:\n          message.data = reader.bytes();\n          break;\n        case 4:\n          message.timestamp = reader.uint64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$signature2, _object$dataType, _object$data;\n    var message = createBaseSignatureAndData();\n    message.signature = (_object$signature2 = object.signature) !== null && _object$signature2 !== void 0 ? _object$signature2 : new Uint8Array();\n    message.dataType = (_object$dataType = object.dataType) !== null && _object$dataType !== void 0 ? _object$dataType : 0;\n    message.data = (_object$data = object.data) !== null && _object$data !== void 0 ? _object$data : new Uint8Array();\n    message.timestamp = object.timestamp !== undefined && object.timestamp !== null ? _helpers.Long.fromValue(object.timestamp) : _helpers.Long.UZERO;\n    return message;\n  }\n};\nexports.SignatureAndData = SignatureAndData;\nfunction createBaseTimestampedSignatureData() {\n  return {\n    signatureData: new Uint8Array(),\n    timestamp: _helpers.Long.UZERO\n  };\n}\nvar TimestampedSignatureData = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.signatureData.length !== 0) {\n      writer.uint32(10).bytes(message.signatureData);\n    }\n    if (!message.timestamp.isZero()) {\n      writer.uint32(16).uint64(message.timestamp);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseTimestampedSignatureData();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.signatureData = reader.bytes();\n          break;\n        case 2:\n          message.timestamp = reader.uint64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$signatureData;\n    var message = createBaseTimestampedSignatureData();\n    message.signatureData = (_object$signatureData = object.signatureData) !== null && _object$signatureData !== void 0 ? _object$signatureData : new Uint8Array();\n    message.timestamp = object.timestamp !== undefined && object.timestamp !== null ? _helpers.Long.fromValue(object.timestamp) : _helpers.Long.UZERO;\n    return message;\n  }\n};\nexports.TimestampedSignatureData = TimestampedSignatureData;\nfunction createBaseSignBytes() {\n  return {\n    sequence: _helpers.Long.UZERO,\n    timestamp: _helpers.Long.UZERO,\n    diversifier: \"\",\n    dataType: 0,\n    data: new Uint8Array()\n  };\n}\nvar SignBytes = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (!message.sequence.isZero()) {\n      writer.uint32(8).uint64(message.sequence);\n    }\n    if (!message.timestamp.isZero()) {\n      writer.uint32(16).uint64(message.timestamp);\n    }\n    if (message.diversifier !== \"\") {\n      writer.uint32(26).string(message.diversifier);\n    }\n    if (message.dataType !== 0) {\n      writer.uint32(32).int32(message.dataType);\n    }\n    if (message.data.length !== 0) {\n      writer.uint32(42).bytes(message.data);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseSignBytes();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.sequence = reader.uint64();\n          break;\n        case 2:\n          message.timestamp = reader.uint64();\n          break;\n        case 3:\n          message.diversifier = reader.string();\n          break;\n        case 4:\n          message.dataType = reader.int32();\n          break;\n        case 5:\n          message.data = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$diversifier2, _object$dataType2, _object$data2;\n    var message = createBaseSignBytes();\n    message.sequence = object.sequence !== undefined && object.sequence !== null ? _helpers.Long.fromValue(object.sequence) : _helpers.Long.UZERO;\n    message.timestamp = object.timestamp !== undefined && object.timestamp !== null ? _helpers.Long.fromValue(object.timestamp) : _helpers.Long.UZERO;\n    message.diversifier = (_object$diversifier2 = object.diversifier) !== null && _object$diversifier2 !== void 0 ? _object$diversifier2 : \"\";\n    message.dataType = (_object$dataType2 = object.dataType) !== null && _object$dataType2 !== void 0 ? _object$dataType2 : 0;\n    message.data = (_object$data2 = object.data) !== null && _object$data2 !== void 0 ? _object$data2 : new Uint8Array();\n    return message;\n  }\n};\nexports.SignBytes = SignBytes;\nfunction createBaseHeaderData() {\n  return {\n    newPubKey: undefined,\n    newDiversifier: \"\"\n  };\n}\nvar HeaderData = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.newPubKey !== undefined) {\n      _any.Any.encode(message.newPubKey, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.newDiversifier !== \"\") {\n      writer.uint32(18).string(message.newDiversifier);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseHeaderData();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.newPubKey = _any.Any.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.newDiversifier = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$newDiversifie2;\n    var message = createBaseHeaderData();\n    message.newPubKey = object.newPubKey !== undefined && object.newPubKey !== null ? _any.Any.fromPartial(object.newPubKey) : undefined;\n    message.newDiversifier = (_object$newDiversifie2 = object.newDiversifier) !== null && _object$newDiversifie2 !== void 0 ? _object$newDiversifie2 : \"\";\n    return message;\n  }\n};\nexports.HeaderData = HeaderData;\nfunction createBaseClientStateData() {\n  return {\n    path: new Uint8Array(),\n    clientState: undefined\n  };\n}\nvar ClientStateData = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.path.length !== 0) {\n      writer.uint32(10).bytes(message.path);\n    }\n    if (message.clientState !== undefined) {\n      _any.Any.encode(message.clientState, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseClientStateData();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.path = reader.bytes();\n          break;\n        case 2:\n          message.clientState = _any.Any.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$path;\n    var message = createBaseClientStateData();\n    message.path = (_object$path = object.path) !== null && _object$path !== void 0 ? _object$path : new Uint8Array();\n    message.clientState = object.clientState !== undefined && object.clientState !== null ? _any.Any.fromPartial(object.clientState) : undefined;\n    return message;\n  }\n};\nexports.ClientStateData = ClientStateData;\nfunction createBaseConsensusStateData() {\n  return {\n    path: new Uint8Array(),\n    consensusState: undefined\n  };\n}\nvar ConsensusStateData = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.path.length !== 0) {\n      writer.uint32(10).bytes(message.path);\n    }\n    if (message.consensusState !== undefined) {\n      _any.Any.encode(message.consensusState, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseConsensusStateData();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.path = reader.bytes();\n          break;\n        case 2:\n          message.consensusState = _any.Any.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$path2;\n    var message = createBaseConsensusStateData();\n    message.path = (_object$path2 = object.path) !== null && _object$path2 !== void 0 ? _object$path2 : new Uint8Array();\n    message.consensusState = object.consensusState !== undefined && object.consensusState !== null ? _any.Any.fromPartial(object.consensusState) : undefined;\n    return message;\n  }\n};\nexports.ConsensusStateData = ConsensusStateData;\nfunction createBaseConnectionStateData() {\n  return {\n    path: new Uint8Array(),\n    connection: _connection.ConnectionEnd.fromPartial({})\n  };\n}\nvar ConnectionStateData = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.path.length !== 0) {\n      writer.uint32(10).bytes(message.path);\n    }\n    if (message.connection !== undefined) {\n      _connection.ConnectionEnd.encode(message.connection, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseConnectionStateData();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.path = reader.bytes();\n          break;\n        case 2:\n          message.connection = _connection.ConnectionEnd.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$path3;\n    var message = createBaseConnectionStateData();\n    message.path = (_object$path3 = object.path) !== null && _object$path3 !== void 0 ? _object$path3 : new Uint8Array();\n    message.connection = object.connection !== undefined && object.connection !== null ? _connection.ConnectionEnd.fromPartial(object.connection) : undefined;\n    return message;\n  }\n};\nexports.ConnectionStateData = ConnectionStateData;\nfunction createBaseChannelStateData() {\n  return {\n    path: new Uint8Array(),\n    channel: _channel.Channel.fromPartial({})\n  };\n}\nvar ChannelStateData = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.path.length !== 0) {\n      writer.uint32(10).bytes(message.path);\n    }\n    if (message.channel !== undefined) {\n      _channel.Channel.encode(message.channel, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseChannelStateData();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.path = reader.bytes();\n          break;\n        case 2:\n          message.channel = _channel.Channel.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$path4;\n    var message = createBaseChannelStateData();\n    message.path = (_object$path4 = object.path) !== null && _object$path4 !== void 0 ? _object$path4 : new Uint8Array();\n    message.channel = object.channel !== undefined && object.channel !== null ? _channel.Channel.fromPartial(object.channel) : undefined;\n    return message;\n  }\n};\nexports.ChannelStateData = ChannelStateData;\nfunction createBasePacketCommitmentData() {\n  return {\n    path: new Uint8Array(),\n    commitment: new Uint8Array()\n  };\n}\nvar PacketCommitmentData = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.path.length !== 0) {\n      writer.uint32(10).bytes(message.path);\n    }\n    if (message.commitment.length !== 0) {\n      writer.uint32(18).bytes(message.commitment);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBasePacketCommitmentData();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.path = reader.bytes();\n          break;\n        case 2:\n          message.commitment = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$path5, _object$commitment;\n    var message = createBasePacketCommitmentData();\n    message.path = (_object$path5 = object.path) !== null && _object$path5 !== void 0 ? _object$path5 : new Uint8Array();\n    message.commitment = (_object$commitment = object.commitment) !== null && _object$commitment !== void 0 ? _object$commitment : new Uint8Array();\n    return message;\n  }\n};\nexports.PacketCommitmentData = PacketCommitmentData;\nfunction createBasePacketAcknowledgementData() {\n  return {\n    path: new Uint8Array(),\n    acknowledgement: new Uint8Array()\n  };\n}\nvar PacketAcknowledgementData = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.path.length !== 0) {\n      writer.uint32(10).bytes(message.path);\n    }\n    if (message.acknowledgement.length !== 0) {\n      writer.uint32(18).bytes(message.acknowledgement);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBasePacketAcknowledgementData();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.path = reader.bytes();\n          break;\n        case 2:\n          message.acknowledgement = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$path6, _object$acknowledgeme;\n    var message = createBasePacketAcknowledgementData();\n    message.path = (_object$path6 = object.path) !== null && _object$path6 !== void 0 ? _object$path6 : new Uint8Array();\n    message.acknowledgement = (_object$acknowledgeme = object.acknowledgement) !== null && _object$acknowledgeme !== void 0 ? _object$acknowledgeme : new Uint8Array();\n    return message;\n  }\n};\nexports.PacketAcknowledgementData = PacketAcknowledgementData;\nfunction createBasePacketReceiptAbsenceData() {\n  return {\n    path: new Uint8Array()\n  };\n}\nvar PacketReceiptAbsenceData = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.path.length !== 0) {\n      writer.uint32(10).bytes(message.path);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBasePacketReceiptAbsenceData();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.path = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$path7;\n    var message = createBasePacketReceiptAbsenceData();\n    message.path = (_object$path7 = object.path) !== null && _object$path7 !== void 0 ? _object$path7 : new Uint8Array();\n    return message;\n  }\n};\nexports.PacketReceiptAbsenceData = PacketReceiptAbsenceData;\nfunction createBaseNextSequenceRecvData() {\n  return {\n    path: new Uint8Array(),\n    nextSeqRecv: _helpers.Long.UZERO\n  };\n}\nvar NextSequenceRecvData = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.path.length !== 0) {\n      writer.uint32(10).bytes(message.path);\n    }\n    if (!message.nextSeqRecv.isZero()) {\n      writer.uint32(16).uint64(message.nextSeqRecv);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseNextSequenceRecvData();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.path = reader.bytes();\n          break;\n        case 2:\n          message.nextSeqRecv = reader.uint64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$path8;\n    var message = createBaseNextSequenceRecvData();\n    message.path = (_object$path8 = object.path) !== null && _object$path8 !== void 0 ? _object$path8 : new Uint8Array();\n    message.nextSeqRecv = object.nextSeqRecv !== undefined && object.nextSeqRecv !== null ? _helpers.Long.fromValue(object.nextSeqRecv) : _helpers.Long.UZERO;\n    return message;\n  }\n};\nexports.NextSequenceRecvData = NextSequenceRecvData;","map":null,"metadata":{},"sourceType":"script"}