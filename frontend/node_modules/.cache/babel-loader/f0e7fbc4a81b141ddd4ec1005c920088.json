{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/linanqi/Hackathon/GameRoom/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/linanqi/Hackathon/GameRoom/frontend/node_modules/@babel/runtime/helpers/createClass\");\nvar _objectSpread = require(\"/Users/linanqi/Hackathon/GameRoom/frontend/node_modules/@babel/runtime/helpers/objectSpread\");\nvar _slicedToArray = require(\"/Users/linanqi/Hackathon/GameRoom/frontend/node_modules/@babel/runtime/helpers/slicedToArray\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Responses = exports.decodeValidatorInfo = exports.decodeValidatorGenesis = exports.decodeValidatorUpdate = exports.decodeEvent = void 0;\n/* eslint-disable @typescript-eslint/naming-convention */\nvar encoding_1 = require(\"@cosmjs/encoding\");\nvar utils_1 = require(\"@cosmjs/utils\");\nvar dates_1 = require(\"../../dates\");\nvar inthelpers_1 = require(\"../../inthelpers\");\nvar types_1 = require(\"../../types\");\nvar encodings_1 = require(\"../encodings\");\nvar hasher_1 = require(\"../hasher\");\nfunction _decodeAbciInfo(data) {\n  return {\n    data: data.data,\n    lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.last_block_height),\n    lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data.last_block_app_hash)\n  };\n}\nfunction decodeQueryProof(data) {\n  return {\n    ops: data.ops.map(function (op) {\n      return {\n        type: op.type,\n        key: (0, encoding_1.fromBase64)(op.key),\n        data: (0, encoding_1.fromBase64)(op.data)\n      };\n    })\n  };\n}\nfunction _decodeAbciQuery(data) {\n  var _a, _b, _c, _d;\n  return {\n    key: (0, encoding_1.fromBase64)((0, encodings_1.assertString)((_a = data.key) !== null && _a !== void 0 ? _a : \"\")),\n    value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)((_b = data.value) !== null && _b !== void 0 ? _b : \"\")),\n    proof: (0, encodings_1.may)(decodeQueryProof, data.proofOps),\n    height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.height),\n    code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.code),\n    codespace: (0, encodings_1.assertString)((_c = data.codespace) !== null && _c !== void 0 ? _c : \"\"),\n    index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.index),\n    log: data.log,\n    info: (0, encodings_1.assertString)((_d = data.info) !== null && _d !== void 0 ? _d : \"\")\n  };\n}\nfunction decodeAttribute(attribute) {\n  var _a;\n  return {\n    key: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(attribute.key)),\n    value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)((_a = attribute.value) !== null && _a !== void 0 ? _a : \"\"))\n  };\n}\nfunction decodeAttributes(attributes) {\n  return (0, encodings_1.assertArray)(attributes).map(decodeAttribute);\n}\nfunction decodeEvent(event) {\n  return {\n    type: event.type,\n    attributes: event.attributes ? decodeAttributes(event.attributes) : []\n  };\n}\nexports.decodeEvent = decodeEvent;\nfunction decodeEvents(events) {\n  return (0, encodings_1.assertArray)(events).map(decodeEvent);\n}\nfunction decodeTxData(data) {\n  var _a, _b, _c;\n  return {\n    code: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)((_a = data.code) !== null && _a !== void 0 ? _a : 0)),\n    codespace: data.codespace,\n    log: data.log,\n    data: (0, encodings_1.may)(encoding_1.fromBase64, data.data),\n    events: data.events ? decodeEvents(data.events) : [],\n    gasWanted: (0, inthelpers_1.apiToSmallInt)((_b = data.gas_wanted) !== null && _b !== void 0 ? _b : \"0\"),\n    gasUsed: (0, inthelpers_1.apiToSmallInt)((_c = data.gas_used) !== null && _c !== void 0 ? _c : \"0\")\n  };\n}\nfunction decodePubkey(data) {\n  if (\"Sum\" in data) {\n    // we don't need to check type because we're checking algorithm\n    var _Object$entries = Object.entries(data.Sum.value),\n      _Object$entries2 = _slicedToArray(_Object$entries, 1),\n      _Object$entries2$ = _slicedToArray(_Object$entries2[0], 2),\n      algorithm = _Object$entries2$[0],\n      value = _Object$entries2$[1];\n    (0, utils_1.assert)(algorithm === \"ed25519\" || algorithm === \"secp256k1\", \"unknown pubkey type: \".concat(algorithm));\n    return {\n      algorithm: algorithm,\n      data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(value))\n    };\n  } else {\n    switch (data.type) {\n      // go-amino special code\n      case \"tendermint/PubKeyEd25519\":\n        return {\n          algorithm: \"ed25519\",\n          data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))\n        };\n      case \"tendermint/PubKeySecp256k1\":\n        return {\n          algorithm: \"secp256k1\",\n          data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))\n        };\n      default:\n        throw new Error(\"unknown pubkey type: \".concat(data.type));\n    }\n  }\n}\n/**\n * Note: we do not parse block.time_iota_ms for now because of this CHANGELOG entry\n *\n * > Add time_iota_ms to block's consensus parameters (not exposed to the application)\n * https://github.com/tendermint/tendermint/blob/master/CHANGELOG.md#v0310\n */\nfunction decodeBlockParams(data) {\n  return {\n    maxBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_bytes)),\n    maxGas: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_gas))\n  };\n}\nfunction decodeEvidenceParams(data) {\n  return {\n    maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_num_blocks)),\n    maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_duration))\n  };\n}\nfunction decodeConsensusParams(data) {\n  return {\n    block: decodeBlockParams((0, encodings_1.assertObject)(data.block)),\n    evidence: decodeEvidenceParams((0, encodings_1.assertObject)(data.evidence))\n  };\n}\nfunction decodeValidatorUpdate(data) {\n  var _a;\n  return {\n    pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),\n    votingPower: (0, inthelpers_1.apiToBigInt)((_a = data.power) !== null && _a !== void 0 ? _a : \"0\")\n  };\n}\nexports.decodeValidatorUpdate = decodeValidatorUpdate;\nfunction _decodeBlockResults(data) {\n  return {\n    height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),\n    results: (data.txs_results || []).map(decodeTxData),\n    validatorUpdates: (data.validator_updates || []).map(decodeValidatorUpdate),\n    consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data.consensus_param_updates),\n    beginBlockEvents: decodeEvents(data.begin_block_events || []),\n    endBlockEvents: decodeEvents(data.end_block_events || [])\n  };\n}\nfunction decodeBlockId(data) {\n  return {\n    hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),\n    parts: {\n      total: (0, encodings_1.assertNotEmpty)(data.parts.total),\n      hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.parts.hash))\n    }\n  };\n}\nfunction decodeBlockVersion(data) {\n  var _a;\n  return {\n    block: (0, inthelpers_1.apiToSmallInt)(data.block),\n    app: (0, inthelpers_1.apiToSmallInt)((_a = data.app) !== null && _a !== void 0 ? _a : 0)\n  };\n}\nfunction decodeHeader(data) {\n  return {\n    version: decodeBlockVersion(data.version),\n    chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),\n    height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),\n    time: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.time)),\n    // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:\n    // { hash: '', parts: { total: 0, hash: '' } }\n    lastBlockId: data.last_block_id.hash ? decodeBlockId(data.last_block_id) : null,\n    lastCommitHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_commit_hash)),\n    dataHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.data_hash)),\n    validatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.validators_hash)),\n    nextValidatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.next_validators_hash)),\n    consensusHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.consensus_hash)),\n    appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),\n    lastResultsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_results_hash)),\n    evidenceHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.evidence_hash)),\n    proposerAddress: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.proposer_address))\n  };\n}\nfunction decodeBlockMeta(data) {\n  return {\n    blockId: decodeBlockId(data.block_id),\n    blockSize: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_size)),\n    header: decodeHeader(data.header),\n    numTxs: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.num_txs))\n  };\n}\nfunction _decodeBlockchain(data) {\n  return {\n    lastHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.last_height)),\n    blockMetas: (0, encodings_1.assertArray)(data.block_metas).map(decodeBlockMeta)\n  };\n}\nfunction _decodeBroadcastTxSync(data) {\n  return _objectSpread({}, decodeTxData(data), {\n    hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash))\n  });\n}\nfunction _decodeBroadcastTxCommit(data) {\n  return {\n    height: (0, inthelpers_1.apiToSmallInt)(data.height),\n    hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),\n    checkTx: decodeTxData((0, encodings_1.assertObject)(data.check_tx)),\n    deliverTx: (0, encodings_1.may)(decodeTxData, data.deliver_tx)\n  };\n}\nfunction decodeBlockIdFlag(blockIdFlag) {\n  (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);\n  return blockIdFlag;\n}\n/**\n * In some cases a timestamp is optional and set to the value 0 in Go.\n * This can lead to strings like \"0001-01-01T00:00:00Z\" (see https://github.com/cosmos/cosmjs/issues/704#issuecomment-797122415).\n * This decoder tries to clean up such encoding from the API and turn them\n * into undefined values.\n */\nfunction decodeOptionalTime(timestamp) {\n  var nonZeroTime = timestamp && !timestamp.startsWith(\"0001-01-01\");\n  return nonZeroTime ? (0, dates_1.fromRfc3339WithNanoseconds)(timestamp) : undefined;\n}\nfunction decodeCommitSignature(data) {\n  return {\n    blockIdFlag: decodeBlockIdFlag(data.block_id_flag),\n    validatorAddress: data.validator_address ? (0, encoding_1.fromHex)(data.validator_address) : undefined,\n    timestamp: decodeOptionalTime(data.timestamp),\n    signature: data.signature ? (0, encoding_1.fromBase64)(data.signature) : undefined\n  };\n}\nfunction decodeCommit(data) {\n  return {\n    blockId: decodeBlockId((0, encodings_1.assertObject)(data.block_id)),\n    height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),\n    round: (0, inthelpers_1.apiToSmallInt)(data.round),\n    signatures: (0, encodings_1.assertArray)(data.signatures).map(decodeCommitSignature)\n  };\n}\nfunction decodeCommitResponse(data) {\n  return {\n    canonical: (0, encodings_1.assertBoolean)(data.canonical),\n    header: decodeHeader(data.signed_header.header),\n    commit: decodeCommit(data.signed_header.commit)\n  };\n}\nfunction decodeValidatorGenesis(data) {\n  return {\n    address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),\n    pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),\n    votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.power))\n  };\n}\nexports.decodeValidatorGenesis = decodeValidatorGenesis;\nfunction _decodeGenesis(data) {\n  return {\n    genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.genesis_time)),\n    chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),\n    consensusParams: decodeConsensusParams(data.consensus_params),\n    validators: data.validators ? (0, encodings_1.assertArray)(data.validators).map(decodeValidatorGenesis) : [],\n    appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),\n    appState: data.app_state\n  };\n}\nfunction decodeValidatorInfo(data) {\n  return {\n    pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),\n    votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.voting_power)),\n    address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),\n    proposerPriority: data.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data.proposer_priority) : undefined\n  };\n}\nexports.decodeValidatorInfo = decodeValidatorInfo;\nfunction decodeNodeInfo(data) {\n  return {\n    id: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.id)),\n    listenAddr: (0, encodings_1.assertNotEmpty)(data.listen_addr),\n    network: (0, encodings_1.assertNotEmpty)(data.network),\n    version: (0, encodings_1.assertString)(data.version),\n    channels: (0, encodings_1.assertNotEmpty)(data.channels),\n    moniker: (0, encodings_1.assertNotEmpty)(data.moniker),\n    other: (0, encodings_1.dictionaryToStringMap)(data.other),\n    protocolVersion: {\n      app: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.app)),\n      block: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.block)),\n      p2p: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.p2p))\n    }\n  };\n}\nfunction decodeSyncInfo(data) {\n  return {\n    latestBlockHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_block_hash)),\n    latestAppHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_app_hash)),\n    latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.latest_block_time)),\n    latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.latest_block_height)),\n    catchingUp: (0, encodings_1.assertBoolean)(data.catching_up)\n  };\n}\nfunction _decodeStatus(data) {\n  return {\n    nodeInfo: decodeNodeInfo(data.node_info),\n    syncInfo: decodeSyncInfo(data.sync_info),\n    validatorInfo: decodeValidatorInfo(data.validator_info)\n  };\n}\nfunction decodeTxProof(data) {\n  return {\n    data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.data)),\n    rootHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.root_hash)),\n    proof: {\n      total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.total)),\n      index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.index)),\n      leafHash: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.proof.leaf_hash)),\n      aunts: (0, encodings_1.assertArray)(data.proof.aunts).map(encoding_1.fromBase64)\n    }\n  };\n}\nfunction decodeTxResponse(data) {\n  return {\n    tx: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx)),\n    result: decodeTxData((0, encodings_1.assertObject)(data.tx_result)),\n    height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),\n    index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.index)),\n    hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),\n    proof: (0, encodings_1.may)(decodeTxProof, data.proof)\n  };\n}\nfunction _decodeTxSearch(data) {\n  return {\n    totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),\n    txs: (0, encodings_1.assertArray)(data.txs).map(decodeTxResponse)\n  };\n}\nfunction _decodeTxEvent(data) {\n  var tx = (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx));\n  return {\n    tx: tx,\n    hash: (0, hasher_1.hashTx)(tx),\n    result: decodeTxData(data.result),\n    height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),\n    index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.index)\n  };\n}\nfunction _decodeValidators(data) {\n  return {\n    blockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_height)),\n    validators: (0, encodings_1.assertArray)(data.validators).map(decodeValidatorInfo),\n    count: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.count)),\n    total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total))\n  };\n}\nfunction decodeBlock(data) {\n  var _a, _b;\n  return {\n    header: decodeHeader((0, encodings_1.assertObject)(data.header)),\n    // For the block at height 1, last commit is not set. This is represented in an empty object like this:\n    // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }\n    lastCommit: data.last_commit.block_id.hash ? decodeCommit((0, encodings_1.assertObject)(data.last_commit)) : null,\n    txs: data.data.txs ? (0, encodings_1.assertArray)(data.data.txs).map(encoding_1.fromBase64) : [],\n    // Lift up .evidence.evidence to just .evidence\n    // See https://github.com/tendermint/tendermint/issues/7697\n    evidence: (_b = (_a = data.evidence) === null || _a === void 0 ? void 0 : _a.evidence) !== null && _b !== void 0 ? _b : []\n  };\n}\nfunction decodeBlockResponse(data) {\n  return {\n    blockId: decodeBlockId(data.block_id),\n    block: decodeBlock(data.block)\n  };\n}\nfunction _decodeBlockSearch(data) {\n  return {\n    totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),\n    blocks: (0, encodings_1.assertArray)(data.blocks).map(decodeBlockResponse)\n  };\n}\nfunction _decodeNumUnconfirmedTxs(data) {\n  return {\n    total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total)),\n    totalBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_bytes))\n  };\n}\nvar Responses = /*#__PURE__*/function () {\n  function Responses() {\n    _classCallCheck(this, Responses);\n  }\n  _createClass(Responses, null, [{\n    key: \"decodeAbciInfo\",\n    value: function decodeAbciInfo(response) {\n      return _decodeAbciInfo((0, encodings_1.assertObject)(response.result.response));\n    }\n  }, {\n    key: \"decodeAbciQuery\",\n    value: function decodeAbciQuery(response) {\n      return _decodeAbciQuery((0, encodings_1.assertObject)(response.result.response));\n    }\n  }, {\n    key: \"decodeBlock\",\n    value: function decodeBlock(response) {\n      return decodeBlockResponse(response.result);\n    }\n  }, {\n    key: \"decodeBlockResults\",\n    value: function decodeBlockResults(response) {\n      return _decodeBlockResults(response.result);\n    }\n  }, {\n    key: \"decodeBlockSearch\",\n    value: function decodeBlockSearch(response) {\n      return _decodeBlockSearch(response.result);\n    }\n  }, {\n    key: \"decodeBlockchain\",\n    value: function decodeBlockchain(response) {\n      return _decodeBlockchain(response.result);\n    }\n  }, {\n    key: \"decodeBroadcastTxSync\",\n    value: function decodeBroadcastTxSync(response) {\n      return _decodeBroadcastTxSync(response.result);\n    }\n  }, {\n    key: \"decodeBroadcastTxAsync\",\n    value: function decodeBroadcastTxAsync(response) {\n      return Responses.decodeBroadcastTxSync(response);\n    }\n  }, {\n    key: \"decodeBroadcastTxCommit\",\n    value: function decodeBroadcastTxCommit(response) {\n      return _decodeBroadcastTxCommit(response.result);\n    }\n  }, {\n    key: \"decodeCommit\",\n    value: function decodeCommit(response) {\n      return decodeCommitResponse(response.result);\n    }\n  }, {\n    key: \"decodeGenesis\",\n    value: function decodeGenesis(response) {\n      return _decodeGenesis((0, encodings_1.assertObject)(response.result.genesis));\n    }\n  }, {\n    key: \"decodeHealth\",\n    value: function decodeHealth() {\n      return null;\n    }\n  }, {\n    key: \"decodeNumUnconfirmedTxs\",\n    value: function decodeNumUnconfirmedTxs(response) {\n      return _decodeNumUnconfirmedTxs(response.result);\n    }\n  }, {\n    key: \"decodeStatus\",\n    value: function decodeStatus(response) {\n      return _decodeStatus(response.result);\n    }\n  }, {\n    key: \"decodeNewBlockEvent\",\n    value: function decodeNewBlockEvent(event) {\n      return decodeBlock(event.data.value.block);\n    }\n  }, {\n    key: \"decodeNewBlockHeaderEvent\",\n    value: function decodeNewBlockHeaderEvent(event) {\n      return decodeHeader(event.data.value.header);\n    }\n  }, {\n    key: \"decodeTxEvent\",\n    value: function decodeTxEvent(event) {\n      return _decodeTxEvent(event.data.value.TxResult);\n    }\n  }, {\n    key: \"decodeTx\",\n    value: function decodeTx(response) {\n      return decodeTxResponse(response.result);\n    }\n  }, {\n    key: \"decodeTxSearch\",\n    value: function decodeTxSearch(response) {\n      return _decodeTxSearch(response.result);\n    }\n  }, {\n    key: \"decodeValidators\",\n    value: function decodeValidators(response) {\n      return _decodeValidators(response.result);\n    }\n  }]);\n  return Responses;\n}();\nexports.Responses = Responses;","map":null,"metadata":{},"sourceType":"script"}