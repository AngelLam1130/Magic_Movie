{"ast":null,"code":"\"use strict\";\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Vote = exports.TxProof = exports.SignedMsgTypeSDKType = exports.SignedMsgType = exports.SignedHeader = exports.Proposal = exports.PartSetHeader = exports.Part = exports.LightBlock = exports.Header = exports.Data = exports.CommitSig = exports.Commit = exports.BlockMeta = exports.BlockIDFlagSDKType = exports.BlockIDFlag = exports.BlockID = void 0;\nexports.blockIDFlagFromJSON = blockIDFlagFromJSON;\nexports.blockIDFlagToJSON = blockIDFlagToJSON;\nexports.signedMsgTypeFromJSON = signedMsgTypeFromJSON;\nexports.signedMsgTypeToJSON = signedMsgTypeToJSON;\nvar _proof = require(\"../crypto/proof\");\nvar _types = require(\"../version/types\");\nvar _timestamp = require(\"../../google/protobuf/timestamp\");\nvar _validator = require(\"./validator\");\nvar _helpers = require(\"../../helpers\");\nvar _m0 = _interopRequireWildcard(require(\"protobufjs/minimal\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj[\"default\"] = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\n/** BlockIdFlag indicates which BlcokID the signature is for */\nvar BlockIDFlag;\nexports.BlockIDFlag = BlockIDFlag;\n(function (BlockIDFlag) {\n  BlockIDFlag[BlockIDFlag[\"BLOCK_ID_FLAG_UNKNOWN\"] = 0] = \"BLOCK_ID_FLAG_UNKNOWN\";\n  BlockIDFlag[BlockIDFlag[\"BLOCK_ID_FLAG_ABSENT\"] = 1] = \"BLOCK_ID_FLAG_ABSENT\";\n  BlockIDFlag[BlockIDFlag[\"BLOCK_ID_FLAG_COMMIT\"] = 2] = \"BLOCK_ID_FLAG_COMMIT\";\n  BlockIDFlag[BlockIDFlag[\"BLOCK_ID_FLAG_NIL\"] = 3] = \"BLOCK_ID_FLAG_NIL\";\n  BlockIDFlag[BlockIDFlag[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(BlockIDFlag || (exports.BlockIDFlag = BlockIDFlag = {}));\nvar BlockIDFlagSDKType = BlockIDFlag;\nexports.BlockIDFlagSDKType = BlockIDFlagSDKType;\nfunction blockIDFlagFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"BLOCK_ID_FLAG_UNKNOWN\":\n      return BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN;\n    case 1:\n    case \"BLOCK_ID_FLAG_ABSENT\":\n      return BlockIDFlag.BLOCK_ID_FLAG_ABSENT;\n    case 2:\n    case \"BLOCK_ID_FLAG_COMMIT\":\n      return BlockIDFlag.BLOCK_ID_FLAG_COMMIT;\n    case 3:\n    case \"BLOCK_ID_FLAG_NIL\":\n      return BlockIDFlag.BLOCK_ID_FLAG_NIL;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return BlockIDFlag.UNRECOGNIZED;\n  }\n}\nfunction blockIDFlagToJSON(object) {\n  switch (object) {\n    case BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN:\n      return \"BLOCK_ID_FLAG_UNKNOWN\";\n    case BlockIDFlag.BLOCK_ID_FLAG_ABSENT:\n      return \"BLOCK_ID_FLAG_ABSENT\";\n    case BlockIDFlag.BLOCK_ID_FLAG_COMMIT:\n      return \"BLOCK_ID_FLAG_COMMIT\";\n    case BlockIDFlag.BLOCK_ID_FLAG_NIL:\n      return \"BLOCK_ID_FLAG_NIL\";\n    case BlockIDFlag.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n/** SignedMsgType is a type of signed message in the consensus. */\nvar SignedMsgType;\nexports.SignedMsgType = SignedMsgType;\n(function (SignedMsgType) {\n  SignedMsgType[SignedMsgType[\"SIGNED_MSG_TYPE_UNKNOWN\"] = 0] = \"SIGNED_MSG_TYPE_UNKNOWN\";\n  SignedMsgType[SignedMsgType[\"SIGNED_MSG_TYPE_PREVOTE\"] = 1] = \"SIGNED_MSG_TYPE_PREVOTE\";\n  SignedMsgType[SignedMsgType[\"SIGNED_MSG_TYPE_PRECOMMIT\"] = 2] = \"SIGNED_MSG_TYPE_PRECOMMIT\";\n  SignedMsgType[SignedMsgType[\"SIGNED_MSG_TYPE_PROPOSAL\"] = 32] = \"SIGNED_MSG_TYPE_PROPOSAL\";\n  SignedMsgType[SignedMsgType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(SignedMsgType || (exports.SignedMsgType = SignedMsgType = {}));\nvar SignedMsgTypeSDKType = SignedMsgType;\nexports.SignedMsgTypeSDKType = SignedMsgTypeSDKType;\nfunction signedMsgTypeFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"SIGNED_MSG_TYPE_UNKNOWN\":\n      return SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN;\n    case 1:\n    case \"SIGNED_MSG_TYPE_PREVOTE\":\n      return SignedMsgType.SIGNED_MSG_TYPE_PREVOTE;\n    case 2:\n    case \"SIGNED_MSG_TYPE_PRECOMMIT\":\n      return SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT;\n    case 32:\n    case \"SIGNED_MSG_TYPE_PROPOSAL\":\n      return SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return SignedMsgType.UNRECOGNIZED;\n  }\n}\nfunction signedMsgTypeToJSON(object) {\n  switch (object) {\n    case SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN:\n      return \"SIGNED_MSG_TYPE_UNKNOWN\";\n    case SignedMsgType.SIGNED_MSG_TYPE_PREVOTE:\n      return \"SIGNED_MSG_TYPE_PREVOTE\";\n    case SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT:\n      return \"SIGNED_MSG_TYPE_PRECOMMIT\";\n    case SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL:\n      return \"SIGNED_MSG_TYPE_PROPOSAL\";\n    case SignedMsgType.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n/** PartsetHeader */\n\nfunction createBasePartSetHeader() {\n  return {\n    total: 0,\n    hash: new Uint8Array()\n  };\n}\nvar PartSetHeader = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.total !== 0) {\n      writer.uint32(8).uint32(message.total);\n    }\n    if (message.hash.length !== 0) {\n      writer.uint32(18).bytes(message.hash);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBasePartSetHeader();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.total = reader.uint32();\n          break;\n        case 2:\n          message.hash = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$total, _object$hash;\n    var message = createBasePartSetHeader();\n    message.total = (_object$total = object.total) !== null && _object$total !== void 0 ? _object$total : 0;\n    message.hash = (_object$hash = object.hash) !== null && _object$hash !== void 0 ? _object$hash : new Uint8Array();\n    return message;\n  }\n};\nexports.PartSetHeader = PartSetHeader;\nfunction createBasePart() {\n  return {\n    index: 0,\n    bytes: new Uint8Array(),\n    proof: _proof.Proof.fromPartial({})\n  };\n}\nvar Part = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.index !== 0) {\n      writer.uint32(8).uint32(message.index);\n    }\n    if (message.bytes.length !== 0) {\n      writer.uint32(18).bytes(message.bytes);\n    }\n    if (message.proof !== undefined) {\n      _proof.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBasePart();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.index = reader.uint32();\n          break;\n        case 2:\n          message.bytes = reader.bytes();\n          break;\n        case 3:\n          message.proof = _proof.Proof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$index, _object$bytes;\n    var message = createBasePart();\n    message.index = (_object$index = object.index) !== null && _object$index !== void 0 ? _object$index : 0;\n    message.bytes = (_object$bytes = object.bytes) !== null && _object$bytes !== void 0 ? _object$bytes : new Uint8Array();\n    message.proof = object.proof !== undefined && object.proof !== null ? _proof.Proof.fromPartial(object.proof) : undefined;\n    return message;\n  }\n};\nexports.Part = Part;\nfunction createBaseBlockID() {\n  return {\n    hash: new Uint8Array(),\n    partSetHeader: PartSetHeader.fromPartial({})\n  };\n}\nvar BlockID = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.hash.length !== 0) {\n      writer.uint32(10).bytes(message.hash);\n    }\n    if (message.partSetHeader !== undefined) {\n      PartSetHeader.encode(message.partSetHeader, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseBlockID();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.bytes();\n          break;\n        case 2:\n          message.partSetHeader = PartSetHeader.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$hash2;\n    var message = createBaseBlockID();\n    message.hash = (_object$hash2 = object.hash) !== null && _object$hash2 !== void 0 ? _object$hash2 : new Uint8Array();\n    message.partSetHeader = object.partSetHeader !== undefined && object.partSetHeader !== null ? PartSetHeader.fromPartial(object.partSetHeader) : undefined;\n    return message;\n  }\n};\nexports.BlockID = BlockID;\nfunction createBaseHeader() {\n  return {\n    version: _types.Consensus.fromPartial({}),\n    chainId: \"\",\n    height: _helpers.Long.ZERO,\n    time: undefined,\n    lastBlockId: BlockID.fromPartial({}),\n    lastCommitHash: new Uint8Array(),\n    dataHash: new Uint8Array(),\n    validatorsHash: new Uint8Array(),\n    nextValidatorsHash: new Uint8Array(),\n    consensusHash: new Uint8Array(),\n    appHash: new Uint8Array(),\n    lastResultsHash: new Uint8Array(),\n    evidenceHash: new Uint8Array(),\n    proposerAddress: new Uint8Array()\n  };\n}\nvar Header = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.version !== undefined) {\n      _types.Consensus.encode(message.version, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.chainId !== \"\") {\n      writer.uint32(18).string(message.chainId);\n    }\n    if (!message.height.isZero()) {\n      writer.uint32(24).int64(message.height);\n    }\n    if (message.time !== undefined) {\n      _timestamp.Timestamp.encode((0, _helpers.toTimestamp)(message.time), writer.uint32(34).fork()).ldelim();\n    }\n    if (message.lastBlockId !== undefined) {\n      BlockID.encode(message.lastBlockId, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.lastCommitHash.length !== 0) {\n      writer.uint32(50).bytes(message.lastCommitHash);\n    }\n    if (message.dataHash.length !== 0) {\n      writer.uint32(58).bytes(message.dataHash);\n    }\n    if (message.validatorsHash.length !== 0) {\n      writer.uint32(66).bytes(message.validatorsHash);\n    }\n    if (message.nextValidatorsHash.length !== 0) {\n      writer.uint32(74).bytes(message.nextValidatorsHash);\n    }\n    if (message.consensusHash.length !== 0) {\n      writer.uint32(82).bytes(message.consensusHash);\n    }\n    if (message.appHash.length !== 0) {\n      writer.uint32(90).bytes(message.appHash);\n    }\n    if (message.lastResultsHash.length !== 0) {\n      writer.uint32(98).bytes(message.lastResultsHash);\n    }\n    if (message.evidenceHash.length !== 0) {\n      writer.uint32(106).bytes(message.evidenceHash);\n    }\n    if (message.proposerAddress.length !== 0) {\n      writer.uint32(114).bytes(message.proposerAddress);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseHeader();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.version = _types.Consensus.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.chainId = reader.string();\n          break;\n        case 3:\n          message.height = reader.int64();\n          break;\n        case 4:\n          message.time = (0, _helpers.fromTimestamp)(_timestamp.Timestamp.decode(reader, reader.uint32()));\n          break;\n        case 5:\n          message.lastBlockId = BlockID.decode(reader, reader.uint32());\n          break;\n        case 6:\n          message.lastCommitHash = reader.bytes();\n          break;\n        case 7:\n          message.dataHash = reader.bytes();\n          break;\n        case 8:\n          message.validatorsHash = reader.bytes();\n          break;\n        case 9:\n          message.nextValidatorsHash = reader.bytes();\n          break;\n        case 10:\n          message.consensusHash = reader.bytes();\n          break;\n        case 11:\n          message.appHash = reader.bytes();\n          break;\n        case 12:\n          message.lastResultsHash = reader.bytes();\n          break;\n        case 13:\n          message.evidenceHash = reader.bytes();\n          break;\n        case 14:\n          message.proposerAddress = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$chainId, _object$time, _object$lastCommitHas, _object$dataHash, _object$validatorsHas, _object$nextValidator, _object$consensusHash, _object$appHash, _object$lastResultsHa, _object$evidenceHash, _object$proposerAddre;\n    var message = createBaseHeader();\n    message.version = object.version !== undefined && object.version !== null ? _types.Consensus.fromPartial(object.version) : undefined;\n    message.chainId = (_object$chainId = object.chainId) !== null && _object$chainId !== void 0 ? _object$chainId : \"\";\n    message.height = object.height !== undefined && object.height !== null ? _helpers.Long.fromValue(object.height) : _helpers.Long.ZERO;\n    message.time = (_object$time = object.time) !== null && _object$time !== void 0 ? _object$time : undefined;\n    message.lastBlockId = object.lastBlockId !== undefined && object.lastBlockId !== null ? BlockID.fromPartial(object.lastBlockId) : undefined;\n    message.lastCommitHash = (_object$lastCommitHas = object.lastCommitHash) !== null && _object$lastCommitHas !== void 0 ? _object$lastCommitHas : new Uint8Array();\n    message.dataHash = (_object$dataHash = object.dataHash) !== null && _object$dataHash !== void 0 ? _object$dataHash : new Uint8Array();\n    message.validatorsHash = (_object$validatorsHas = object.validatorsHash) !== null && _object$validatorsHas !== void 0 ? _object$validatorsHas : new Uint8Array();\n    message.nextValidatorsHash = (_object$nextValidator = object.nextValidatorsHash) !== null && _object$nextValidator !== void 0 ? _object$nextValidator : new Uint8Array();\n    message.consensusHash = (_object$consensusHash = object.consensusHash) !== null && _object$consensusHash !== void 0 ? _object$consensusHash : new Uint8Array();\n    message.appHash = (_object$appHash = object.appHash) !== null && _object$appHash !== void 0 ? _object$appHash : new Uint8Array();\n    message.lastResultsHash = (_object$lastResultsHa = object.lastResultsHash) !== null && _object$lastResultsHa !== void 0 ? _object$lastResultsHa : new Uint8Array();\n    message.evidenceHash = (_object$evidenceHash = object.evidenceHash) !== null && _object$evidenceHash !== void 0 ? _object$evidenceHash : new Uint8Array();\n    message.proposerAddress = (_object$proposerAddre = object.proposerAddress) !== null && _object$proposerAddre !== void 0 ? _object$proposerAddre : new Uint8Array();\n    return message;\n  }\n};\nexports.Header = Header;\nfunction createBaseData() {\n  return {\n    txs: []\n  };\n}\nvar Data = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    var _iterator = _createForOfIteratorHelper(message.txs),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var v = _step.value;\n        writer.uint32(10).bytes(v);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseData();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.txs.push(reader.bytes());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$txs;\n    var message = createBaseData();\n    message.txs = ((_object$txs = object.txs) === null || _object$txs === void 0 ? void 0 : _object$txs.map(function (e) {\n      return e;\n    })) || [];\n    return message;\n  }\n};\nexports.Data = Data;\nfunction createBaseVote() {\n  return {\n    type: 0,\n    height: _helpers.Long.ZERO,\n    round: 0,\n    blockId: BlockID.fromPartial({}),\n    timestamp: undefined,\n    validatorAddress: new Uint8Array(),\n    validatorIndex: 0,\n    signature: new Uint8Array()\n  };\n}\nvar Vote = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.type !== 0) {\n      writer.uint32(8).int32(message.type);\n    }\n    if (!message.height.isZero()) {\n      writer.uint32(16).int64(message.height);\n    }\n    if (message.round !== 0) {\n      writer.uint32(24).int32(message.round);\n    }\n    if (message.blockId !== undefined) {\n      BlockID.encode(message.blockId, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.timestamp !== undefined) {\n      _timestamp.Timestamp.encode((0, _helpers.toTimestamp)(message.timestamp), writer.uint32(42).fork()).ldelim();\n    }\n    if (message.validatorAddress.length !== 0) {\n      writer.uint32(50).bytes(message.validatorAddress);\n    }\n    if (message.validatorIndex !== 0) {\n      writer.uint32(56).int32(message.validatorIndex);\n    }\n    if (message.signature.length !== 0) {\n      writer.uint32(66).bytes(message.signature);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseVote();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.int32();\n          break;\n        case 2:\n          message.height = reader.int64();\n          break;\n        case 3:\n          message.round = reader.int32();\n          break;\n        case 4:\n          message.blockId = BlockID.decode(reader, reader.uint32());\n          break;\n        case 5:\n          message.timestamp = (0, _helpers.fromTimestamp)(_timestamp.Timestamp.decode(reader, reader.uint32()));\n          break;\n        case 6:\n          message.validatorAddress = reader.bytes();\n          break;\n        case 7:\n          message.validatorIndex = reader.int32();\n          break;\n        case 8:\n          message.signature = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$type, _object$round, _object$timestamp, _object$validatorAddr, _object$validatorInde, _object$signature;\n    var message = createBaseVote();\n    message.type = (_object$type = object.type) !== null && _object$type !== void 0 ? _object$type : 0;\n    message.height = object.height !== undefined && object.height !== null ? _helpers.Long.fromValue(object.height) : _helpers.Long.ZERO;\n    message.round = (_object$round = object.round) !== null && _object$round !== void 0 ? _object$round : 0;\n    message.blockId = object.blockId !== undefined && object.blockId !== null ? BlockID.fromPartial(object.blockId) : undefined;\n    message.timestamp = (_object$timestamp = object.timestamp) !== null && _object$timestamp !== void 0 ? _object$timestamp : undefined;\n    message.validatorAddress = (_object$validatorAddr = object.validatorAddress) !== null && _object$validatorAddr !== void 0 ? _object$validatorAddr : new Uint8Array();\n    message.validatorIndex = (_object$validatorInde = object.validatorIndex) !== null && _object$validatorInde !== void 0 ? _object$validatorInde : 0;\n    message.signature = (_object$signature = object.signature) !== null && _object$signature !== void 0 ? _object$signature : new Uint8Array();\n    return message;\n  }\n};\nexports.Vote = Vote;\nfunction createBaseCommit() {\n  return {\n    height: _helpers.Long.ZERO,\n    round: 0,\n    blockId: BlockID.fromPartial({}),\n    signatures: []\n  };\n}\nvar Commit = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (!message.height.isZero()) {\n      writer.uint32(8).int64(message.height);\n    }\n    if (message.round !== 0) {\n      writer.uint32(16).int32(message.round);\n    }\n    if (message.blockId !== undefined) {\n      BlockID.encode(message.blockId, writer.uint32(26).fork()).ldelim();\n    }\n    var _iterator2 = _createForOfIteratorHelper(message.signatures),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var v = _step2.value;\n        CommitSig.encode(v, writer.uint32(34).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseCommit();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.height = reader.int64();\n          break;\n        case 2:\n          message.round = reader.int32();\n          break;\n        case 3:\n          message.blockId = BlockID.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.signatures.push(CommitSig.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$round2, _object$signatures;\n    var message = createBaseCommit();\n    message.height = object.height !== undefined && object.height !== null ? _helpers.Long.fromValue(object.height) : _helpers.Long.ZERO;\n    message.round = (_object$round2 = object.round) !== null && _object$round2 !== void 0 ? _object$round2 : 0;\n    message.blockId = object.blockId !== undefined && object.blockId !== null ? BlockID.fromPartial(object.blockId) : undefined;\n    message.signatures = ((_object$signatures = object.signatures) === null || _object$signatures === void 0 ? void 0 : _object$signatures.map(function (e) {\n      return CommitSig.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.Commit = Commit;\nfunction createBaseCommitSig() {\n  return {\n    blockIdFlag: 0,\n    validatorAddress: new Uint8Array(),\n    timestamp: undefined,\n    signature: new Uint8Array()\n  };\n}\nvar CommitSig = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.blockIdFlag !== 0) {\n      writer.uint32(8).int32(message.blockIdFlag);\n    }\n    if (message.validatorAddress.length !== 0) {\n      writer.uint32(18).bytes(message.validatorAddress);\n    }\n    if (message.timestamp !== undefined) {\n      _timestamp.Timestamp.encode((0, _helpers.toTimestamp)(message.timestamp), writer.uint32(26).fork()).ldelim();\n    }\n    if (message.signature.length !== 0) {\n      writer.uint32(34).bytes(message.signature);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseCommitSig();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.blockIdFlag = reader.int32();\n          break;\n        case 2:\n          message.validatorAddress = reader.bytes();\n          break;\n        case 3:\n          message.timestamp = (0, _helpers.fromTimestamp)(_timestamp.Timestamp.decode(reader, reader.uint32()));\n          break;\n        case 4:\n          message.signature = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$blockIdFlag, _object$validatorAddr2, _object$timestamp2, _object$signature2;\n    var message = createBaseCommitSig();\n    message.blockIdFlag = (_object$blockIdFlag = object.blockIdFlag) !== null && _object$blockIdFlag !== void 0 ? _object$blockIdFlag : 0;\n    message.validatorAddress = (_object$validatorAddr2 = object.validatorAddress) !== null && _object$validatorAddr2 !== void 0 ? _object$validatorAddr2 : new Uint8Array();\n    message.timestamp = (_object$timestamp2 = object.timestamp) !== null && _object$timestamp2 !== void 0 ? _object$timestamp2 : undefined;\n    message.signature = (_object$signature2 = object.signature) !== null && _object$signature2 !== void 0 ? _object$signature2 : new Uint8Array();\n    return message;\n  }\n};\nexports.CommitSig = CommitSig;\nfunction createBaseProposal() {\n  return {\n    type: 0,\n    height: _helpers.Long.ZERO,\n    round: 0,\n    polRound: 0,\n    blockId: BlockID.fromPartial({}),\n    timestamp: undefined,\n    signature: new Uint8Array()\n  };\n}\nvar Proposal = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.type !== 0) {\n      writer.uint32(8).int32(message.type);\n    }\n    if (!message.height.isZero()) {\n      writer.uint32(16).int64(message.height);\n    }\n    if (message.round !== 0) {\n      writer.uint32(24).int32(message.round);\n    }\n    if (message.polRound !== 0) {\n      writer.uint32(32).int32(message.polRound);\n    }\n    if (message.blockId !== undefined) {\n      BlockID.encode(message.blockId, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.timestamp !== undefined) {\n      _timestamp.Timestamp.encode((0, _helpers.toTimestamp)(message.timestamp), writer.uint32(50).fork()).ldelim();\n    }\n    if (message.signature.length !== 0) {\n      writer.uint32(58).bytes(message.signature);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseProposal();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.int32();\n          break;\n        case 2:\n          message.height = reader.int64();\n          break;\n        case 3:\n          message.round = reader.int32();\n          break;\n        case 4:\n          message.polRound = reader.int32();\n          break;\n        case 5:\n          message.blockId = BlockID.decode(reader, reader.uint32());\n          break;\n        case 6:\n          message.timestamp = (0, _helpers.fromTimestamp)(_timestamp.Timestamp.decode(reader, reader.uint32()));\n          break;\n        case 7:\n          message.signature = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$type2, _object$round3, _object$polRound, _object$timestamp3, _object$signature3;\n    var message = createBaseProposal();\n    message.type = (_object$type2 = object.type) !== null && _object$type2 !== void 0 ? _object$type2 : 0;\n    message.height = object.height !== undefined && object.height !== null ? _helpers.Long.fromValue(object.height) : _helpers.Long.ZERO;\n    message.round = (_object$round3 = object.round) !== null && _object$round3 !== void 0 ? _object$round3 : 0;\n    message.polRound = (_object$polRound = object.polRound) !== null && _object$polRound !== void 0 ? _object$polRound : 0;\n    message.blockId = object.blockId !== undefined && object.blockId !== null ? BlockID.fromPartial(object.blockId) : undefined;\n    message.timestamp = (_object$timestamp3 = object.timestamp) !== null && _object$timestamp3 !== void 0 ? _object$timestamp3 : undefined;\n    message.signature = (_object$signature3 = object.signature) !== null && _object$signature3 !== void 0 ? _object$signature3 : new Uint8Array();\n    return message;\n  }\n};\nexports.Proposal = Proposal;\nfunction createBaseSignedHeader() {\n  return {\n    header: Header.fromPartial({}),\n    commit: Commit.fromPartial({})\n  };\n}\nvar SignedHeader = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.header !== undefined) {\n      Header.encode(message.header, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.commit !== undefined) {\n      Commit.encode(message.commit, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseSignedHeader();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.header = Header.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.commit = Commit.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = createBaseSignedHeader();\n    message.header = object.header !== undefined && object.header !== null ? Header.fromPartial(object.header) : undefined;\n    message.commit = object.commit !== undefined && object.commit !== null ? Commit.fromPartial(object.commit) : undefined;\n    return message;\n  }\n};\nexports.SignedHeader = SignedHeader;\nfunction createBaseLightBlock() {\n  return {\n    signedHeader: SignedHeader.fromPartial({}),\n    validatorSet: _validator.ValidatorSet.fromPartial({})\n  };\n}\nvar LightBlock = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.signedHeader !== undefined) {\n      SignedHeader.encode(message.signedHeader, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.validatorSet !== undefined) {\n      _validator.ValidatorSet.encode(message.validatorSet, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseLightBlock();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.signedHeader = SignedHeader.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.validatorSet = _validator.ValidatorSet.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = createBaseLightBlock();\n    message.signedHeader = object.signedHeader !== undefined && object.signedHeader !== null ? SignedHeader.fromPartial(object.signedHeader) : undefined;\n    message.validatorSet = object.validatorSet !== undefined && object.validatorSet !== null ? _validator.ValidatorSet.fromPartial(object.validatorSet) : undefined;\n    return message;\n  }\n};\nexports.LightBlock = LightBlock;\nfunction createBaseBlockMeta() {\n  return {\n    blockId: BlockID.fromPartial({}),\n    blockSize: _helpers.Long.ZERO,\n    header: Header.fromPartial({}),\n    numTxs: _helpers.Long.ZERO\n  };\n}\nvar BlockMeta = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.blockId !== undefined) {\n      BlockID.encode(message.blockId, writer.uint32(10).fork()).ldelim();\n    }\n    if (!message.blockSize.isZero()) {\n      writer.uint32(16).int64(message.blockSize);\n    }\n    if (message.header !== undefined) {\n      Header.encode(message.header, writer.uint32(26).fork()).ldelim();\n    }\n    if (!message.numTxs.isZero()) {\n      writer.uint32(32).int64(message.numTxs);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseBlockMeta();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.blockId = BlockID.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.blockSize = reader.int64();\n          break;\n        case 3:\n          message.header = Header.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.numTxs = reader.int64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = createBaseBlockMeta();\n    message.blockId = object.blockId !== undefined && object.blockId !== null ? BlockID.fromPartial(object.blockId) : undefined;\n    message.blockSize = object.blockSize !== undefined && object.blockSize !== null ? _helpers.Long.fromValue(object.blockSize) : _helpers.Long.ZERO;\n    message.header = object.header !== undefined && object.header !== null ? Header.fromPartial(object.header) : undefined;\n    message.numTxs = object.numTxs !== undefined && object.numTxs !== null ? _helpers.Long.fromValue(object.numTxs) : _helpers.Long.ZERO;\n    return message;\n  }\n};\nexports.BlockMeta = BlockMeta;\nfunction createBaseTxProof() {\n  return {\n    rootHash: new Uint8Array(),\n    data: new Uint8Array(),\n    proof: _proof.Proof.fromPartial({})\n  };\n}\nvar TxProof = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.rootHash.length !== 0) {\n      writer.uint32(10).bytes(message.rootHash);\n    }\n    if (message.data.length !== 0) {\n      writer.uint32(18).bytes(message.data);\n    }\n    if (message.proof !== undefined) {\n      _proof.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseTxProof();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.rootHash = reader.bytes();\n          break;\n        case 2:\n          message.data = reader.bytes();\n          break;\n        case 3:\n          message.proof = _proof.Proof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$rootHash, _object$data;\n    var message = createBaseTxProof();\n    message.rootHash = (_object$rootHash = object.rootHash) !== null && _object$rootHash !== void 0 ? _object$rootHash : new Uint8Array();\n    message.data = (_object$data = object.data) !== null && _object$data !== void 0 ? _object$data : new Uint8Array();\n    message.proof = object.proof !== undefined && object.proof !== null ? _proof.Proof.fromPartial(object.proof) : undefined;\n    return message;\n  }\n};\nexports.TxProof = TxProof;","map":null,"metadata":{},"sourceType":"script"}