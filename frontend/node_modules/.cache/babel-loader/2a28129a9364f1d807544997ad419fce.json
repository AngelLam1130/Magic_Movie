{"ast":null,"code":"\"use strict\";\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UninterpretedOption_NamePart = exports.UninterpretedOption = exports.SourceCodeInfo_Location = exports.SourceCodeInfo = exports.ServiceOptions = exports.ServiceDescriptorProto = exports.OneofOptions = exports.OneofDescriptorProto = exports.MethodOptions_IdempotencyLevelSDKType = exports.MethodOptions_IdempotencyLevel = exports.MethodOptions = exports.MethodDescriptorProto = exports.MessageOptions = exports.GeneratedCodeInfo_Annotation = exports.GeneratedCodeInfo = exports.FileOptions_OptimizeModeSDKType = exports.FileOptions_OptimizeMode = exports.FileOptions = exports.FileDescriptorSet = exports.FileDescriptorProto = exports.FieldOptions_JSTypeSDKType = exports.FieldOptions_JSType = exports.FieldOptions_CTypeSDKType = exports.FieldOptions_CType = exports.FieldOptions = exports.FieldDescriptorProto_TypeSDKType = exports.FieldDescriptorProto_Type = exports.FieldDescriptorProto_LabelSDKType = exports.FieldDescriptorProto_Label = exports.FieldDescriptorProto = exports.ExtensionRangeOptions = exports.EnumValueOptions = exports.EnumValueDescriptorProto = exports.EnumOptions = exports.EnumDescriptorProto_EnumReservedRange = exports.EnumDescriptorProto = exports.DescriptorProto_ReservedRange = exports.DescriptorProto_ExtensionRange = exports.DescriptorProto = void 0;\nexports.fieldDescriptorProto_LabelFromJSON = fieldDescriptorProto_LabelFromJSON;\nexports.fieldDescriptorProto_LabelToJSON = fieldDescriptorProto_LabelToJSON;\nexports.fieldDescriptorProto_TypeFromJSON = fieldDescriptorProto_TypeFromJSON;\nexports.fieldDescriptorProto_TypeToJSON = fieldDescriptorProto_TypeToJSON;\nexports.fieldOptions_CTypeFromJSON = fieldOptions_CTypeFromJSON;\nexports.fieldOptions_CTypeToJSON = fieldOptions_CTypeToJSON;\nexports.fieldOptions_JSTypeFromJSON = fieldOptions_JSTypeFromJSON;\nexports.fieldOptions_JSTypeToJSON = fieldOptions_JSTypeToJSON;\nexports.fileOptions_OptimizeModeFromJSON = fileOptions_OptimizeModeFromJSON;\nexports.fileOptions_OptimizeModeToJSON = fileOptions_OptimizeModeToJSON;\nexports.methodOptions_IdempotencyLevelFromJSON = methodOptions_IdempotencyLevelFromJSON;\nexports.methodOptions_IdempotencyLevelToJSON = methodOptions_IdempotencyLevelToJSON;\nvar _helpers = require(\"../../helpers\");\nvar _m0 = _interopRequireWildcard(require(\"protobufjs/minimal\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj[\"default\"] = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nvar FieldDescriptorProto_Type;\nexports.FieldDescriptorProto_Type = FieldDescriptorProto_Type;\n(function (FieldDescriptorProto_Type) {\n  FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_DOUBLE\"] = 1] = \"TYPE_DOUBLE\";\n  FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_FLOAT\"] = 2] = \"TYPE_FLOAT\";\n  FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_INT64\"] = 3] = \"TYPE_INT64\";\n  FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_UINT64\"] = 4] = \"TYPE_UINT64\";\n  FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_INT32\"] = 5] = \"TYPE_INT32\";\n  FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_FIXED64\"] = 6] = \"TYPE_FIXED64\";\n  FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_FIXED32\"] = 7] = \"TYPE_FIXED32\";\n  FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_BOOL\"] = 8] = \"TYPE_BOOL\";\n  FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_STRING\"] = 9] = \"TYPE_STRING\";\n  FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_GROUP\"] = 10] = \"TYPE_GROUP\";\n  FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_MESSAGE\"] = 11] = \"TYPE_MESSAGE\";\n  FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_BYTES\"] = 12] = \"TYPE_BYTES\";\n  FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_UINT32\"] = 13] = \"TYPE_UINT32\";\n  FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_ENUM\"] = 14] = \"TYPE_ENUM\";\n  FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_SFIXED32\"] = 15] = \"TYPE_SFIXED32\";\n  FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_SFIXED64\"] = 16] = \"TYPE_SFIXED64\";\n  FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_SINT32\"] = 17] = \"TYPE_SINT32\";\n  FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_SINT64\"] = 18] = \"TYPE_SINT64\";\n  FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(FieldDescriptorProto_Type || (exports.FieldDescriptorProto_Type = FieldDescriptorProto_Type = {}));\nvar FieldDescriptorProto_TypeSDKType = FieldDescriptorProto_Type;\nexports.FieldDescriptorProto_TypeSDKType = FieldDescriptorProto_TypeSDKType;\nfunction fieldDescriptorProto_TypeFromJSON(object) {\n  switch (object) {\n    case 1:\n    case \"TYPE_DOUBLE\":\n      return FieldDescriptorProto_Type.TYPE_DOUBLE;\n    case 2:\n    case \"TYPE_FLOAT\":\n      return FieldDescriptorProto_Type.TYPE_FLOAT;\n    case 3:\n    case \"TYPE_INT64\":\n      return FieldDescriptorProto_Type.TYPE_INT64;\n    case 4:\n    case \"TYPE_UINT64\":\n      return FieldDescriptorProto_Type.TYPE_UINT64;\n    case 5:\n    case \"TYPE_INT32\":\n      return FieldDescriptorProto_Type.TYPE_INT32;\n    case 6:\n    case \"TYPE_FIXED64\":\n      return FieldDescriptorProto_Type.TYPE_FIXED64;\n    case 7:\n    case \"TYPE_FIXED32\":\n      return FieldDescriptorProto_Type.TYPE_FIXED32;\n    case 8:\n    case \"TYPE_BOOL\":\n      return FieldDescriptorProto_Type.TYPE_BOOL;\n    case 9:\n    case \"TYPE_STRING\":\n      return FieldDescriptorProto_Type.TYPE_STRING;\n    case 10:\n    case \"TYPE_GROUP\":\n      return FieldDescriptorProto_Type.TYPE_GROUP;\n    case 11:\n    case \"TYPE_MESSAGE\":\n      return FieldDescriptorProto_Type.TYPE_MESSAGE;\n    case 12:\n    case \"TYPE_BYTES\":\n      return FieldDescriptorProto_Type.TYPE_BYTES;\n    case 13:\n    case \"TYPE_UINT32\":\n      return FieldDescriptorProto_Type.TYPE_UINT32;\n    case 14:\n    case \"TYPE_ENUM\":\n      return FieldDescriptorProto_Type.TYPE_ENUM;\n    case 15:\n    case \"TYPE_SFIXED32\":\n      return FieldDescriptorProto_Type.TYPE_SFIXED32;\n    case 16:\n    case \"TYPE_SFIXED64\":\n      return FieldDescriptorProto_Type.TYPE_SFIXED64;\n    case 17:\n    case \"TYPE_SINT32\":\n      return FieldDescriptorProto_Type.TYPE_SINT32;\n    case 18:\n    case \"TYPE_SINT64\":\n      return FieldDescriptorProto_Type.TYPE_SINT64;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return FieldDescriptorProto_Type.UNRECOGNIZED;\n  }\n}\nfunction fieldDescriptorProto_TypeToJSON(object) {\n  switch (object) {\n    case FieldDescriptorProto_Type.TYPE_DOUBLE:\n      return \"TYPE_DOUBLE\";\n    case FieldDescriptorProto_Type.TYPE_FLOAT:\n      return \"TYPE_FLOAT\";\n    case FieldDescriptorProto_Type.TYPE_INT64:\n      return \"TYPE_INT64\";\n    case FieldDescriptorProto_Type.TYPE_UINT64:\n      return \"TYPE_UINT64\";\n    case FieldDescriptorProto_Type.TYPE_INT32:\n      return \"TYPE_INT32\";\n    case FieldDescriptorProto_Type.TYPE_FIXED64:\n      return \"TYPE_FIXED64\";\n    case FieldDescriptorProto_Type.TYPE_FIXED32:\n      return \"TYPE_FIXED32\";\n    case FieldDescriptorProto_Type.TYPE_BOOL:\n      return \"TYPE_BOOL\";\n    case FieldDescriptorProto_Type.TYPE_STRING:\n      return \"TYPE_STRING\";\n    case FieldDescriptorProto_Type.TYPE_GROUP:\n      return \"TYPE_GROUP\";\n    case FieldDescriptorProto_Type.TYPE_MESSAGE:\n      return \"TYPE_MESSAGE\";\n    case FieldDescriptorProto_Type.TYPE_BYTES:\n      return \"TYPE_BYTES\";\n    case FieldDescriptorProto_Type.TYPE_UINT32:\n      return \"TYPE_UINT32\";\n    case FieldDescriptorProto_Type.TYPE_ENUM:\n      return \"TYPE_ENUM\";\n    case FieldDescriptorProto_Type.TYPE_SFIXED32:\n      return \"TYPE_SFIXED32\";\n    case FieldDescriptorProto_Type.TYPE_SFIXED64:\n      return \"TYPE_SFIXED64\";\n    case FieldDescriptorProto_Type.TYPE_SINT32:\n      return \"TYPE_SINT32\";\n    case FieldDescriptorProto_Type.TYPE_SINT64:\n      return \"TYPE_SINT64\";\n    case FieldDescriptorProto_Type.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar FieldDescriptorProto_Label;\nexports.FieldDescriptorProto_Label = FieldDescriptorProto_Label;\n(function (FieldDescriptorProto_Label) {\n  FieldDescriptorProto_Label[FieldDescriptorProto_Label[\"LABEL_OPTIONAL\"] = 1] = \"LABEL_OPTIONAL\";\n  FieldDescriptorProto_Label[FieldDescriptorProto_Label[\"LABEL_REQUIRED\"] = 2] = \"LABEL_REQUIRED\";\n  FieldDescriptorProto_Label[FieldDescriptorProto_Label[\"LABEL_REPEATED\"] = 3] = \"LABEL_REPEATED\";\n  FieldDescriptorProto_Label[FieldDescriptorProto_Label[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(FieldDescriptorProto_Label || (exports.FieldDescriptorProto_Label = FieldDescriptorProto_Label = {}));\nvar FieldDescriptorProto_LabelSDKType = FieldDescriptorProto_Label;\nexports.FieldDescriptorProto_LabelSDKType = FieldDescriptorProto_LabelSDKType;\nfunction fieldDescriptorProto_LabelFromJSON(object) {\n  switch (object) {\n    case 1:\n    case \"LABEL_OPTIONAL\":\n      return FieldDescriptorProto_Label.LABEL_OPTIONAL;\n    case 2:\n    case \"LABEL_REQUIRED\":\n      return FieldDescriptorProto_Label.LABEL_REQUIRED;\n    case 3:\n    case \"LABEL_REPEATED\":\n      return FieldDescriptorProto_Label.LABEL_REPEATED;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return FieldDescriptorProto_Label.UNRECOGNIZED;\n  }\n}\nfunction fieldDescriptorProto_LabelToJSON(object) {\n  switch (object) {\n    case FieldDescriptorProto_Label.LABEL_OPTIONAL:\n      return \"LABEL_OPTIONAL\";\n    case FieldDescriptorProto_Label.LABEL_REQUIRED:\n      return \"LABEL_REQUIRED\";\n    case FieldDescriptorProto_Label.LABEL_REPEATED:\n      return \"LABEL_REPEATED\";\n    case FieldDescriptorProto_Label.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n/** Generated classes can be optimized for speed or code size. */\nvar FileOptions_OptimizeMode;\nexports.FileOptions_OptimizeMode = FileOptions_OptimizeMode;\n(function (FileOptions_OptimizeMode) {\n  FileOptions_OptimizeMode[FileOptions_OptimizeMode[\"SPEED\"] = 1] = \"SPEED\";\n  FileOptions_OptimizeMode[FileOptions_OptimizeMode[\"CODE_SIZE\"] = 2] = \"CODE_SIZE\";\n  FileOptions_OptimizeMode[FileOptions_OptimizeMode[\"LITE_RUNTIME\"] = 3] = \"LITE_RUNTIME\";\n  FileOptions_OptimizeMode[FileOptions_OptimizeMode[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(FileOptions_OptimizeMode || (exports.FileOptions_OptimizeMode = FileOptions_OptimizeMode = {}));\nvar FileOptions_OptimizeModeSDKType = FileOptions_OptimizeMode;\nexports.FileOptions_OptimizeModeSDKType = FileOptions_OptimizeModeSDKType;\nfunction fileOptions_OptimizeModeFromJSON(object) {\n  switch (object) {\n    case 1:\n    case \"SPEED\":\n      return FileOptions_OptimizeMode.SPEED;\n    case 2:\n    case \"CODE_SIZE\":\n      return FileOptions_OptimizeMode.CODE_SIZE;\n    case 3:\n    case \"LITE_RUNTIME\":\n      return FileOptions_OptimizeMode.LITE_RUNTIME;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return FileOptions_OptimizeMode.UNRECOGNIZED;\n  }\n}\nfunction fileOptions_OptimizeModeToJSON(object) {\n  switch (object) {\n    case FileOptions_OptimizeMode.SPEED:\n      return \"SPEED\";\n    case FileOptions_OptimizeMode.CODE_SIZE:\n      return \"CODE_SIZE\";\n    case FileOptions_OptimizeMode.LITE_RUNTIME:\n      return \"LITE_RUNTIME\";\n    case FileOptions_OptimizeMode.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar FieldOptions_CType;\nexports.FieldOptions_CType = FieldOptions_CType;\n(function (FieldOptions_CType) {\n  FieldOptions_CType[FieldOptions_CType[\"STRING\"] = 0] = \"STRING\";\n  FieldOptions_CType[FieldOptions_CType[\"CORD\"] = 1] = \"CORD\";\n  FieldOptions_CType[FieldOptions_CType[\"STRING_PIECE\"] = 2] = \"STRING_PIECE\";\n  FieldOptions_CType[FieldOptions_CType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(FieldOptions_CType || (exports.FieldOptions_CType = FieldOptions_CType = {}));\nvar FieldOptions_CTypeSDKType = FieldOptions_CType;\nexports.FieldOptions_CTypeSDKType = FieldOptions_CTypeSDKType;\nfunction fieldOptions_CTypeFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"STRING\":\n      return FieldOptions_CType.STRING;\n    case 1:\n    case \"CORD\":\n      return FieldOptions_CType.CORD;\n    case 2:\n    case \"STRING_PIECE\":\n      return FieldOptions_CType.STRING_PIECE;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return FieldOptions_CType.UNRECOGNIZED;\n  }\n}\nfunction fieldOptions_CTypeToJSON(object) {\n  switch (object) {\n    case FieldOptions_CType.STRING:\n      return \"STRING\";\n    case FieldOptions_CType.CORD:\n      return \"CORD\";\n    case FieldOptions_CType.STRING_PIECE:\n      return \"STRING_PIECE\";\n    case FieldOptions_CType.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar FieldOptions_JSType;\nexports.FieldOptions_JSType = FieldOptions_JSType;\n(function (FieldOptions_JSType) {\n  FieldOptions_JSType[FieldOptions_JSType[\"JS_NORMAL\"] = 0] = \"JS_NORMAL\";\n  FieldOptions_JSType[FieldOptions_JSType[\"JS_STRING\"] = 1] = \"JS_STRING\";\n  FieldOptions_JSType[FieldOptions_JSType[\"JS_NUMBER\"] = 2] = \"JS_NUMBER\";\n  FieldOptions_JSType[FieldOptions_JSType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(FieldOptions_JSType || (exports.FieldOptions_JSType = FieldOptions_JSType = {}));\nvar FieldOptions_JSTypeSDKType = FieldOptions_JSType;\nexports.FieldOptions_JSTypeSDKType = FieldOptions_JSTypeSDKType;\nfunction fieldOptions_JSTypeFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"JS_NORMAL\":\n      return FieldOptions_JSType.JS_NORMAL;\n    case 1:\n    case \"JS_STRING\":\n      return FieldOptions_JSType.JS_STRING;\n    case 2:\n    case \"JS_NUMBER\":\n      return FieldOptions_JSType.JS_NUMBER;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return FieldOptions_JSType.UNRECOGNIZED;\n  }\n}\nfunction fieldOptions_JSTypeToJSON(object) {\n  switch (object) {\n    case FieldOptions_JSType.JS_NORMAL:\n      return \"JS_NORMAL\";\n    case FieldOptions_JSType.JS_STRING:\n      return \"JS_STRING\";\n    case FieldOptions_JSType.JS_NUMBER:\n      return \"JS_NUMBER\";\n    case FieldOptions_JSType.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n/**\n * Is this method side-effect-free (or safe in HTTP parlance), or idempotent,\n * or neither? HTTP based RPC implementation may choose GET verb for safe\n * methods, and PUT verb for idempotent methods instead of the default POST.\n */\nvar MethodOptions_IdempotencyLevel;\nexports.MethodOptions_IdempotencyLevel = MethodOptions_IdempotencyLevel;\n(function (MethodOptions_IdempotencyLevel) {\n  MethodOptions_IdempotencyLevel[MethodOptions_IdempotencyLevel[\"IDEMPOTENCY_UNKNOWN\"] = 0] = \"IDEMPOTENCY_UNKNOWN\";\n  MethodOptions_IdempotencyLevel[MethodOptions_IdempotencyLevel[\"NO_SIDE_EFFECTS\"] = 1] = \"NO_SIDE_EFFECTS\";\n  MethodOptions_IdempotencyLevel[MethodOptions_IdempotencyLevel[\"IDEMPOTENT\"] = 2] = \"IDEMPOTENT\";\n  MethodOptions_IdempotencyLevel[MethodOptions_IdempotencyLevel[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(MethodOptions_IdempotencyLevel || (exports.MethodOptions_IdempotencyLevel = MethodOptions_IdempotencyLevel = {}));\nvar MethodOptions_IdempotencyLevelSDKType = MethodOptions_IdempotencyLevel;\nexports.MethodOptions_IdempotencyLevelSDKType = MethodOptions_IdempotencyLevelSDKType;\nfunction methodOptions_IdempotencyLevelFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"IDEMPOTENCY_UNKNOWN\":\n      return MethodOptions_IdempotencyLevel.IDEMPOTENCY_UNKNOWN;\n    case 1:\n    case \"NO_SIDE_EFFECTS\":\n      return MethodOptions_IdempotencyLevel.NO_SIDE_EFFECTS;\n    case 2:\n    case \"IDEMPOTENT\":\n      return MethodOptions_IdempotencyLevel.IDEMPOTENT;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return MethodOptions_IdempotencyLevel.UNRECOGNIZED;\n  }\n}\nfunction methodOptions_IdempotencyLevelToJSON(object) {\n  switch (object) {\n    case MethodOptions_IdempotencyLevel.IDEMPOTENCY_UNKNOWN:\n      return \"IDEMPOTENCY_UNKNOWN\";\n    case MethodOptions_IdempotencyLevel.NO_SIDE_EFFECTS:\n      return \"NO_SIDE_EFFECTS\";\n    case MethodOptions_IdempotencyLevel.IDEMPOTENT:\n      return \"IDEMPOTENT\";\n    case MethodOptions_IdempotencyLevel.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n/**\n * The protocol compiler can output a FileDescriptorSet containing the .proto\n * files it parses.\n */\n\nfunction createBaseFileDescriptorSet() {\n  return {\n    file: []\n  };\n}\nvar FileDescriptorSet = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    var _iterator = _createForOfIteratorHelper(message.file),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var v = _step.value;\n        FileDescriptorProto.encode(v, writer.uint32(10).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseFileDescriptorSet();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.file.push(FileDescriptorProto.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$file;\n    var message = createBaseFileDescriptorSet();\n    message.file = ((_object$file = object.file) === null || _object$file === void 0 ? void 0 : _object$file.map(function (e) {\n      return FileDescriptorProto.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.FileDescriptorSet = FileDescriptorSet;\nfunction createBaseFileDescriptorProto() {\n  return {\n    name: \"\",\n    \"package\": \"\",\n    dependency: [],\n    publicDependency: [],\n    weakDependency: [],\n    messageType: [],\n    enumType: [],\n    service: [],\n    extension: [],\n    options: FileOptions.fromPartial({}),\n    sourceCodeInfo: SourceCodeInfo.fromPartial({}),\n    syntax: \"\"\n  };\n}\nvar FileDescriptorProto = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.name !== \"\") {\n      writer.uint32(10).string(message.name);\n    }\n    if (message[\"package\"] !== \"\") {\n      writer.uint32(18).string(message[\"package\"]);\n    }\n    var _iterator2 = _createForOfIteratorHelper(message.dependency),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var v = _step2.value;\n        writer.uint32(26).string(v);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    writer.uint32(82).fork();\n    var _iterator3 = _createForOfIteratorHelper(message.publicDependency),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _v = _step3.value;\n        writer.int32(_v);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    writer.ldelim();\n    writer.uint32(90).fork();\n    var _iterator4 = _createForOfIteratorHelper(message.weakDependency),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _v2 = _step4.value;\n        writer.int32(_v2);\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n    writer.ldelim();\n    var _iterator5 = _createForOfIteratorHelper(message.messageType),\n      _step5;\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var _v3 = _step5.value;\n        DescriptorProto.encode(_v3, writer.uint32(34).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n    var _iterator6 = _createForOfIteratorHelper(message.enumType),\n      _step6;\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var _v4 = _step6.value;\n        EnumDescriptorProto.encode(_v4, writer.uint32(42).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n    var _iterator7 = _createForOfIteratorHelper(message.service),\n      _step7;\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var _v5 = _step7.value;\n        ServiceDescriptorProto.encode(_v5, writer.uint32(50).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n    var _iterator8 = _createForOfIteratorHelper(message.extension),\n      _step8;\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var _v6 = _step8.value;\n        FieldDescriptorProto.encode(_v6, writer.uint32(58).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n    if (message.options !== undefined) {\n      FileOptions.encode(message.options, writer.uint32(66).fork()).ldelim();\n    }\n    if (message.sourceCodeInfo !== undefined) {\n      SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(74).fork()).ldelim();\n    }\n    if (message.syntax !== \"\") {\n      writer.uint32(98).string(message.syntax);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseFileDescriptorProto();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.name = reader.string();\n          break;\n        case 2:\n          message[\"package\"] = reader.string();\n          break;\n        case 3:\n          message.dependency.push(reader.string());\n          break;\n        case 10:\n          if ((tag & 7) === 2) {\n            var end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.publicDependency.push(reader.int32());\n            }\n          } else {\n            message.publicDependency.push(reader.int32());\n          }\n          break;\n        case 11:\n          if ((tag & 7) === 2) {\n            var _end = reader.uint32() + reader.pos;\n            while (reader.pos < _end) {\n              message.weakDependency.push(reader.int32());\n            }\n          } else {\n            message.weakDependency.push(reader.int32());\n          }\n          break;\n        case 4:\n          message.messageType.push(DescriptorProto.decode(reader, reader.uint32()));\n          break;\n        case 5:\n          message.enumType.push(EnumDescriptorProto.decode(reader, reader.uint32()));\n          break;\n        case 6:\n          message.service.push(ServiceDescriptorProto.decode(reader, reader.uint32()));\n          break;\n        case 7:\n          message.extension.push(FieldDescriptorProto.decode(reader, reader.uint32()));\n          break;\n        case 8:\n          message.options = FileOptions.decode(reader, reader.uint32());\n          break;\n        case 9:\n          message.sourceCodeInfo = SourceCodeInfo.decode(reader, reader.uint32());\n          break;\n        case 12:\n          message.syntax = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$name, _object$package, _object$dependency, _object$publicDepende, _object$weakDependenc, _object$messageType, _object$enumType, _object$service, _object$extension, _object$syntax;\n    var message = createBaseFileDescriptorProto();\n    message.name = (_object$name = object.name) !== null && _object$name !== void 0 ? _object$name : \"\";\n    message[\"package\"] = (_object$package = object[\"package\"]) !== null && _object$package !== void 0 ? _object$package : \"\";\n    message.dependency = ((_object$dependency = object.dependency) === null || _object$dependency === void 0 ? void 0 : _object$dependency.map(function (e) {\n      return e;\n    })) || [];\n    message.publicDependency = ((_object$publicDepende = object.publicDependency) === null || _object$publicDepende === void 0 ? void 0 : _object$publicDepende.map(function (e) {\n      return e;\n    })) || [];\n    message.weakDependency = ((_object$weakDependenc = object.weakDependency) === null || _object$weakDependenc === void 0 ? void 0 : _object$weakDependenc.map(function (e) {\n      return e;\n    })) || [];\n    message.messageType = ((_object$messageType = object.messageType) === null || _object$messageType === void 0 ? void 0 : _object$messageType.map(function (e) {\n      return DescriptorProto.fromPartial(e);\n    })) || [];\n    message.enumType = ((_object$enumType = object.enumType) === null || _object$enumType === void 0 ? void 0 : _object$enumType.map(function (e) {\n      return EnumDescriptorProto.fromPartial(e);\n    })) || [];\n    message.service = ((_object$service = object.service) === null || _object$service === void 0 ? void 0 : _object$service.map(function (e) {\n      return ServiceDescriptorProto.fromPartial(e);\n    })) || [];\n    message.extension = ((_object$extension = object.extension) === null || _object$extension === void 0 ? void 0 : _object$extension.map(function (e) {\n      return FieldDescriptorProto.fromPartial(e);\n    })) || [];\n    message.options = object.options !== undefined && object.options !== null ? FileOptions.fromPartial(object.options) : undefined;\n    message.sourceCodeInfo = object.sourceCodeInfo !== undefined && object.sourceCodeInfo !== null ? SourceCodeInfo.fromPartial(object.sourceCodeInfo) : undefined;\n    message.syntax = (_object$syntax = object.syntax) !== null && _object$syntax !== void 0 ? _object$syntax : \"\";\n    return message;\n  }\n};\nexports.FileDescriptorProto = FileDescriptorProto;\nfunction createBaseDescriptorProto() {\n  return {\n    name: \"\",\n    field: [],\n    extension: [],\n    nestedType: [],\n    enumType: [],\n    extensionRange: [],\n    oneofDecl: [],\n    options: MessageOptions.fromPartial({}),\n    reservedRange: [],\n    reservedName: []\n  };\n}\nvar DescriptorProto = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.name !== \"\") {\n      writer.uint32(10).string(message.name);\n    }\n    var _iterator9 = _createForOfIteratorHelper(message.field),\n      _step9;\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var v = _step9.value;\n        FieldDescriptorProto.encode(v, writer.uint32(18).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n    var _iterator10 = _createForOfIteratorHelper(message.extension),\n      _step10;\n    try {\n      for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n        var _v7 = _step10.value;\n        FieldDescriptorProto.encode(_v7, writer.uint32(50).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator10.e(err);\n    } finally {\n      _iterator10.f();\n    }\n    var _iterator11 = _createForOfIteratorHelper(message.nestedType),\n      _step11;\n    try {\n      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n        var _v8 = _step11.value;\n        DescriptorProto.encode(_v8, writer.uint32(26).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator11.e(err);\n    } finally {\n      _iterator11.f();\n    }\n    var _iterator12 = _createForOfIteratorHelper(message.enumType),\n      _step12;\n    try {\n      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n        var _v9 = _step12.value;\n        EnumDescriptorProto.encode(_v9, writer.uint32(34).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator12.e(err);\n    } finally {\n      _iterator12.f();\n    }\n    var _iterator13 = _createForOfIteratorHelper(message.extensionRange),\n      _step13;\n    try {\n      for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n        var _v10 = _step13.value;\n        DescriptorProto_ExtensionRange.encode(_v10, writer.uint32(42).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator13.e(err);\n    } finally {\n      _iterator13.f();\n    }\n    var _iterator14 = _createForOfIteratorHelper(message.oneofDecl),\n      _step14;\n    try {\n      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n        var _v11 = _step14.value;\n        OneofDescriptorProto.encode(_v11, writer.uint32(66).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator14.e(err);\n    } finally {\n      _iterator14.f();\n    }\n    if (message.options !== undefined) {\n      MessageOptions.encode(message.options, writer.uint32(58).fork()).ldelim();\n    }\n    var _iterator15 = _createForOfIteratorHelper(message.reservedRange),\n      _step15;\n    try {\n      for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n        var _v12 = _step15.value;\n        DescriptorProto_ReservedRange.encode(_v12, writer.uint32(74).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator15.e(err);\n    } finally {\n      _iterator15.f();\n    }\n    var _iterator16 = _createForOfIteratorHelper(message.reservedName),\n      _step16;\n    try {\n      for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n        var _v13 = _step16.value;\n        writer.uint32(82).string(_v13);\n      }\n    } catch (err) {\n      _iterator16.e(err);\n    } finally {\n      _iterator16.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseDescriptorProto();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.name = reader.string();\n          break;\n        case 2:\n          message.field.push(FieldDescriptorProto.decode(reader, reader.uint32()));\n          break;\n        case 6:\n          message.extension.push(FieldDescriptorProto.decode(reader, reader.uint32()));\n          break;\n        case 3:\n          message.nestedType.push(DescriptorProto.decode(reader, reader.uint32()));\n          break;\n        case 4:\n          message.enumType.push(EnumDescriptorProto.decode(reader, reader.uint32()));\n          break;\n        case 5:\n          message.extensionRange.push(DescriptorProto_ExtensionRange.decode(reader, reader.uint32()));\n          break;\n        case 8:\n          message.oneofDecl.push(OneofDescriptorProto.decode(reader, reader.uint32()));\n          break;\n        case 7:\n          message.options = MessageOptions.decode(reader, reader.uint32());\n          break;\n        case 9:\n          message.reservedRange.push(DescriptorProto_ReservedRange.decode(reader, reader.uint32()));\n          break;\n        case 10:\n          message.reservedName.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$name2, _object$field, _object$extension2, _object$nestedType, _object$enumType2, _object$extensionRang, _object$oneofDecl, _object$reservedRange, _object$reservedName;\n    var message = createBaseDescriptorProto();\n    message.name = (_object$name2 = object.name) !== null && _object$name2 !== void 0 ? _object$name2 : \"\";\n    message.field = ((_object$field = object.field) === null || _object$field === void 0 ? void 0 : _object$field.map(function (e) {\n      return FieldDescriptorProto.fromPartial(e);\n    })) || [];\n    message.extension = ((_object$extension2 = object.extension) === null || _object$extension2 === void 0 ? void 0 : _object$extension2.map(function (e) {\n      return FieldDescriptorProto.fromPartial(e);\n    })) || [];\n    message.nestedType = ((_object$nestedType = object.nestedType) === null || _object$nestedType === void 0 ? void 0 : _object$nestedType.map(function (e) {\n      return DescriptorProto.fromPartial(e);\n    })) || [];\n    message.enumType = ((_object$enumType2 = object.enumType) === null || _object$enumType2 === void 0 ? void 0 : _object$enumType2.map(function (e) {\n      return EnumDescriptorProto.fromPartial(e);\n    })) || [];\n    message.extensionRange = ((_object$extensionRang = object.extensionRange) === null || _object$extensionRang === void 0 ? void 0 : _object$extensionRang.map(function (e) {\n      return DescriptorProto_ExtensionRange.fromPartial(e);\n    })) || [];\n    message.oneofDecl = ((_object$oneofDecl = object.oneofDecl) === null || _object$oneofDecl === void 0 ? void 0 : _object$oneofDecl.map(function (e) {\n      return OneofDescriptorProto.fromPartial(e);\n    })) || [];\n    message.options = object.options !== undefined && object.options !== null ? MessageOptions.fromPartial(object.options) : undefined;\n    message.reservedRange = ((_object$reservedRange = object.reservedRange) === null || _object$reservedRange === void 0 ? void 0 : _object$reservedRange.map(function (e) {\n      return DescriptorProto_ReservedRange.fromPartial(e);\n    })) || [];\n    message.reservedName = ((_object$reservedName = object.reservedName) === null || _object$reservedName === void 0 ? void 0 : _object$reservedName.map(function (e) {\n      return e;\n    })) || [];\n    return message;\n  }\n};\nexports.DescriptorProto = DescriptorProto;\nfunction createBaseDescriptorProto_ExtensionRange() {\n  return {\n    start: 0,\n    end: 0,\n    options: ExtensionRangeOptions.fromPartial({})\n  };\n}\nvar DescriptorProto_ExtensionRange = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.start !== 0) {\n      writer.uint32(8).int32(message.start);\n    }\n    if (message.end !== 0) {\n      writer.uint32(16).int32(message.end);\n    }\n    if (message.options !== undefined) {\n      ExtensionRangeOptions.encode(message.options, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseDescriptorProto_ExtensionRange();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.start = reader.int32();\n          break;\n        case 2:\n          message.end = reader.int32();\n          break;\n        case 3:\n          message.options = ExtensionRangeOptions.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$start, _object$end;\n    var message = createBaseDescriptorProto_ExtensionRange();\n    message.start = (_object$start = object.start) !== null && _object$start !== void 0 ? _object$start : 0;\n    message.end = (_object$end = object.end) !== null && _object$end !== void 0 ? _object$end : 0;\n    message.options = object.options !== undefined && object.options !== null ? ExtensionRangeOptions.fromPartial(object.options) : undefined;\n    return message;\n  }\n};\nexports.DescriptorProto_ExtensionRange = DescriptorProto_ExtensionRange;\nfunction createBaseDescriptorProto_ReservedRange() {\n  return {\n    start: 0,\n    end: 0\n  };\n}\nvar DescriptorProto_ReservedRange = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.start !== 0) {\n      writer.uint32(8).int32(message.start);\n    }\n    if (message.end !== 0) {\n      writer.uint32(16).int32(message.end);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseDescriptorProto_ReservedRange();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.start = reader.int32();\n          break;\n        case 2:\n          message.end = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$start2, _object$end2;\n    var message = createBaseDescriptorProto_ReservedRange();\n    message.start = (_object$start2 = object.start) !== null && _object$start2 !== void 0 ? _object$start2 : 0;\n    message.end = (_object$end2 = object.end) !== null && _object$end2 !== void 0 ? _object$end2 : 0;\n    return message;\n  }\n};\nexports.DescriptorProto_ReservedRange = DescriptorProto_ReservedRange;\nfunction createBaseExtensionRangeOptions() {\n  return {\n    uninterpretedOption: []\n  };\n}\nvar ExtensionRangeOptions = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    var _iterator17 = _createForOfIteratorHelper(message.uninterpretedOption),\n      _step17;\n    try {\n      for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n        var v = _step17.value;\n        UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator17.e(err);\n    } finally {\n      _iterator17.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseExtensionRangeOptions();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 999:\n          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$uninterpreted;\n    var message = createBaseExtensionRangeOptions();\n    message.uninterpretedOption = ((_object$uninterpreted = object.uninterpretedOption) === null || _object$uninterpreted === void 0 ? void 0 : _object$uninterpreted.map(function (e) {\n      return UninterpretedOption.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.ExtensionRangeOptions = ExtensionRangeOptions;\nfunction createBaseFieldDescriptorProto() {\n  return {\n    name: \"\",\n    number: 0,\n    label: 1,\n    type: 1,\n    typeName: \"\",\n    extendee: \"\",\n    defaultValue: \"\",\n    oneofIndex: 0,\n    jsonName: \"\",\n    options: FieldOptions.fromPartial({})\n  };\n}\nvar FieldDescriptorProto = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.name !== \"\") {\n      writer.uint32(10).string(message.name);\n    }\n    if (message.number !== 0) {\n      writer.uint32(24).int32(message.number);\n    }\n    if (message.label !== 1) {\n      writer.uint32(32).int32(message.label);\n    }\n    if (message.type !== 1) {\n      writer.uint32(40).int32(message.type);\n    }\n    if (message.typeName !== \"\") {\n      writer.uint32(50).string(message.typeName);\n    }\n    if (message.extendee !== \"\") {\n      writer.uint32(18).string(message.extendee);\n    }\n    if (message.defaultValue !== \"\") {\n      writer.uint32(58).string(message.defaultValue);\n    }\n    if (message.oneofIndex !== 0) {\n      writer.uint32(72).int32(message.oneofIndex);\n    }\n    if (message.jsonName !== \"\") {\n      writer.uint32(82).string(message.jsonName);\n    }\n    if (message.options !== undefined) {\n      FieldOptions.encode(message.options, writer.uint32(66).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseFieldDescriptorProto();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.name = reader.string();\n          break;\n        case 3:\n          message.number = reader.int32();\n          break;\n        case 4:\n          message.label = reader.int32();\n          break;\n        case 5:\n          message.type = reader.int32();\n          break;\n        case 6:\n          message.typeName = reader.string();\n          break;\n        case 2:\n          message.extendee = reader.string();\n          break;\n        case 7:\n          message.defaultValue = reader.string();\n          break;\n        case 9:\n          message.oneofIndex = reader.int32();\n          break;\n        case 10:\n          message.jsonName = reader.string();\n          break;\n        case 8:\n          message.options = FieldOptions.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$name3, _object$number, _object$label, _object$type, _object$typeName, _object$extendee, _object$defaultValue, _object$oneofIndex, _object$jsonName;\n    var message = createBaseFieldDescriptorProto();\n    message.name = (_object$name3 = object.name) !== null && _object$name3 !== void 0 ? _object$name3 : \"\";\n    message.number = (_object$number = object.number) !== null && _object$number !== void 0 ? _object$number : 0;\n    message.label = (_object$label = object.label) !== null && _object$label !== void 0 ? _object$label : 1;\n    message.type = (_object$type = object.type) !== null && _object$type !== void 0 ? _object$type : 1;\n    message.typeName = (_object$typeName = object.typeName) !== null && _object$typeName !== void 0 ? _object$typeName : \"\";\n    message.extendee = (_object$extendee = object.extendee) !== null && _object$extendee !== void 0 ? _object$extendee : \"\";\n    message.defaultValue = (_object$defaultValue = object.defaultValue) !== null && _object$defaultValue !== void 0 ? _object$defaultValue : \"\";\n    message.oneofIndex = (_object$oneofIndex = object.oneofIndex) !== null && _object$oneofIndex !== void 0 ? _object$oneofIndex : 0;\n    message.jsonName = (_object$jsonName = object.jsonName) !== null && _object$jsonName !== void 0 ? _object$jsonName : \"\";\n    message.options = object.options !== undefined && object.options !== null ? FieldOptions.fromPartial(object.options) : undefined;\n    return message;\n  }\n};\nexports.FieldDescriptorProto = FieldDescriptorProto;\nfunction createBaseOneofDescriptorProto() {\n  return {\n    name: \"\",\n    options: OneofOptions.fromPartial({})\n  };\n}\nvar OneofDescriptorProto = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.name !== \"\") {\n      writer.uint32(10).string(message.name);\n    }\n    if (message.options !== undefined) {\n      OneofOptions.encode(message.options, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseOneofDescriptorProto();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.name = reader.string();\n          break;\n        case 2:\n          message.options = OneofOptions.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$name4;\n    var message = createBaseOneofDescriptorProto();\n    message.name = (_object$name4 = object.name) !== null && _object$name4 !== void 0 ? _object$name4 : \"\";\n    message.options = object.options !== undefined && object.options !== null ? OneofOptions.fromPartial(object.options) : undefined;\n    return message;\n  }\n};\nexports.OneofDescriptorProto = OneofDescriptorProto;\nfunction createBaseEnumDescriptorProto() {\n  return {\n    name: \"\",\n    value: [],\n    options: EnumOptions.fromPartial({}),\n    reservedRange: [],\n    reservedName: []\n  };\n}\nvar EnumDescriptorProto = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.name !== \"\") {\n      writer.uint32(10).string(message.name);\n    }\n    var _iterator18 = _createForOfIteratorHelper(message.value),\n      _step18;\n    try {\n      for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n        var v = _step18.value;\n        EnumValueDescriptorProto.encode(v, writer.uint32(18).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator18.e(err);\n    } finally {\n      _iterator18.f();\n    }\n    if (message.options !== undefined) {\n      EnumOptions.encode(message.options, writer.uint32(26).fork()).ldelim();\n    }\n    var _iterator19 = _createForOfIteratorHelper(message.reservedRange),\n      _step19;\n    try {\n      for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n        var _v14 = _step19.value;\n        EnumDescriptorProto_EnumReservedRange.encode(_v14, writer.uint32(34).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator19.e(err);\n    } finally {\n      _iterator19.f();\n    }\n    var _iterator20 = _createForOfIteratorHelper(message.reservedName),\n      _step20;\n    try {\n      for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n        var _v15 = _step20.value;\n        writer.uint32(42).string(_v15);\n      }\n    } catch (err) {\n      _iterator20.e(err);\n    } finally {\n      _iterator20.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseEnumDescriptorProto();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.name = reader.string();\n          break;\n        case 2:\n          message.value.push(EnumValueDescriptorProto.decode(reader, reader.uint32()));\n          break;\n        case 3:\n          message.options = EnumOptions.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.reservedRange.push(EnumDescriptorProto_EnumReservedRange.decode(reader, reader.uint32()));\n          break;\n        case 5:\n          message.reservedName.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$name5, _object$value, _object$reservedRange2, _object$reservedName2;\n    var message = createBaseEnumDescriptorProto();\n    message.name = (_object$name5 = object.name) !== null && _object$name5 !== void 0 ? _object$name5 : \"\";\n    message.value = ((_object$value = object.value) === null || _object$value === void 0 ? void 0 : _object$value.map(function (e) {\n      return EnumValueDescriptorProto.fromPartial(e);\n    })) || [];\n    message.options = object.options !== undefined && object.options !== null ? EnumOptions.fromPartial(object.options) : undefined;\n    message.reservedRange = ((_object$reservedRange2 = object.reservedRange) === null || _object$reservedRange2 === void 0 ? void 0 : _object$reservedRange2.map(function (e) {\n      return EnumDescriptorProto_EnumReservedRange.fromPartial(e);\n    })) || [];\n    message.reservedName = ((_object$reservedName2 = object.reservedName) === null || _object$reservedName2 === void 0 ? void 0 : _object$reservedName2.map(function (e) {\n      return e;\n    })) || [];\n    return message;\n  }\n};\nexports.EnumDescriptorProto = EnumDescriptorProto;\nfunction createBaseEnumDescriptorProto_EnumReservedRange() {\n  return {\n    start: 0,\n    end: 0\n  };\n}\nvar EnumDescriptorProto_EnumReservedRange = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.start !== 0) {\n      writer.uint32(8).int32(message.start);\n    }\n    if (message.end !== 0) {\n      writer.uint32(16).int32(message.end);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseEnumDescriptorProto_EnumReservedRange();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.start = reader.int32();\n          break;\n        case 2:\n          message.end = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$start3, _object$end3;\n    var message = createBaseEnumDescriptorProto_EnumReservedRange();\n    message.start = (_object$start3 = object.start) !== null && _object$start3 !== void 0 ? _object$start3 : 0;\n    message.end = (_object$end3 = object.end) !== null && _object$end3 !== void 0 ? _object$end3 : 0;\n    return message;\n  }\n};\nexports.EnumDescriptorProto_EnumReservedRange = EnumDescriptorProto_EnumReservedRange;\nfunction createBaseEnumValueDescriptorProto() {\n  return {\n    name: \"\",\n    number: 0,\n    options: EnumValueOptions.fromPartial({})\n  };\n}\nvar EnumValueDescriptorProto = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.name !== \"\") {\n      writer.uint32(10).string(message.name);\n    }\n    if (message.number !== 0) {\n      writer.uint32(16).int32(message.number);\n    }\n    if (message.options !== undefined) {\n      EnumValueOptions.encode(message.options, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseEnumValueDescriptorProto();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.name = reader.string();\n          break;\n        case 2:\n          message.number = reader.int32();\n          break;\n        case 3:\n          message.options = EnumValueOptions.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$name6, _object$number2;\n    var message = createBaseEnumValueDescriptorProto();\n    message.name = (_object$name6 = object.name) !== null && _object$name6 !== void 0 ? _object$name6 : \"\";\n    message.number = (_object$number2 = object.number) !== null && _object$number2 !== void 0 ? _object$number2 : 0;\n    message.options = object.options !== undefined && object.options !== null ? EnumValueOptions.fromPartial(object.options) : undefined;\n    return message;\n  }\n};\nexports.EnumValueDescriptorProto = EnumValueDescriptorProto;\nfunction createBaseServiceDescriptorProto() {\n  return {\n    name: \"\",\n    method: [],\n    options: ServiceOptions.fromPartial({})\n  };\n}\nvar ServiceDescriptorProto = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.name !== \"\") {\n      writer.uint32(10).string(message.name);\n    }\n    var _iterator21 = _createForOfIteratorHelper(message.method),\n      _step21;\n    try {\n      for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n        var v = _step21.value;\n        MethodDescriptorProto.encode(v, writer.uint32(18).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator21.e(err);\n    } finally {\n      _iterator21.f();\n    }\n    if (message.options !== undefined) {\n      ServiceOptions.encode(message.options, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseServiceDescriptorProto();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.name = reader.string();\n          break;\n        case 2:\n          message.method.push(MethodDescriptorProto.decode(reader, reader.uint32()));\n          break;\n        case 3:\n          message.options = ServiceOptions.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$name7, _object$method;\n    var message = createBaseServiceDescriptorProto();\n    message.name = (_object$name7 = object.name) !== null && _object$name7 !== void 0 ? _object$name7 : \"\";\n    message.method = ((_object$method = object.method) === null || _object$method === void 0 ? void 0 : _object$method.map(function (e) {\n      return MethodDescriptorProto.fromPartial(e);\n    })) || [];\n    message.options = object.options !== undefined && object.options !== null ? ServiceOptions.fromPartial(object.options) : undefined;\n    return message;\n  }\n};\nexports.ServiceDescriptorProto = ServiceDescriptorProto;\nfunction createBaseMethodDescriptorProto() {\n  return {\n    name: \"\",\n    inputType: \"\",\n    outputType: \"\",\n    options: MethodOptions.fromPartial({}),\n    clientStreaming: false,\n    serverStreaming: false\n  };\n}\nvar MethodDescriptorProto = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.name !== \"\") {\n      writer.uint32(10).string(message.name);\n    }\n    if (message.inputType !== \"\") {\n      writer.uint32(18).string(message.inputType);\n    }\n    if (message.outputType !== \"\") {\n      writer.uint32(26).string(message.outputType);\n    }\n    if (message.options !== undefined) {\n      MethodOptions.encode(message.options, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.clientStreaming === true) {\n      writer.uint32(40).bool(message.clientStreaming);\n    }\n    if (message.serverStreaming === true) {\n      writer.uint32(48).bool(message.serverStreaming);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMethodDescriptorProto();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.name = reader.string();\n          break;\n        case 2:\n          message.inputType = reader.string();\n          break;\n        case 3:\n          message.outputType = reader.string();\n          break;\n        case 4:\n          message.options = MethodOptions.decode(reader, reader.uint32());\n          break;\n        case 5:\n          message.clientStreaming = reader.bool();\n          break;\n        case 6:\n          message.serverStreaming = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$name8, _object$inputType, _object$outputType, _object$clientStreami, _object$serverStreami;\n    var message = createBaseMethodDescriptorProto();\n    message.name = (_object$name8 = object.name) !== null && _object$name8 !== void 0 ? _object$name8 : \"\";\n    message.inputType = (_object$inputType = object.inputType) !== null && _object$inputType !== void 0 ? _object$inputType : \"\";\n    message.outputType = (_object$outputType = object.outputType) !== null && _object$outputType !== void 0 ? _object$outputType : \"\";\n    message.options = object.options !== undefined && object.options !== null ? MethodOptions.fromPartial(object.options) : undefined;\n    message.clientStreaming = (_object$clientStreami = object.clientStreaming) !== null && _object$clientStreami !== void 0 ? _object$clientStreami : false;\n    message.serverStreaming = (_object$serverStreami = object.serverStreaming) !== null && _object$serverStreami !== void 0 ? _object$serverStreami : false;\n    return message;\n  }\n};\nexports.MethodDescriptorProto = MethodDescriptorProto;\nfunction createBaseFileOptions() {\n  return {\n    javaPackage: \"\",\n    javaOuterClassname: \"\",\n    javaMultipleFiles: false,\n    javaGenerateEqualsAndHash: false,\n    javaStringCheckUtf8: false,\n    optimizeFor: 1,\n    goPackage: \"\",\n    ccGenericServices: false,\n    javaGenericServices: false,\n    pyGenericServices: false,\n    phpGenericServices: false,\n    deprecated: false,\n    ccEnableArenas: false,\n    objcClassPrefix: \"\",\n    csharpNamespace: \"\",\n    swiftPrefix: \"\",\n    phpClassPrefix: \"\",\n    phpNamespace: \"\",\n    phpMetadataNamespace: \"\",\n    rubyPackage: \"\",\n    uninterpretedOption: []\n  };\n}\nvar FileOptions = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.javaPackage !== \"\") {\n      writer.uint32(10).string(message.javaPackage);\n    }\n    if (message.javaOuterClassname !== \"\") {\n      writer.uint32(66).string(message.javaOuterClassname);\n    }\n    if (message.javaMultipleFiles === true) {\n      writer.uint32(80).bool(message.javaMultipleFiles);\n    }\n    if (message.javaGenerateEqualsAndHash === true) {\n      writer.uint32(160).bool(message.javaGenerateEqualsAndHash);\n    }\n    if (message.javaStringCheckUtf8 === true) {\n      writer.uint32(216).bool(message.javaStringCheckUtf8);\n    }\n    if (message.optimizeFor !== 1) {\n      writer.uint32(72).int32(message.optimizeFor);\n    }\n    if (message.goPackage !== \"\") {\n      writer.uint32(90).string(message.goPackage);\n    }\n    if (message.ccGenericServices === true) {\n      writer.uint32(128).bool(message.ccGenericServices);\n    }\n    if (message.javaGenericServices === true) {\n      writer.uint32(136).bool(message.javaGenericServices);\n    }\n    if (message.pyGenericServices === true) {\n      writer.uint32(144).bool(message.pyGenericServices);\n    }\n    if (message.phpGenericServices === true) {\n      writer.uint32(336).bool(message.phpGenericServices);\n    }\n    if (message.deprecated === true) {\n      writer.uint32(184).bool(message.deprecated);\n    }\n    if (message.ccEnableArenas === true) {\n      writer.uint32(248).bool(message.ccEnableArenas);\n    }\n    if (message.objcClassPrefix !== \"\") {\n      writer.uint32(290).string(message.objcClassPrefix);\n    }\n    if (message.csharpNamespace !== \"\") {\n      writer.uint32(298).string(message.csharpNamespace);\n    }\n    if (message.swiftPrefix !== \"\") {\n      writer.uint32(314).string(message.swiftPrefix);\n    }\n    if (message.phpClassPrefix !== \"\") {\n      writer.uint32(322).string(message.phpClassPrefix);\n    }\n    if (message.phpNamespace !== \"\") {\n      writer.uint32(330).string(message.phpNamespace);\n    }\n    if (message.phpMetadataNamespace !== \"\") {\n      writer.uint32(354).string(message.phpMetadataNamespace);\n    }\n    if (message.rubyPackage !== \"\") {\n      writer.uint32(362).string(message.rubyPackage);\n    }\n    var _iterator22 = _createForOfIteratorHelper(message.uninterpretedOption),\n      _step22;\n    try {\n      for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n        var v = _step22.value;\n        UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator22.e(err);\n    } finally {\n      _iterator22.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseFileOptions();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.javaPackage = reader.string();\n          break;\n        case 8:\n          message.javaOuterClassname = reader.string();\n          break;\n        case 10:\n          message.javaMultipleFiles = reader.bool();\n          break;\n        case 20:\n          message.javaGenerateEqualsAndHash = reader.bool();\n          break;\n        case 27:\n          message.javaStringCheckUtf8 = reader.bool();\n          break;\n        case 9:\n          message.optimizeFor = reader.int32();\n          break;\n        case 11:\n          message.goPackage = reader.string();\n          break;\n        case 16:\n          message.ccGenericServices = reader.bool();\n          break;\n        case 17:\n          message.javaGenericServices = reader.bool();\n          break;\n        case 18:\n          message.pyGenericServices = reader.bool();\n          break;\n        case 42:\n          message.phpGenericServices = reader.bool();\n          break;\n        case 23:\n          message.deprecated = reader.bool();\n          break;\n        case 31:\n          message.ccEnableArenas = reader.bool();\n          break;\n        case 36:\n          message.objcClassPrefix = reader.string();\n          break;\n        case 37:\n          message.csharpNamespace = reader.string();\n          break;\n        case 39:\n          message.swiftPrefix = reader.string();\n          break;\n        case 40:\n          message.phpClassPrefix = reader.string();\n          break;\n        case 41:\n          message.phpNamespace = reader.string();\n          break;\n        case 44:\n          message.phpMetadataNamespace = reader.string();\n          break;\n        case 45:\n          message.rubyPackage = reader.string();\n          break;\n        case 999:\n          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$javaPackage, _object$javaOuterClas, _object$javaMultipleF, _object$javaGenerateE, _object$javaStringChe, _object$optimizeFor, _object$goPackage, _object$ccGenericServ, _object$javaGenericSe, _object$pyGenericServ, _object$phpGenericSer, _object$deprecated, _object$ccEnableArena, _object$objcClassPref, _object$csharpNamespa, _object$swiftPrefix, _object$phpClassPrefi, _object$phpNamespace, _object$phpMetadataNa, _object$rubyPackage, _object$uninterpreted2;\n    var message = createBaseFileOptions();\n    message.javaPackage = (_object$javaPackage = object.javaPackage) !== null && _object$javaPackage !== void 0 ? _object$javaPackage : \"\";\n    message.javaOuterClassname = (_object$javaOuterClas = object.javaOuterClassname) !== null && _object$javaOuterClas !== void 0 ? _object$javaOuterClas : \"\";\n    message.javaMultipleFiles = (_object$javaMultipleF = object.javaMultipleFiles) !== null && _object$javaMultipleF !== void 0 ? _object$javaMultipleF : false;\n    message.javaGenerateEqualsAndHash = (_object$javaGenerateE = object.javaGenerateEqualsAndHash) !== null && _object$javaGenerateE !== void 0 ? _object$javaGenerateE : false;\n    message.javaStringCheckUtf8 = (_object$javaStringChe = object.javaStringCheckUtf8) !== null && _object$javaStringChe !== void 0 ? _object$javaStringChe : false;\n    message.optimizeFor = (_object$optimizeFor = object.optimizeFor) !== null && _object$optimizeFor !== void 0 ? _object$optimizeFor : 1;\n    message.goPackage = (_object$goPackage = object.goPackage) !== null && _object$goPackage !== void 0 ? _object$goPackage : \"\";\n    message.ccGenericServices = (_object$ccGenericServ = object.ccGenericServices) !== null && _object$ccGenericServ !== void 0 ? _object$ccGenericServ : false;\n    message.javaGenericServices = (_object$javaGenericSe = object.javaGenericServices) !== null && _object$javaGenericSe !== void 0 ? _object$javaGenericSe : false;\n    message.pyGenericServices = (_object$pyGenericServ = object.pyGenericServices) !== null && _object$pyGenericServ !== void 0 ? _object$pyGenericServ : false;\n    message.phpGenericServices = (_object$phpGenericSer = object.phpGenericServices) !== null && _object$phpGenericSer !== void 0 ? _object$phpGenericSer : false;\n    message.deprecated = (_object$deprecated = object.deprecated) !== null && _object$deprecated !== void 0 ? _object$deprecated : false;\n    message.ccEnableArenas = (_object$ccEnableArena = object.ccEnableArenas) !== null && _object$ccEnableArena !== void 0 ? _object$ccEnableArena : false;\n    message.objcClassPrefix = (_object$objcClassPref = object.objcClassPrefix) !== null && _object$objcClassPref !== void 0 ? _object$objcClassPref : \"\";\n    message.csharpNamespace = (_object$csharpNamespa = object.csharpNamespace) !== null && _object$csharpNamespa !== void 0 ? _object$csharpNamespa : \"\";\n    message.swiftPrefix = (_object$swiftPrefix = object.swiftPrefix) !== null && _object$swiftPrefix !== void 0 ? _object$swiftPrefix : \"\";\n    message.phpClassPrefix = (_object$phpClassPrefi = object.phpClassPrefix) !== null && _object$phpClassPrefi !== void 0 ? _object$phpClassPrefi : \"\";\n    message.phpNamespace = (_object$phpNamespace = object.phpNamespace) !== null && _object$phpNamespace !== void 0 ? _object$phpNamespace : \"\";\n    message.phpMetadataNamespace = (_object$phpMetadataNa = object.phpMetadataNamespace) !== null && _object$phpMetadataNa !== void 0 ? _object$phpMetadataNa : \"\";\n    message.rubyPackage = (_object$rubyPackage = object.rubyPackage) !== null && _object$rubyPackage !== void 0 ? _object$rubyPackage : \"\";\n    message.uninterpretedOption = ((_object$uninterpreted2 = object.uninterpretedOption) === null || _object$uninterpreted2 === void 0 ? void 0 : _object$uninterpreted2.map(function (e) {\n      return UninterpretedOption.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.FileOptions = FileOptions;\nfunction createBaseMessageOptions() {\n  return {\n    messageSetWireFormat: false,\n    noStandardDescriptorAccessor: false,\n    deprecated: false,\n    mapEntry: false,\n    uninterpretedOption: []\n  };\n}\nvar MessageOptions = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.messageSetWireFormat === true) {\n      writer.uint32(8).bool(message.messageSetWireFormat);\n    }\n    if (message.noStandardDescriptorAccessor === true) {\n      writer.uint32(16).bool(message.noStandardDescriptorAccessor);\n    }\n    if (message.deprecated === true) {\n      writer.uint32(24).bool(message.deprecated);\n    }\n    if (message.mapEntry === true) {\n      writer.uint32(56).bool(message.mapEntry);\n    }\n    var _iterator23 = _createForOfIteratorHelper(message.uninterpretedOption),\n      _step23;\n    try {\n      for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n        var v = _step23.value;\n        UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator23.e(err);\n    } finally {\n      _iterator23.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMessageOptions();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.messageSetWireFormat = reader.bool();\n          break;\n        case 2:\n          message.noStandardDescriptorAccessor = reader.bool();\n          break;\n        case 3:\n          message.deprecated = reader.bool();\n          break;\n        case 7:\n          message.mapEntry = reader.bool();\n          break;\n        case 999:\n          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$messageSetWir, _object$noStandardDes, _object$deprecated2, _object$mapEntry, _object$uninterpreted3;\n    var message = createBaseMessageOptions();\n    message.messageSetWireFormat = (_object$messageSetWir = object.messageSetWireFormat) !== null && _object$messageSetWir !== void 0 ? _object$messageSetWir : false;\n    message.noStandardDescriptorAccessor = (_object$noStandardDes = object.noStandardDescriptorAccessor) !== null && _object$noStandardDes !== void 0 ? _object$noStandardDes : false;\n    message.deprecated = (_object$deprecated2 = object.deprecated) !== null && _object$deprecated2 !== void 0 ? _object$deprecated2 : false;\n    message.mapEntry = (_object$mapEntry = object.mapEntry) !== null && _object$mapEntry !== void 0 ? _object$mapEntry : false;\n    message.uninterpretedOption = ((_object$uninterpreted3 = object.uninterpretedOption) === null || _object$uninterpreted3 === void 0 ? void 0 : _object$uninterpreted3.map(function (e) {\n      return UninterpretedOption.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.MessageOptions = MessageOptions;\nfunction createBaseFieldOptions() {\n  return {\n    ctype: 1,\n    packed: false,\n    jstype: 1,\n    lazy: false,\n    deprecated: false,\n    weak: false,\n    uninterpretedOption: []\n  };\n}\nvar FieldOptions = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.ctype !== 1) {\n      writer.uint32(8).int32(message.ctype);\n    }\n    if (message.packed === true) {\n      writer.uint32(16).bool(message.packed);\n    }\n    if (message.jstype !== 1) {\n      writer.uint32(48).int32(message.jstype);\n    }\n    if (message.lazy === true) {\n      writer.uint32(40).bool(message.lazy);\n    }\n    if (message.deprecated === true) {\n      writer.uint32(24).bool(message.deprecated);\n    }\n    if (message.weak === true) {\n      writer.uint32(80).bool(message.weak);\n    }\n    var _iterator24 = _createForOfIteratorHelper(message.uninterpretedOption),\n      _step24;\n    try {\n      for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n        var v = _step24.value;\n        UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator24.e(err);\n    } finally {\n      _iterator24.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseFieldOptions();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.ctype = reader.int32();\n          break;\n        case 2:\n          message.packed = reader.bool();\n          break;\n        case 6:\n          message.jstype = reader.int32();\n          break;\n        case 5:\n          message.lazy = reader.bool();\n          break;\n        case 3:\n          message.deprecated = reader.bool();\n          break;\n        case 10:\n          message.weak = reader.bool();\n          break;\n        case 999:\n          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$ctype, _object$packed, _object$jstype, _object$lazy, _object$deprecated3, _object$weak, _object$uninterpreted4;\n    var message = createBaseFieldOptions();\n    message.ctype = (_object$ctype = object.ctype) !== null && _object$ctype !== void 0 ? _object$ctype : 1;\n    message.packed = (_object$packed = object.packed) !== null && _object$packed !== void 0 ? _object$packed : false;\n    message.jstype = (_object$jstype = object.jstype) !== null && _object$jstype !== void 0 ? _object$jstype : 1;\n    message.lazy = (_object$lazy = object.lazy) !== null && _object$lazy !== void 0 ? _object$lazy : false;\n    message.deprecated = (_object$deprecated3 = object.deprecated) !== null && _object$deprecated3 !== void 0 ? _object$deprecated3 : false;\n    message.weak = (_object$weak = object.weak) !== null && _object$weak !== void 0 ? _object$weak : false;\n    message.uninterpretedOption = ((_object$uninterpreted4 = object.uninterpretedOption) === null || _object$uninterpreted4 === void 0 ? void 0 : _object$uninterpreted4.map(function (e) {\n      return UninterpretedOption.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.FieldOptions = FieldOptions;\nfunction createBaseOneofOptions() {\n  return {\n    uninterpretedOption: []\n  };\n}\nvar OneofOptions = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    var _iterator25 = _createForOfIteratorHelper(message.uninterpretedOption),\n      _step25;\n    try {\n      for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n        var v = _step25.value;\n        UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator25.e(err);\n    } finally {\n      _iterator25.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseOneofOptions();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 999:\n          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$uninterpreted5;\n    var message = createBaseOneofOptions();\n    message.uninterpretedOption = ((_object$uninterpreted5 = object.uninterpretedOption) === null || _object$uninterpreted5 === void 0 ? void 0 : _object$uninterpreted5.map(function (e) {\n      return UninterpretedOption.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.OneofOptions = OneofOptions;\nfunction createBaseEnumOptions() {\n  return {\n    allowAlias: false,\n    deprecated: false,\n    uninterpretedOption: []\n  };\n}\nvar EnumOptions = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.allowAlias === true) {\n      writer.uint32(16).bool(message.allowAlias);\n    }\n    if (message.deprecated === true) {\n      writer.uint32(24).bool(message.deprecated);\n    }\n    var _iterator26 = _createForOfIteratorHelper(message.uninterpretedOption),\n      _step26;\n    try {\n      for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n        var v = _step26.value;\n        UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator26.e(err);\n    } finally {\n      _iterator26.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseEnumOptions();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 2:\n          message.allowAlias = reader.bool();\n          break;\n        case 3:\n          message.deprecated = reader.bool();\n          break;\n        case 999:\n          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$allowAlias, _object$deprecated4, _object$uninterpreted6;\n    var message = createBaseEnumOptions();\n    message.allowAlias = (_object$allowAlias = object.allowAlias) !== null && _object$allowAlias !== void 0 ? _object$allowAlias : false;\n    message.deprecated = (_object$deprecated4 = object.deprecated) !== null && _object$deprecated4 !== void 0 ? _object$deprecated4 : false;\n    message.uninterpretedOption = ((_object$uninterpreted6 = object.uninterpretedOption) === null || _object$uninterpreted6 === void 0 ? void 0 : _object$uninterpreted6.map(function (e) {\n      return UninterpretedOption.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.EnumOptions = EnumOptions;\nfunction createBaseEnumValueOptions() {\n  return {\n    deprecated: false,\n    uninterpretedOption: []\n  };\n}\nvar EnumValueOptions = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.deprecated === true) {\n      writer.uint32(8).bool(message.deprecated);\n    }\n    var _iterator27 = _createForOfIteratorHelper(message.uninterpretedOption),\n      _step27;\n    try {\n      for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n        var v = _step27.value;\n        UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator27.e(err);\n    } finally {\n      _iterator27.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseEnumValueOptions();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.deprecated = reader.bool();\n          break;\n        case 999:\n          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$deprecated5, _object$uninterpreted7;\n    var message = createBaseEnumValueOptions();\n    message.deprecated = (_object$deprecated5 = object.deprecated) !== null && _object$deprecated5 !== void 0 ? _object$deprecated5 : false;\n    message.uninterpretedOption = ((_object$uninterpreted7 = object.uninterpretedOption) === null || _object$uninterpreted7 === void 0 ? void 0 : _object$uninterpreted7.map(function (e) {\n      return UninterpretedOption.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.EnumValueOptions = EnumValueOptions;\nfunction createBaseServiceOptions() {\n  return {\n    deprecated: false,\n    uninterpretedOption: []\n  };\n}\nvar ServiceOptions = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.deprecated === true) {\n      writer.uint32(264).bool(message.deprecated);\n    }\n    var _iterator28 = _createForOfIteratorHelper(message.uninterpretedOption),\n      _step28;\n    try {\n      for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n        var v = _step28.value;\n        UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator28.e(err);\n    } finally {\n      _iterator28.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseServiceOptions();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 33:\n          message.deprecated = reader.bool();\n          break;\n        case 999:\n          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$deprecated6, _object$uninterpreted8;\n    var message = createBaseServiceOptions();\n    message.deprecated = (_object$deprecated6 = object.deprecated) !== null && _object$deprecated6 !== void 0 ? _object$deprecated6 : false;\n    message.uninterpretedOption = ((_object$uninterpreted8 = object.uninterpretedOption) === null || _object$uninterpreted8 === void 0 ? void 0 : _object$uninterpreted8.map(function (e) {\n      return UninterpretedOption.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.ServiceOptions = ServiceOptions;\nfunction createBaseMethodOptions() {\n  return {\n    deprecated: false,\n    idempotencyLevel: 1,\n    uninterpretedOption: []\n  };\n}\nvar MethodOptions = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.deprecated === true) {\n      writer.uint32(264).bool(message.deprecated);\n    }\n    if (message.idempotencyLevel !== 1) {\n      writer.uint32(272).int32(message.idempotencyLevel);\n    }\n    var _iterator29 = _createForOfIteratorHelper(message.uninterpretedOption),\n      _step29;\n    try {\n      for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n        var v = _step29.value;\n        UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator29.e(err);\n    } finally {\n      _iterator29.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMethodOptions();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 33:\n          message.deprecated = reader.bool();\n          break;\n        case 34:\n          message.idempotencyLevel = reader.int32();\n          break;\n        case 999:\n          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$deprecated7, _object$idempotencyLe, _object$uninterpreted9;\n    var message = createBaseMethodOptions();\n    message.deprecated = (_object$deprecated7 = object.deprecated) !== null && _object$deprecated7 !== void 0 ? _object$deprecated7 : false;\n    message.idempotencyLevel = (_object$idempotencyLe = object.idempotencyLevel) !== null && _object$idempotencyLe !== void 0 ? _object$idempotencyLe : 1;\n    message.uninterpretedOption = ((_object$uninterpreted9 = object.uninterpretedOption) === null || _object$uninterpreted9 === void 0 ? void 0 : _object$uninterpreted9.map(function (e) {\n      return UninterpretedOption.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.MethodOptions = MethodOptions;\nfunction createBaseUninterpretedOption() {\n  return {\n    name: [],\n    identifierValue: \"\",\n    positiveIntValue: _helpers.Long.UZERO,\n    negativeIntValue: _helpers.Long.ZERO,\n    doubleValue: 0,\n    stringValue: new Uint8Array(),\n    aggregateValue: \"\"\n  };\n}\nvar UninterpretedOption = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    var _iterator30 = _createForOfIteratorHelper(message.name),\n      _step30;\n    try {\n      for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n        var v = _step30.value;\n        UninterpretedOption_NamePart.encode(v, writer.uint32(18).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator30.e(err);\n    } finally {\n      _iterator30.f();\n    }\n    if (message.identifierValue !== \"\") {\n      writer.uint32(26).string(message.identifierValue);\n    }\n    if (!message.positiveIntValue.isZero()) {\n      writer.uint32(32).uint64(message.positiveIntValue);\n    }\n    if (!message.negativeIntValue.isZero()) {\n      writer.uint32(40).int64(message.negativeIntValue);\n    }\n    if (message.doubleValue !== 0) {\n      writer.uint32(49)[\"double\"](message.doubleValue);\n    }\n    if (message.stringValue.length !== 0) {\n      writer.uint32(58).bytes(message.stringValue);\n    }\n    if (message.aggregateValue !== \"\") {\n      writer.uint32(66).string(message.aggregateValue);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseUninterpretedOption();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 2:\n          message.name.push(UninterpretedOption_NamePart.decode(reader, reader.uint32()));\n          break;\n        case 3:\n          message.identifierValue = reader.string();\n          break;\n        case 4:\n          message.positiveIntValue = reader.uint64();\n          break;\n        case 5:\n          message.negativeIntValue = reader.int64();\n          break;\n        case 6:\n          message.doubleValue = reader[\"double\"]();\n          break;\n        case 7:\n          message.stringValue = reader.bytes();\n          break;\n        case 8:\n          message.aggregateValue = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$name9, _object$identifierVal, _object$doubleValue, _object$stringValue, _object$aggregateValu;\n    var message = createBaseUninterpretedOption();\n    message.name = ((_object$name9 = object.name) === null || _object$name9 === void 0 ? void 0 : _object$name9.map(function (e) {\n      return UninterpretedOption_NamePart.fromPartial(e);\n    })) || [];\n    message.identifierValue = (_object$identifierVal = object.identifierValue) !== null && _object$identifierVal !== void 0 ? _object$identifierVal : \"\";\n    message.positiveIntValue = object.positiveIntValue !== undefined && object.positiveIntValue !== null ? _helpers.Long.fromValue(object.positiveIntValue) : _helpers.Long.UZERO;\n    message.negativeIntValue = object.negativeIntValue !== undefined && object.negativeIntValue !== null ? _helpers.Long.fromValue(object.negativeIntValue) : _helpers.Long.ZERO;\n    message.doubleValue = (_object$doubleValue = object.doubleValue) !== null && _object$doubleValue !== void 0 ? _object$doubleValue : 0;\n    message.stringValue = (_object$stringValue = object.stringValue) !== null && _object$stringValue !== void 0 ? _object$stringValue : new Uint8Array();\n    message.aggregateValue = (_object$aggregateValu = object.aggregateValue) !== null && _object$aggregateValu !== void 0 ? _object$aggregateValu : \"\";\n    return message;\n  }\n};\nexports.UninterpretedOption = UninterpretedOption;\nfunction createBaseUninterpretedOption_NamePart() {\n  return {\n    namePart: \"\",\n    isExtension: false\n  };\n}\nvar UninterpretedOption_NamePart = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.namePart !== \"\") {\n      writer.uint32(10).string(message.namePart);\n    }\n    if (message.isExtension === true) {\n      writer.uint32(16).bool(message.isExtension);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseUninterpretedOption_NamePart();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.namePart = reader.string();\n          break;\n        case 2:\n          message.isExtension = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$namePart, _object$isExtension;\n    var message = createBaseUninterpretedOption_NamePart();\n    message.namePart = (_object$namePart = object.namePart) !== null && _object$namePart !== void 0 ? _object$namePart : \"\";\n    message.isExtension = (_object$isExtension = object.isExtension) !== null && _object$isExtension !== void 0 ? _object$isExtension : false;\n    return message;\n  }\n};\nexports.UninterpretedOption_NamePart = UninterpretedOption_NamePart;\nfunction createBaseSourceCodeInfo() {\n  return {\n    location: []\n  };\n}\nvar SourceCodeInfo = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    var _iterator31 = _createForOfIteratorHelper(message.location),\n      _step31;\n    try {\n      for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n        var v = _step31.value;\n        SourceCodeInfo_Location.encode(v, writer.uint32(10).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator31.e(err);\n    } finally {\n      _iterator31.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseSourceCodeInfo();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.location.push(SourceCodeInfo_Location.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$location;\n    var message = createBaseSourceCodeInfo();\n    message.location = ((_object$location = object.location) === null || _object$location === void 0 ? void 0 : _object$location.map(function (e) {\n      return SourceCodeInfo_Location.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.SourceCodeInfo = SourceCodeInfo;\nfunction createBaseSourceCodeInfo_Location() {\n  return {\n    path: [],\n    span: [],\n    leadingComments: \"\",\n    trailingComments: \"\",\n    leadingDetachedComments: []\n  };\n}\nvar SourceCodeInfo_Location = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    writer.uint32(10).fork();\n    var _iterator32 = _createForOfIteratorHelper(message.path),\n      _step32;\n    try {\n      for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n        var v = _step32.value;\n        writer.int32(v);\n      }\n    } catch (err) {\n      _iterator32.e(err);\n    } finally {\n      _iterator32.f();\n    }\n    writer.ldelim();\n    writer.uint32(18).fork();\n    var _iterator33 = _createForOfIteratorHelper(message.span),\n      _step33;\n    try {\n      for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n        var _v16 = _step33.value;\n        writer.int32(_v16);\n      }\n    } catch (err) {\n      _iterator33.e(err);\n    } finally {\n      _iterator33.f();\n    }\n    writer.ldelim();\n    if (message.leadingComments !== \"\") {\n      writer.uint32(26).string(message.leadingComments);\n    }\n    if (message.trailingComments !== \"\") {\n      writer.uint32(34).string(message.trailingComments);\n    }\n    var _iterator34 = _createForOfIteratorHelper(message.leadingDetachedComments),\n      _step34;\n    try {\n      for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n        var _v17 = _step34.value;\n        writer.uint32(50).string(_v17);\n      }\n    } catch (err) {\n      _iterator34.e(err);\n    } finally {\n      _iterator34.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseSourceCodeInfo_Location();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if ((tag & 7) === 2) {\n            var end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.path.push(reader.int32());\n            }\n          } else {\n            message.path.push(reader.int32());\n          }\n          break;\n        case 2:\n          if ((tag & 7) === 2) {\n            var _end2 = reader.uint32() + reader.pos;\n            while (reader.pos < _end2) {\n              message.span.push(reader.int32());\n            }\n          } else {\n            message.span.push(reader.int32());\n          }\n          break;\n        case 3:\n          message.leadingComments = reader.string();\n          break;\n        case 4:\n          message.trailingComments = reader.string();\n          break;\n        case 6:\n          message.leadingDetachedComments.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$path, _object$span, _object$leadingCommen, _object$trailingComme, _object$leadingDetach;\n    var message = createBaseSourceCodeInfo_Location();\n    message.path = ((_object$path = object.path) === null || _object$path === void 0 ? void 0 : _object$path.map(function (e) {\n      return e;\n    })) || [];\n    message.span = ((_object$span = object.span) === null || _object$span === void 0 ? void 0 : _object$span.map(function (e) {\n      return e;\n    })) || [];\n    message.leadingComments = (_object$leadingCommen = object.leadingComments) !== null && _object$leadingCommen !== void 0 ? _object$leadingCommen : \"\";\n    message.trailingComments = (_object$trailingComme = object.trailingComments) !== null && _object$trailingComme !== void 0 ? _object$trailingComme : \"\";\n    message.leadingDetachedComments = ((_object$leadingDetach = object.leadingDetachedComments) === null || _object$leadingDetach === void 0 ? void 0 : _object$leadingDetach.map(function (e) {\n      return e;\n    })) || [];\n    return message;\n  }\n};\nexports.SourceCodeInfo_Location = SourceCodeInfo_Location;\nfunction createBaseGeneratedCodeInfo() {\n  return {\n    annotation: []\n  };\n}\nvar GeneratedCodeInfo = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    var _iterator35 = _createForOfIteratorHelper(message.annotation),\n      _step35;\n    try {\n      for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {\n        var v = _step35.value;\n        GeneratedCodeInfo_Annotation.encode(v, writer.uint32(10).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator35.e(err);\n    } finally {\n      _iterator35.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseGeneratedCodeInfo();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.annotation.push(GeneratedCodeInfo_Annotation.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$annotation;\n    var message = createBaseGeneratedCodeInfo();\n    message.annotation = ((_object$annotation = object.annotation) === null || _object$annotation === void 0 ? void 0 : _object$annotation.map(function (e) {\n      return GeneratedCodeInfo_Annotation.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.GeneratedCodeInfo = GeneratedCodeInfo;\nfunction createBaseGeneratedCodeInfo_Annotation() {\n  return {\n    path: [],\n    sourceFile: \"\",\n    begin: 0,\n    end: 0\n  };\n}\nvar GeneratedCodeInfo_Annotation = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    writer.uint32(10).fork();\n    var _iterator36 = _createForOfIteratorHelper(message.path),\n      _step36;\n    try {\n      for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {\n        var v = _step36.value;\n        writer.int32(v);\n      }\n    } catch (err) {\n      _iterator36.e(err);\n    } finally {\n      _iterator36.f();\n    }\n    writer.ldelim();\n    if (message.sourceFile !== \"\") {\n      writer.uint32(18).string(message.sourceFile);\n    }\n    if (message.begin !== 0) {\n      writer.uint32(24).int32(message.begin);\n    }\n    if (message.end !== 0) {\n      writer.uint32(32).int32(message.end);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseGeneratedCodeInfo_Annotation();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if ((tag & 7) === 2) {\n            var end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.path.push(reader.int32());\n            }\n          } else {\n            message.path.push(reader.int32());\n          }\n          break;\n        case 2:\n          message.sourceFile = reader.string();\n          break;\n        case 3:\n          message.begin = reader.int32();\n          break;\n        case 4:\n          message.end = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$path2, _object$sourceFile, _object$begin, _object$end4;\n    var message = createBaseGeneratedCodeInfo_Annotation();\n    message.path = ((_object$path2 = object.path) === null || _object$path2 === void 0 ? void 0 : _object$path2.map(function (e) {\n      return e;\n    })) || [];\n    message.sourceFile = (_object$sourceFile = object.sourceFile) !== null && _object$sourceFile !== void 0 ? _object$sourceFile : \"\";\n    message.begin = (_object$begin = object.begin) !== null && _object$begin !== void 0 ? _object$begin : 0;\n    message.end = (_object$end4 = object.end) !== null && _object$end4 !== void 0 ? _object$end4 : 0;\n    return message;\n  }\n};\nexports.GeneratedCodeInfo_Annotation = GeneratedCodeInfo_Annotation;","map":null,"metadata":{},"sourceType":"script"}