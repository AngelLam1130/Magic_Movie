{"ast":null,"code":"\"use strict\";\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WeightedVoteOption = exports.VotingParams = exports.VoteOptionSDKType = exports.VoteOption = exports.Vote = exports.TextProposal = exports.TallyResult = exports.TallyParams = exports.ProposalStatusSDKType = exports.ProposalStatus = exports.Proposal = exports.DepositParams = exports.Deposit = void 0;\nexports.proposalStatusFromJSON = proposalStatusFromJSON;\nexports.proposalStatusToJSON = proposalStatusToJSON;\nexports.voteOptionFromJSON = voteOptionFromJSON;\nexports.voteOptionToJSON = voteOptionToJSON;\nvar _coin = require(\"../../base/v1beta1/coin\");\nvar _any = require(\"../../../google/protobuf/any\");\nvar _timestamp = require(\"../../../google/protobuf/timestamp\");\nvar _duration = require(\"../../../google/protobuf/duration\");\nvar _helpers = require(\"../../../helpers\");\nvar _m0 = _interopRequireWildcard(require(\"protobufjs/minimal\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj[\"default\"] = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\n/** VoteOption enumerates the valid vote options for a given governance proposal. */\nvar VoteOption;\nexports.VoteOption = VoteOption;\n(function (VoteOption) {\n  VoteOption[VoteOption[\"VOTE_OPTION_UNSPECIFIED\"] = 0] = \"VOTE_OPTION_UNSPECIFIED\";\n  VoteOption[VoteOption[\"VOTE_OPTION_YES\"] = 1] = \"VOTE_OPTION_YES\";\n  VoteOption[VoteOption[\"VOTE_OPTION_ABSTAIN\"] = 2] = \"VOTE_OPTION_ABSTAIN\";\n  VoteOption[VoteOption[\"VOTE_OPTION_NO\"] = 3] = \"VOTE_OPTION_NO\";\n  VoteOption[VoteOption[\"VOTE_OPTION_NO_WITH_VETO\"] = 4] = \"VOTE_OPTION_NO_WITH_VETO\";\n  VoteOption[VoteOption[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(VoteOption || (exports.VoteOption = VoteOption = {}));\nvar VoteOptionSDKType = VoteOption;\nexports.VoteOptionSDKType = VoteOptionSDKType;\nfunction voteOptionFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"VOTE_OPTION_UNSPECIFIED\":\n      return VoteOption.VOTE_OPTION_UNSPECIFIED;\n    case 1:\n    case \"VOTE_OPTION_YES\":\n      return VoteOption.VOTE_OPTION_YES;\n    case 2:\n    case \"VOTE_OPTION_ABSTAIN\":\n      return VoteOption.VOTE_OPTION_ABSTAIN;\n    case 3:\n    case \"VOTE_OPTION_NO\":\n      return VoteOption.VOTE_OPTION_NO;\n    case 4:\n    case \"VOTE_OPTION_NO_WITH_VETO\":\n      return VoteOption.VOTE_OPTION_NO_WITH_VETO;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return VoteOption.UNRECOGNIZED;\n  }\n}\nfunction voteOptionToJSON(object) {\n  switch (object) {\n    case VoteOption.VOTE_OPTION_UNSPECIFIED:\n      return \"VOTE_OPTION_UNSPECIFIED\";\n    case VoteOption.VOTE_OPTION_YES:\n      return \"VOTE_OPTION_YES\";\n    case VoteOption.VOTE_OPTION_ABSTAIN:\n      return \"VOTE_OPTION_ABSTAIN\";\n    case VoteOption.VOTE_OPTION_NO:\n      return \"VOTE_OPTION_NO\";\n    case VoteOption.VOTE_OPTION_NO_WITH_VETO:\n      return \"VOTE_OPTION_NO_WITH_VETO\";\n    case VoteOption.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n/** ProposalStatus enumerates the valid statuses of a proposal. */\nvar ProposalStatus;\nexports.ProposalStatus = ProposalStatus;\n(function (ProposalStatus) {\n  ProposalStatus[ProposalStatus[\"PROPOSAL_STATUS_UNSPECIFIED\"] = 0] = \"PROPOSAL_STATUS_UNSPECIFIED\";\n  ProposalStatus[ProposalStatus[\"PROPOSAL_STATUS_DEPOSIT_PERIOD\"] = 1] = \"PROPOSAL_STATUS_DEPOSIT_PERIOD\";\n  ProposalStatus[ProposalStatus[\"PROPOSAL_STATUS_VOTING_PERIOD\"] = 2] = \"PROPOSAL_STATUS_VOTING_PERIOD\";\n  ProposalStatus[ProposalStatus[\"PROPOSAL_STATUS_PASSED\"] = 3] = \"PROPOSAL_STATUS_PASSED\";\n  ProposalStatus[ProposalStatus[\"PROPOSAL_STATUS_REJECTED\"] = 4] = \"PROPOSAL_STATUS_REJECTED\";\n  ProposalStatus[ProposalStatus[\"PROPOSAL_STATUS_FAILED\"] = 5] = \"PROPOSAL_STATUS_FAILED\";\n  ProposalStatus[ProposalStatus[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ProposalStatus || (exports.ProposalStatus = ProposalStatus = {}));\nvar ProposalStatusSDKType = ProposalStatus;\nexports.ProposalStatusSDKType = ProposalStatusSDKType;\nfunction proposalStatusFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"PROPOSAL_STATUS_UNSPECIFIED\":\n      return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;\n    case 1:\n    case \"PROPOSAL_STATUS_DEPOSIT_PERIOD\":\n      return ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD;\n    case 2:\n    case \"PROPOSAL_STATUS_VOTING_PERIOD\":\n      return ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD;\n    case 3:\n    case \"PROPOSAL_STATUS_PASSED\":\n      return ProposalStatus.PROPOSAL_STATUS_PASSED;\n    case 4:\n    case \"PROPOSAL_STATUS_REJECTED\":\n      return ProposalStatus.PROPOSAL_STATUS_REJECTED;\n    case 5:\n    case \"PROPOSAL_STATUS_FAILED\":\n      return ProposalStatus.PROPOSAL_STATUS_FAILED;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return ProposalStatus.UNRECOGNIZED;\n  }\n}\nfunction proposalStatusToJSON(object) {\n  switch (object) {\n    case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:\n      return \"PROPOSAL_STATUS_UNSPECIFIED\";\n    case ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD:\n      return \"PROPOSAL_STATUS_DEPOSIT_PERIOD\";\n    case ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD:\n      return \"PROPOSAL_STATUS_VOTING_PERIOD\";\n    case ProposalStatus.PROPOSAL_STATUS_PASSED:\n      return \"PROPOSAL_STATUS_PASSED\";\n    case ProposalStatus.PROPOSAL_STATUS_REJECTED:\n      return \"PROPOSAL_STATUS_REJECTED\";\n    case ProposalStatus.PROPOSAL_STATUS_FAILED:\n      return \"PROPOSAL_STATUS_FAILED\";\n    case ProposalStatus.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n/**\n * WeightedVoteOption defines a unit of vote for vote split.\n * \n * Since: cosmos-sdk 0.43\n */\n\nfunction createBaseWeightedVoteOption() {\n  return {\n    option: 0,\n    weight: \"\"\n  };\n}\nvar WeightedVoteOption = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.option !== 0) {\n      writer.uint32(8).int32(message.option);\n    }\n    if (message.weight !== \"\") {\n      writer.uint32(18).string(message.weight);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseWeightedVoteOption();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.option = reader.int32();\n          break;\n        case 2:\n          message.weight = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$option, _object$weight;\n    var message = createBaseWeightedVoteOption();\n    message.option = (_object$option = object.option) !== null && _object$option !== void 0 ? _object$option : 0;\n    message.weight = (_object$weight = object.weight) !== null && _object$weight !== void 0 ? _object$weight : \"\";\n    return message;\n  }\n};\nexports.WeightedVoteOption = WeightedVoteOption;\nfunction createBaseTextProposal() {\n  return {\n    title: \"\",\n    description: \"\"\n  };\n}\nvar TextProposal = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.title !== \"\") {\n      writer.uint32(10).string(message.title);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(18).string(message.description);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseTextProposal();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.title = reader.string();\n          break;\n        case 2:\n          message.description = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$title, _object$description;\n    var message = createBaseTextProposal();\n    message.title = (_object$title = object.title) !== null && _object$title !== void 0 ? _object$title : \"\";\n    message.description = (_object$description = object.description) !== null && _object$description !== void 0 ? _object$description : \"\";\n    return message;\n  }\n};\nexports.TextProposal = TextProposal;\nfunction createBaseDeposit() {\n  return {\n    proposalId: _helpers.Long.UZERO,\n    depositor: \"\",\n    amount: []\n  };\n}\nvar Deposit = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    if (message.depositor !== \"\") {\n      writer.uint32(18).string(message.depositor);\n    }\n    var _iterator = _createForOfIteratorHelper(message.amount),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var v = _step.value;\n        _coin.Coin.encode(v, writer.uint32(26).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseDeposit();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64();\n          break;\n        case 2:\n          message.depositor = reader.string();\n          break;\n        case 3:\n          message.amount.push(_coin.Coin.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$depositor, _object$amount;\n    var message = createBaseDeposit();\n    message.proposalId = object.proposalId !== undefined && object.proposalId !== null ? _helpers.Long.fromValue(object.proposalId) : _helpers.Long.UZERO;\n    message.depositor = (_object$depositor = object.depositor) !== null && _object$depositor !== void 0 ? _object$depositor : \"\";\n    message.amount = ((_object$amount = object.amount) === null || _object$amount === void 0 ? void 0 : _object$amount.map(function (e) {\n      return _coin.Coin.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.Deposit = Deposit;\nfunction createBaseProposal() {\n  return {\n    proposalId: _helpers.Long.UZERO,\n    content: undefined,\n    status: 0,\n    finalTallyResult: TallyResult.fromPartial({}),\n    submitTime: undefined,\n    depositEndTime: undefined,\n    totalDeposit: [],\n    votingStartTime: undefined,\n    votingEndTime: undefined\n  };\n}\nvar Proposal = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    if (message.content !== undefined) {\n      _any.Any.encode(message.content, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.status !== 0) {\n      writer.uint32(24).int32(message.status);\n    }\n    if (message.finalTallyResult !== undefined) {\n      TallyResult.encode(message.finalTallyResult, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.submitTime !== undefined) {\n      _timestamp.Timestamp.encode((0, _helpers.toTimestamp)(message.submitTime), writer.uint32(42).fork()).ldelim();\n    }\n    if (message.depositEndTime !== undefined) {\n      _timestamp.Timestamp.encode((0, _helpers.toTimestamp)(message.depositEndTime), writer.uint32(50).fork()).ldelim();\n    }\n    var _iterator2 = _createForOfIteratorHelper(message.totalDeposit),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var v = _step2.value;\n        _coin.Coin.encode(v, writer.uint32(58).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    if (message.votingStartTime !== undefined) {\n      _timestamp.Timestamp.encode((0, _helpers.toTimestamp)(message.votingStartTime), writer.uint32(66).fork()).ldelim();\n    }\n    if (message.votingEndTime !== undefined) {\n      _timestamp.Timestamp.encode((0, _helpers.toTimestamp)(message.votingEndTime), writer.uint32(74).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseProposal();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64();\n          break;\n        case 2:\n          message.content = _any.Any.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.status = reader.int32();\n          break;\n        case 4:\n          message.finalTallyResult = TallyResult.decode(reader, reader.uint32());\n          break;\n        case 5:\n          message.submitTime = (0, _helpers.fromTimestamp)(_timestamp.Timestamp.decode(reader, reader.uint32()));\n          break;\n        case 6:\n          message.depositEndTime = (0, _helpers.fromTimestamp)(_timestamp.Timestamp.decode(reader, reader.uint32()));\n          break;\n        case 7:\n          message.totalDeposit.push(_coin.Coin.decode(reader, reader.uint32()));\n          break;\n        case 8:\n          message.votingStartTime = (0, _helpers.fromTimestamp)(_timestamp.Timestamp.decode(reader, reader.uint32()));\n          break;\n        case 9:\n          message.votingEndTime = (0, _helpers.fromTimestamp)(_timestamp.Timestamp.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$status, _object$submitTime, _object$depositEndTim, _object$totalDeposit, _object$votingStartTi, _object$votingEndTime;\n    var message = createBaseProposal();\n    message.proposalId = object.proposalId !== undefined && object.proposalId !== null ? _helpers.Long.fromValue(object.proposalId) : _helpers.Long.UZERO;\n    message.content = object.content !== undefined && object.content !== null ? _any.Any.fromPartial(object.content) : undefined;\n    message.status = (_object$status = object.status) !== null && _object$status !== void 0 ? _object$status : 0;\n    message.finalTallyResult = object.finalTallyResult !== undefined && object.finalTallyResult !== null ? TallyResult.fromPartial(object.finalTallyResult) : undefined;\n    message.submitTime = (_object$submitTime = object.submitTime) !== null && _object$submitTime !== void 0 ? _object$submitTime : undefined;\n    message.depositEndTime = (_object$depositEndTim = object.depositEndTime) !== null && _object$depositEndTim !== void 0 ? _object$depositEndTim : undefined;\n    message.totalDeposit = ((_object$totalDeposit = object.totalDeposit) === null || _object$totalDeposit === void 0 ? void 0 : _object$totalDeposit.map(function (e) {\n      return _coin.Coin.fromPartial(e);\n    })) || [];\n    message.votingStartTime = (_object$votingStartTi = object.votingStartTime) !== null && _object$votingStartTi !== void 0 ? _object$votingStartTi : undefined;\n    message.votingEndTime = (_object$votingEndTime = object.votingEndTime) !== null && _object$votingEndTime !== void 0 ? _object$votingEndTime : undefined;\n    return message;\n  }\n};\nexports.Proposal = Proposal;\nfunction createBaseTallyResult() {\n  return {\n    yes: \"\",\n    abstain: \"\",\n    no: \"\",\n    noWithVeto: \"\"\n  };\n}\nvar TallyResult = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.yes !== \"\") {\n      writer.uint32(10).string(message.yes);\n    }\n    if (message.abstain !== \"\") {\n      writer.uint32(18).string(message.abstain);\n    }\n    if (message.no !== \"\") {\n      writer.uint32(26).string(message.no);\n    }\n    if (message.noWithVeto !== \"\") {\n      writer.uint32(34).string(message.noWithVeto);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseTallyResult();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.yes = reader.string();\n          break;\n        case 2:\n          message.abstain = reader.string();\n          break;\n        case 3:\n          message.no = reader.string();\n          break;\n        case 4:\n          message.noWithVeto = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$yes, _object$abstain, _object$no, _object$noWithVeto;\n    var message = createBaseTallyResult();\n    message.yes = (_object$yes = object.yes) !== null && _object$yes !== void 0 ? _object$yes : \"\";\n    message.abstain = (_object$abstain = object.abstain) !== null && _object$abstain !== void 0 ? _object$abstain : \"\";\n    message.no = (_object$no = object.no) !== null && _object$no !== void 0 ? _object$no : \"\";\n    message.noWithVeto = (_object$noWithVeto = object.noWithVeto) !== null && _object$noWithVeto !== void 0 ? _object$noWithVeto : \"\";\n    return message;\n  }\n};\nexports.TallyResult = TallyResult;\nfunction createBaseVote() {\n  return {\n    proposalId: _helpers.Long.UZERO,\n    voter: \"\",\n    option: 0,\n    options: []\n  };\n}\nvar Vote = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    if (message.voter !== \"\") {\n      writer.uint32(18).string(message.voter);\n    }\n    if (message.option !== 0) {\n      writer.uint32(24).int32(message.option);\n    }\n    var _iterator3 = _createForOfIteratorHelper(message.options),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var v = _step3.value;\n        WeightedVoteOption.encode(v, writer.uint32(34).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseVote();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64();\n          break;\n        case 2:\n          message.voter = reader.string();\n          break;\n        case 3:\n          message.option = reader.int32();\n          break;\n        case 4:\n          message.options.push(WeightedVoteOption.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$voter, _object$option2, _object$options;\n    var message = createBaseVote();\n    message.proposalId = object.proposalId !== undefined && object.proposalId !== null ? _helpers.Long.fromValue(object.proposalId) : _helpers.Long.UZERO;\n    message.voter = (_object$voter = object.voter) !== null && _object$voter !== void 0 ? _object$voter : \"\";\n    message.option = (_object$option2 = object.option) !== null && _object$option2 !== void 0 ? _object$option2 : 0;\n    message.options = ((_object$options = object.options) === null || _object$options === void 0 ? void 0 : _object$options.map(function (e) {\n      return WeightedVoteOption.fromPartial(e);\n    })) || [];\n    return message;\n  }\n};\nexports.Vote = Vote;\nfunction createBaseDepositParams() {\n  return {\n    minDeposit: [],\n    maxDepositPeriod: undefined\n  };\n}\nvar DepositParams = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    var _iterator4 = _createForOfIteratorHelper(message.minDeposit),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var v = _step4.value;\n        _coin.Coin.encode(v, writer.uint32(10).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n    if (message.maxDepositPeriod !== undefined) {\n      _duration.Duration.encode(message.maxDepositPeriod, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseDepositParams();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.minDeposit.push(_coin.Coin.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.maxDepositPeriod = _duration.Duration.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$minDeposit;\n    var message = createBaseDepositParams();\n    message.minDeposit = ((_object$minDeposit = object.minDeposit) === null || _object$minDeposit === void 0 ? void 0 : _object$minDeposit.map(function (e) {\n      return _coin.Coin.fromPartial(e);\n    })) || [];\n    message.maxDepositPeriod = object.maxDepositPeriod !== undefined && object.maxDepositPeriod !== null ? _duration.Duration.fromPartial(object.maxDepositPeriod) : undefined;\n    return message;\n  }\n};\nexports.DepositParams = DepositParams;\nfunction createBaseVotingParams() {\n  return {\n    votingPeriod: undefined\n  };\n}\nvar VotingParams = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.votingPeriod !== undefined) {\n      _duration.Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseVotingParams();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.votingPeriod = _duration.Duration.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = createBaseVotingParams();\n    message.votingPeriod = object.votingPeriod !== undefined && object.votingPeriod !== null ? _duration.Duration.fromPartial(object.votingPeriod) : undefined;\n    return message;\n  }\n};\nexports.VotingParams = VotingParams;\nfunction createBaseTallyParams() {\n  return {\n    quorum: new Uint8Array(),\n    threshold: new Uint8Array(),\n    vetoThreshold: new Uint8Array()\n  };\n}\nvar TallyParams = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.quorum.length !== 0) {\n      writer.uint32(10).bytes(message.quorum);\n    }\n    if (message.threshold.length !== 0) {\n      writer.uint32(18).bytes(message.threshold);\n    }\n    if (message.vetoThreshold.length !== 0) {\n      writer.uint32(26).bytes(message.vetoThreshold);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseTallyParams();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.quorum = reader.bytes();\n          break;\n        case 2:\n          message.threshold = reader.bytes();\n          break;\n        case 3:\n          message.vetoThreshold = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$quorum, _object$threshold, _object$vetoThreshold;\n    var message = createBaseTallyParams();\n    message.quorum = (_object$quorum = object.quorum) !== null && _object$quorum !== void 0 ? _object$quorum : new Uint8Array();\n    message.threshold = (_object$threshold = object.threshold) !== null && _object$threshold !== void 0 ? _object$threshold : new Uint8Array();\n    message.vetoThreshold = (_object$vetoThreshold = object.vetoThreshold) !== null && _object$vetoThreshold !== void 0 ? _object$vetoThreshold : new Uint8Array();\n    return message;\n  }\n};\nexports.TallyParams = TallyParams;","map":null,"metadata":{},"sourceType":"script"}