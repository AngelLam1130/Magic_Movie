{"ast":null,"code":"\"use strict\";\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MsgUndelegateResponse = exports.MsgUndelegate = exports.MsgEditValidatorResponse = exports.MsgEditValidator = exports.MsgDelegateResponse = exports.MsgDelegate = exports.MsgCreateValidatorResponse = exports.MsgCreateValidator = exports.MsgBeginRedelegateResponse = exports.MsgBeginRedelegate = void 0;\nvar _staking = require(\"./staking\");\nvar _any = require(\"../../../google/protobuf/any\");\nvar _coin = require(\"../../base/v1beta1/coin\");\nvar _timestamp = require(\"../../../google/protobuf/timestamp\");\nvar _m0 = _interopRequireWildcard(require(\"protobufjs/minimal\"));\nvar _helpers = require(\"../../../helpers\");\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj[\"default\"] = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction createBaseMsgCreateValidator() {\n  return {\n    description: _staking.Description.fromPartial({}),\n    commission: _staking.CommissionRates.fromPartial({}),\n    minSelfDelegation: \"\",\n    delegatorAddress: \"\",\n    validatorAddress: \"\",\n    pubkey: undefined,\n    value: undefined\n  };\n}\nvar MsgCreateValidator = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.description !== undefined) {\n      _staking.Description.encode(message.description, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.commission !== undefined) {\n      _staking.CommissionRates.encode(message.commission, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.minSelfDelegation !== \"\") {\n      writer.uint32(26).string(message.minSelfDelegation);\n    }\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(34).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(42).string(message.validatorAddress);\n    }\n    if (message.pubkey !== undefined) {\n      _any.Any.encode(message.pubkey, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.value !== undefined) {\n      _coin.Coin.encode(message.value, writer.uint32(58).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgCreateValidator();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.description = _staking.Description.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.commission = _staking.CommissionRates.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.minSelfDelegation = reader.string();\n          break;\n        case 4:\n          message.delegatorAddress = reader.string();\n          break;\n        case 5:\n          message.validatorAddress = reader.string();\n          break;\n        case 6:\n          message.pubkey = _any.Any.decode(reader, reader.uint32());\n          break;\n        case 7:\n          message.value = _coin.Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$minSelfDelega, _object$delegatorAddr, _object$validatorAddr;\n    var message = createBaseMsgCreateValidator();\n    message.description = object.description !== undefined && object.description !== null ? _staking.Description.fromPartial(object.description) : undefined;\n    message.commission = object.commission !== undefined && object.commission !== null ? _staking.CommissionRates.fromPartial(object.commission) : undefined;\n    message.minSelfDelegation = (_object$minSelfDelega = object.minSelfDelegation) !== null && _object$minSelfDelega !== void 0 ? _object$minSelfDelega : \"\";\n    message.delegatorAddress = (_object$delegatorAddr = object.delegatorAddress) !== null && _object$delegatorAddr !== void 0 ? _object$delegatorAddr : \"\";\n    message.validatorAddress = (_object$validatorAddr = object.validatorAddress) !== null && _object$validatorAddr !== void 0 ? _object$validatorAddr : \"\";\n    message.pubkey = object.pubkey !== undefined && object.pubkey !== null ? _any.Any.fromPartial(object.pubkey) : undefined;\n    message.value = object.value !== undefined && object.value !== null ? _coin.Coin.fromPartial(object.value) : undefined;\n    return message;\n  }\n};\nexports.MsgCreateValidator = MsgCreateValidator;\nfunction createBaseMsgCreateValidatorResponse() {\n  return {};\n}\nvar MsgCreateValidatorResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgCreateValidatorResponse();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = createBaseMsgCreateValidatorResponse();\n    return message;\n  }\n};\nexports.MsgCreateValidatorResponse = MsgCreateValidatorResponse;\nfunction createBaseMsgEditValidator() {\n  return {\n    description: _staking.Description.fromPartial({}),\n    validatorAddress: \"\",\n    commissionRate: \"\",\n    minSelfDelegation: \"\"\n  };\n}\nvar MsgEditValidator = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.description !== undefined) {\n      _staking.Description.encode(message.description, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    if (message.commissionRate !== \"\") {\n      writer.uint32(26).string(message.commissionRate);\n    }\n    if (message.minSelfDelegation !== \"\") {\n      writer.uint32(34).string(message.minSelfDelegation);\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgEditValidator();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.description = _staking.Description.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        case 3:\n          message.commissionRate = reader.string();\n          break;\n        case 4:\n          message.minSelfDelegation = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$validatorAddr2, _object$commissionRat, _object$minSelfDelega2;\n    var message = createBaseMsgEditValidator();\n    message.description = object.description !== undefined && object.description !== null ? _staking.Description.fromPartial(object.description) : undefined;\n    message.validatorAddress = (_object$validatorAddr2 = object.validatorAddress) !== null && _object$validatorAddr2 !== void 0 ? _object$validatorAddr2 : \"\";\n    message.commissionRate = (_object$commissionRat = object.commissionRate) !== null && _object$commissionRat !== void 0 ? _object$commissionRat : \"\";\n    message.minSelfDelegation = (_object$minSelfDelega2 = object.minSelfDelegation) !== null && _object$minSelfDelega2 !== void 0 ? _object$minSelfDelega2 : \"\";\n    return message;\n  }\n};\nexports.MsgEditValidator = MsgEditValidator;\nfunction createBaseMsgEditValidatorResponse() {\n  return {};\n}\nvar MsgEditValidatorResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgEditValidatorResponse();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = createBaseMsgEditValidatorResponse();\n    return message;\n  }\n};\nexports.MsgEditValidatorResponse = MsgEditValidatorResponse;\nfunction createBaseMsgDelegate() {\n  return {\n    delegatorAddress: \"\",\n    validatorAddress: \"\",\n    amount: undefined\n  };\n}\nvar MsgDelegate = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    if (message.amount !== undefined) {\n      _coin.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgDelegate();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        case 3:\n          message.amount = _coin.Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$delegatorAddr2, _object$validatorAddr3;\n    var message = createBaseMsgDelegate();\n    message.delegatorAddress = (_object$delegatorAddr2 = object.delegatorAddress) !== null && _object$delegatorAddr2 !== void 0 ? _object$delegatorAddr2 : \"\";\n    message.validatorAddress = (_object$validatorAddr3 = object.validatorAddress) !== null && _object$validatorAddr3 !== void 0 ? _object$validatorAddr3 : \"\";\n    message.amount = object.amount !== undefined && object.amount !== null ? _coin.Coin.fromPartial(object.amount) : undefined;\n    return message;\n  }\n};\nexports.MsgDelegate = MsgDelegate;\nfunction createBaseMsgDelegateResponse() {\n  return {};\n}\nvar MsgDelegateResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgDelegateResponse();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = createBaseMsgDelegateResponse();\n    return message;\n  }\n};\nexports.MsgDelegateResponse = MsgDelegateResponse;\nfunction createBaseMsgBeginRedelegate() {\n  return {\n    delegatorAddress: \"\",\n    validatorSrcAddress: \"\",\n    validatorDstAddress: \"\",\n    amount: undefined\n  };\n}\nvar MsgBeginRedelegate = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorSrcAddress !== \"\") {\n      writer.uint32(18).string(message.validatorSrcAddress);\n    }\n    if (message.validatorDstAddress !== \"\") {\n      writer.uint32(26).string(message.validatorDstAddress);\n    }\n    if (message.amount !== undefined) {\n      _coin.Coin.encode(message.amount, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgBeginRedelegate();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorSrcAddress = reader.string();\n          break;\n        case 3:\n          message.validatorDstAddress = reader.string();\n          break;\n        case 4:\n          message.amount = _coin.Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$delegatorAddr3, _object$validatorSrcA, _object$validatorDstA;\n    var message = createBaseMsgBeginRedelegate();\n    message.delegatorAddress = (_object$delegatorAddr3 = object.delegatorAddress) !== null && _object$delegatorAddr3 !== void 0 ? _object$delegatorAddr3 : \"\";\n    message.validatorSrcAddress = (_object$validatorSrcA = object.validatorSrcAddress) !== null && _object$validatorSrcA !== void 0 ? _object$validatorSrcA : \"\";\n    message.validatorDstAddress = (_object$validatorDstA = object.validatorDstAddress) !== null && _object$validatorDstA !== void 0 ? _object$validatorDstA : \"\";\n    message.amount = object.amount !== undefined && object.amount !== null ? _coin.Coin.fromPartial(object.amount) : undefined;\n    return message;\n  }\n};\nexports.MsgBeginRedelegate = MsgBeginRedelegate;\nfunction createBaseMsgBeginRedelegateResponse() {\n  return {\n    completionTime: undefined\n  };\n}\nvar MsgBeginRedelegateResponse = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.completionTime !== undefined) {\n      _timestamp.Timestamp.encode((0, _helpers.toTimestamp)(message.completionTime), writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgBeginRedelegateResponse();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.completionTime = (0, _helpers.fromTimestamp)(_timestamp.Timestamp.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$completionTim;\n    var message = createBaseMsgBeginRedelegateResponse();\n    message.completionTime = (_object$completionTim = object.completionTime) !== null && _object$completionTim !== void 0 ? _object$completionTim : undefined;\n    return message;\n  }\n};\nexports.MsgBeginRedelegateResponse = MsgBeginRedelegateResponse;\nfunction createBaseMsgUndelegate() {\n  return {\n    delegatorAddress: \"\",\n    validatorAddress: \"\",\n    amount: undefined\n  };\n}\nvar MsgUndelegate = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    if (message.amount !== undefined) {\n      _coin.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgUndelegate();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        case 3:\n          message.amount = _coin.Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$delegatorAddr4, _object$validatorAddr4;\n    var message = createBaseMsgUndelegate();\n    message.delegatorAddress = (_object$delegatorAddr4 = object.delegatorAddress) !== null && _object$delegatorAddr4 !== void 0 ? _object$delegatorAddr4 : \"\";\n    message.validatorAddress = (_object$validatorAddr4 = object.validatorAddress) !== null && _object$validatorAddr4 !== void 0 ? _object$validatorAddr4 : \"\";\n    message.amount = object.amount !== undefined && object.amount !== null ? _coin.Coin.fromPartial(object.amount) : undefined;\n    return message;\n  }\n};\nexports.MsgUndelegate = MsgUndelegate;\nfunction createBaseMsgUndelegateResponse() {\n  return {\n    completionTime: undefined\n  };\n}\nvar MsgUndelegateResponse = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();\n    if (message.completionTime !== undefined) {\n      _timestamp.Timestamp.encode((0, _helpers.toTimestamp)(message.completionTime), writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = createBaseMsgUndelegateResponse();\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.completionTime = (0, _helpers.fromTimestamp)(_timestamp.Timestamp.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial: function fromPartial(object) {\n    var _object$completionTim2;\n    var message = createBaseMsgUndelegateResponse();\n    message.completionTime = (_object$completionTim2 = object.completionTime) !== null && _object$completionTim2 !== void 0 ? _object$completionTim2 : undefined;\n    return message;\n  }\n};\nexports.MsgUndelegateResponse = MsgUndelegateResponse;","map":null,"metadata":{},"sourceType":"script"}