{"ast":null,"code":"'use strict';\n\nvar _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault');\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.verifyDigest32 = exports.pubKeyToKeyPair = exports.pubKeyToBytes = exports.isValidSeiAddress = exports.getAddressFromPubKey = void 0;\nvar _encoding = require('@cosmjs/encoding');\nvar _cryptoJs = _interopRequireDefault(require('crypto-js'));\nvar _elliptic = require('elliptic');\nvar isValidSeiAddress = function isValidSeiAddress(address) {\n  try {\n    var _fromBech = (0, _encoding.fromBech32)(address),\n      prefix = _fromBech.prefix;\n    return prefix && prefix === 'sei';\n  } catch (e) {\n    return false;\n  }\n};\nexports.isValidSeiAddress = isValidSeiAddress;\nvar pubKeyToKeyPair = function pubKeyToKeyPair(pubKey) {\n  var secp256k1 = new _elliptic.ec('secp256k1');\n  return secp256k1.keyFromPublic(Buffer.from(pubKey).toString('hex'), 'hex');\n};\nexports.pubKeyToKeyPair = pubKeyToKeyPair;\nvar pubKeyToBytes = function pubKeyToBytes(pubKey, uncompressed) {\n  if (uncompressed && pubKey.length === 65) {\n    return pubKey;\n  }\n  if (!uncompressed && pubKey.length === 33) {\n    return pubKey;\n  }\n  var keyPair = pubKeyToKeyPair(pubKey);\n  if (uncompressed) {\n    return new Uint8Array(Buffer.from(keyPair.getPublic().encode('hex', false), 'hex'));\n  } else {\n    return new Uint8Array(Buffer.from(keyPair.getPublic().encodeCompressed('hex'), 'hex'));\n  }\n};\nexports.pubKeyToBytes = pubKeyToBytes;\nvar getAddressFromPubKey = function getAddressFromPubKey(pubKey) {\n  var hash = _cryptoJs['default'].SHA256(_cryptoJs['default'].lib.WordArray.create(pubKeyToBytes(pubKey))).toString();\n  hash = _cryptoJs['default'].RIPEMD160(_cryptoJs['default'].enc.Hex.parse(hash)).toString();\n  return new Uint8Array(Buffer.from(hash, 'hex'));\n};\nexports.getAddressFromPubKey = getAddressFromPubKey;\nvar verifyDigest32 = function verifyDigest32(digest, signature, pubKey) {\n  if (digest.length !== 32) {\n    throw new Error('Invalid length of digest to verify: '.concat(digest.length));\n  }\n  if (signature.length !== 64) {\n    throw new Error('Invalid length of signature: '.concat(signature.length));\n  }\n  var secp256k1 = new _elliptic.ec('secp256k1');\n  var r = signature.slice(0, 32);\n  var s = signature.slice(32);\n  return secp256k1.verify(digest, {\n    r: Buffer.from(r).toString('hex'),\n    s: Buffer.from(s).toString('hex')\n  }, pubKeyToKeyPair(pubKey));\n};\nexports.verifyDigest32 = verifyDigest32;","map":null,"metadata":{},"sourceType":"script"}