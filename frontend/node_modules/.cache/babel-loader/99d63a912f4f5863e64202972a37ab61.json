{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nvar _typeof3 = require(\"@babel/runtime/helpers/typeof\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"Long\", {\n  enumerable: true,\n  get: function get() {\n    return _long[\"default\"];\n  }\n});\nexports.base64FromBytes = base64FromBytes;\nexports.bytesFromBase64 = bytesFromBase64;\nexports.fromDuration = fromDuration;\nexports.fromJsonTimestamp = fromJsonTimestamp;\nexports.fromTimestamp = fromTimestamp;\nexports.isObject = isObject;\nexports.isSet = isSet;\nexports.omitDefault = omitDefault;\nexports.setPaginationParams = void 0;\nexports.toDuration = toDuration;\nexports.toTimestamp = toTimestamp;\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\nvar _m0 = _interopRequireWildcard(require(\"protobufjs/minimal\"));\nvar _long = _interopRequireDefault(require(\"long\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || _typeof3(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj[\"default\"] = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n/**\n* This file and any referenced files were automatically generated by @osmonauts/telescope@0.99.0\n* DO NOT MODIFY BY HAND. Instead, download the latest proto files for your chain\n* and run the transpile command or yarn proto command to regenerate this bundle.\n*/\n\n// @ts-ignore\nif (_m0.util.Long !== _long[\"default\"]) {\n  _m0.util.Long = _long[\"default\"];\n  _m0.configure();\n}\nvar globalThis = function () {\n  if (typeof globalThis !== 'undefined') return globalThis;\n  if (typeof self !== 'undefined') return self;\n  if (typeof window !== 'undefined') return window;\n  if (typeof global !== 'undefined') return global;\n  throw 'Unable to locate global object';\n}();\nvar atob = globalThis.atob || function (b64) {\n  return globalThis.Buffer.from(b64, 'base64').toString('binary');\n};\nfunction bytesFromBase64(b64) {\n  var bin = atob(b64);\n  var arr = new Uint8Array(bin.length);\n  for (var i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\nvar btoa = globalThis.btoa || function (bin) {\n  return globalThis.Buffer.from(bin, 'binary').toString('base64');\n};\nfunction base64FromBytes(arr) {\n  var bin = [];\n  arr.forEach(function (_byte) {\n    bin.push(String.fromCharCode(_byte));\n  });\n  return btoa(bin.join(''));\n}\n;\nfunction omitDefault(input) {\n  if (typeof input === \"string\") {\n    return input === \"\" ? undefined : input;\n  }\n  if (typeof input === \"number\") {\n    return input === 0 ? undefined : input;\n  }\n  if (_long[\"default\"].isLong(input)) {\n    return input.isZero() ? undefined : input;\n  }\n  throw new Error(\"Got unsupported type \".concat((0, _typeof2[\"default\"])(input)));\n}\n;\nfunction toDuration(duration) {\n  return {\n    seconds: _long[\"default\"].fromNumber(Math.floor(parseInt(duration) / 1000000000)),\n    nanos: parseInt(duration) % 1000000000\n  };\n}\n;\nfunction fromDuration(duration) {\n  return (parseInt(duration.seconds.toString()) * 1000000000 + duration.nanos).toString();\n}\n;\nfunction isSet(value) {\n  return value !== null && value !== undefined;\n}\n;\nfunction isObject(value) {\n  return (0, _typeof2[\"default\"])(value) === 'object' && value !== null;\n}\n;\n;\n;\n;\nvar setPaginationParams = function setPaginationParams(options, pagination) {\n  if (!pagination) {\n    return options;\n  }\n  if (typeof (pagination === null || pagination === void 0 ? void 0 : pagination.countTotal) !== \"undefined\") {\n    options.params['pagination.count_total'] = pagination.countTotal;\n  }\n  if (typeof (pagination === null || pagination === void 0 ? void 0 : pagination.key) !== \"undefined\") {\n    // String to Uint8Array\n    // let uint8arr = new Uint8Array(Buffer.from(data,'base64')); \n\n    // Uint8Array to String\n    options.params['pagination.key'] = Buffer.from(pagination.key).toString('base64');\n  }\n  if (typeof (pagination === null || pagination === void 0 ? void 0 : pagination.limit) !== \"undefined\") {\n    options.params[\"pagination.limit\"] = pagination.limit.toString();\n  }\n  if (typeof (pagination === null || pagination === void 0 ? void 0 : pagination.offset) !== \"undefined\") {\n    options.params[\"pagination.offset\"] = pagination.offset.toString();\n  }\n  if (typeof (pagination === null || pagination === void 0 ? void 0 : pagination.reverse) !== \"undefined\") {\n    options.params['pagination.reverse'] = pagination.reverse;\n  }\n  return options;\n};\nexports.setPaginationParams = setPaginationParams;\n;\nfunction toTimestamp(date) {\n  var seconds = numberToLong(date.getTime() / 1000);\n  var nanos = date.getTime() % 1000 * 1000000;\n  return {\n    seconds: seconds,\n    nanos: nanos\n  };\n}\n;\nfunction fromTimestamp(t) {\n  var millis = t.seconds.toNumber() * 1000;\n  millis += t.nanos / 1000000;\n  return new Date(millis);\n}\n;\nvar fromJSON = function fromJSON(object) {\n  return {\n    seconds: isSet(object.seconds) ? _long[\"default\"].fromString(object.seconds) : _long[\"default\"].ZERO,\n    nanos: isSet(object.nanos) ? Number(object.nanos) : 0\n  };\n};\nvar timestampFromJSON = function timestampFromJSON(object) {\n  return {\n    seconds: isSet(object.seconds) ? _long[\"default\"].fromValue(object.seconds) : _long[\"default\"].ZERO,\n    nanos: isSet(object.nanos) ? Number(object.nanos) : 0\n  };\n};\nfunction fromJsonTimestamp(o) {\n  if (o instanceof Date) {\n    return toTimestamp(o);\n  } else if (typeof o === \"string\") {\n    return toTimestamp(new Date(o));\n  } else {\n    return timestampFromJSON(o);\n  }\n}\nfunction numberToLong(number) {\n  return _long[\"default\"].fromNumber(number);\n}","map":null,"metadata":{},"sourceType":"script"}